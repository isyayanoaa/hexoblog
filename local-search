<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计网碎片</title>
    <link href="/2023/10/11/%E8%AE%A1%E7%BD%91%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/"/>
    <url>/2023/10/11/%E8%AE%A1%E7%BD%91%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="计网碎片"><a href="#计网碎片" class="headerlink" title="计网碎片"></a>计网碎片</h1><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>内网穿透（Intranet Penetration）是一种网络技术，允许外部网络（例如公共互联网）访问位于内部网络（私有网络或内部网络）的资源。内网穿透通常用于以下情况：</p><ol><li><strong>远程访问内部网络：</strong> 允许外部用户或设备通过公共互联网访问位于内部网络的服务器、摄像头、数据库等资源，实现远程访问和控制。</li><li><strong>开发和测试环境：</strong> 在开发和测试过程中，开发人员可能需要从外部访问内部网络中的应用程序或服务，以便进行调试、测试和开发。</li><li><strong>局域网游戏：</strong> 在局域网游戏中，玩家可能需要在不同的物理位置或网络中进行游戏。内网穿透可以帮助玩家在不同的局域网中建立直接连接，以实现游戏的多人联机功能。</li><li><strong>IoT 设备管理：</strong> 在物联网（IoT）应用中，远程管理和监控 IoT 设备是一个常见需求。内网穿透可以帮助实现远程访问和管理 IoT 设备。</li></ol><p>实现内网穿透通常需要使用特定的工具或服务，这些工具和服务可以将外部网络请求转发到内部网络中的指定设备或服务器。以下是一些常见的内网穿透方法：</p><ol><li><strong>反向代理（Reverse Proxy）：</strong> 使用反向代理服务器将外部请求代理到内部服务器。常见的反向代理工具包括Nginx和Apache。</li><li><strong>端口映射（Port Forwarding）：</strong> 在路由器上配置端口映射规则，将外部请求的特定端口映射到内部网络中的设备或服务器上。</li><li><strong>VPN（Virtual Private Network）：</strong> 使用VPN技术建立外部网络与内部网络之间的加密通道，使得外部设备可以像在内部网络中一样访问内部资源。</li><li><strong>专用内网穿透服务：</strong> 有一些专门的内网穿透服务提供商，例如Ngrok、Serveo等，它们提供了简单易用的方式来实现内网穿透，用户只需注册账户并配置相应的参数即可。</li></ol><h2 id="反向代理（Forward-Proxy）"><a href="#反向代理（Forward-Proxy）" class="headerlink" title="反向代理（Forward Proxy）"></a>反向代理（Forward Proxy）</h2><p>反向代理是代理服务器位于<strong>原始服务器和客户端之间的服务器</strong>。当客户端发送请求时，请求首先被发送到<strong>反向代理服务器</strong>，代理服务器将请求转发到<strong>一个或多个真实的服务器上</strong>，这些真实服务器响应请求，<strong>反向代理再将响应返回给客户端</strong>。客户端不知道真实服务器是谁，因为它只与反向代理服务器通信。反向代理常用于以下情况：</p><ul><li><strong>负载均衡：</strong> 反向代理可以将请求分发到多个服务器上，以实现负载均衡，确保每台服务器的负载相对均匀，提高系统的性能和可靠性。</li><li><strong>SSL终结（SSL Termination）：</strong> 反向代理可以处理SSL&#x2F;TLS加密和解密，减轻了原始服务器的负担，提高了安全性。</li><li><strong>安全性和隐藏真实服务器：</strong> 反向代理可以隐藏真实服务器的信息，增加了网络安全性，外部客户端只能看到反向代理服务器。</li><li><strong>缓存和加速：</strong> 反向代理可以缓存静态内容，提高网站的访问速度。</li></ul><h2 id="正向代理（Reverse-Proxy）"><a href="#正向代理（Reverse-Proxy）" class="headerlink" title="正向代理（Reverse Proxy）"></a>正向代理（Reverse Proxy）</h2><p>正向代理是代理服务器位于客户端和原始服务器之间的服务器。当客户端发起请求时，请求首先被发送到正向代理服务器，然后由代理服务器将请求转发到目标服务器。客户端通常不知道真实的服务器是谁，因为它只与代理服务器通信。正向代理常用于以下情况：</p><ul><li><strong>访问受限制的内容：</strong> 如果客户端无法直接访问某些受限制或被封锁的网站，可以通过正向代理服务器访问这些网站，代理服务器将请求发送到目标网站并将响应返回给客户端。</li><li><strong>匿名访问：</strong> 正向代理可以隐藏客户端的真实IP地址，从而实现匿名访问网站的目的。</li><li><strong>访问速度优化：</strong> 正向代理服务器可以缓存常用的资源，提高客户端的访问速度。</li></ul><p>总结来说，正向代理是代理客户端，隐藏客户端的真实信息，而反向代理是代理服务器，隐藏服务器的真实信息，同时具备负载均衡和性能优化的功能。</p><p><strong>其实正向代理和反向代理的模式结构图是一样的，不过只是处理的任务不同，担任的角色不同，代理服务器永远都是一个“中间人”</strong></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202310111723828.png" alt="image-20231011172349754"></p><h2 id="内网穿透的反向代理过程"><a href="#内网穿透的反向代理过程" class="headerlink" title="内网穿透的反向代理过程"></a>内网穿透的反向代理过程</h2><p>当外部用户通过公共互联网访问内部网络中的资源时，他们实际上是连接到了反向代理服务器。外部用户的请求首先到达反向代理服务器，然后反向代理服务器将请求转发到内部网络中的真实服务器上。这样，外部用户不直接与内部服务器通信，而是通过反向代理进行通信。</p><p>内网穿透服务使用反向代理的原理来实现外部网络访问内部网络资源。这种方式有助于提高内部网络的安全性，因为外部用户无法直接访问内部网络中的真实服务器，只能与反向代理服务器通信。同时，内网穿透服务还可以提供一些额外的功能，例如负载均衡、SSL终结、缓存等，以优化性能和安全性。</p><h2 id="反向代理具体例子"><a href="#反向代理具体例子" class="headerlink" title="反向代理具体例子"></a>反向代理具体例子</h2><p><strong>反向代理的例子（网站负载均衡）：</strong></p><ol><li><strong>客户端访问网站：</strong> 客户端在浏览器中输入购物网站的URL，发起访问请求。</li><li><strong>请求到达反向代理服务器：</strong> 请求首先到达位于公共互联网和内部网络之间的反向代理服务器。</li><li><strong>反向代理服务器负载均衡：</strong> 反向代理服务器会将请求分发给多台内部服务器中的其中一台，以实现负载均衡。</li><li><strong>内部服务器处理请求：</strong> 被选中的内部服务器处理客户端的请求，可能包括检索数据库、生成网页内容等操作。</li><li><strong>内部服务器返回响应：</strong> 内部服务器将生成的网页内容或其他响应数据发送回反向代理服务器。</li><li><strong>反向代理服务器将响应传回客户端：</strong> 反向代理服务器接收到内部服务器的响应后，将数据传回到客户端的浏览器中。</li><li><strong>客户端显示网页内容：</strong> 客户端浏览器接收到数据后，显示网页内容。</li></ol><p>在这个例子中，反向代理服务器帮助内部服务器处理客户端的请求，实现了负载均衡和性能优化，并且客户端只知道它在与反向代理服务器通信，而不知道内部服务器的真实身份。</p><p>该例子中提出的内部服务器是托管在一个内部网络或私有网络中的服务器。这个服务器不直接面向公共互联网，而是在内部网络中，供内部网络的设备（例如公司内部员工的电脑、内部应用程序、数据库等）使用，只在内部网络中可访问。</p><h2 id="正向代理具体例子"><a href="#正向代理具体例子" class="headerlink" title="正向代理具体例子"></a>正向代理具体例子</h2><p><strong>正向代理的例子（使用翻墙工具）：</strong></p><ol><li><strong>客户端使用翻墙工具：</strong> 你的电脑（客户端）上安装了一个翻墙工具（例如VPN软件、Shadowsocks等）。</li><li><strong>客户端连接到正向代理服务器：</strong> 当你启动翻墙工具并连接到服务器时，你的请求会被发送到一个位于海外的正向代理服务器。</li><li><strong>代理服务器请求目标网站：</strong> 正向代理服务器收到你的请求后，会代表你向目标网站（例如YouTube、Facebook等）发起请求。</li><li><strong>目标网站返回响应：</strong> 目标网站收到代理服务器的请求后，会返回响应数据。</li><li><strong>代理服务器将响应传回客户端：</strong> 代理服务器接收到目标网站的响应后，将数据传回到你的电脑上。</li><li><strong>客户端解析并显示网页内容：</strong> 你的电脑接收到数据后，翻墙工具会解析响应，并在你的浏览器上显示目标网站的内容。</li></ol><p>这个过程中，正向代理服务器帮助你访问了被封锁的网站，同时隐藏了你的真实IP地址，保护了你的隐私。</p>]]></content>
    
    
    <categories>
      
      <category>计网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cmake</title>
    <link href="/2023/09/03/Cmake/"/>
    <url>/2023/09/03/Cmake/</url>
    
    <content type="html"><![CDATA[<p><strong>CMake</strong> 是一个<strong>项目构建工具</strong>，并且是<strong>跨平台</strong>的。关于项目构建我们所熟知的还有<strong>Makefile</strong>（通过 make 命令进行项目的构建），大多是IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写 makefile，会发现，makefile 通常依赖于当前的编译平台，而且编写 makefile 的工作量比较大，解决依赖关系时也容易出错。</p><p>而 CMake 恰好能解决上述问题， 其允许开发者指定整个工程的编译流程，在根据编译平台，自动生成本地化的Makefile和工程文件，最后用户只需make编译即可，所以可以把CMake看成一款自动生成 Makefile的工具。</p><span id="more"></span><h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><h2 id="1、CMake的使用"><a href="#1、CMake的使用" class="headerlink" title="1、CMake的使用"></a>1、CMake的使用</h2><p>CMake支持大写、小写、混合大小写的命令。如果在编写CMakeLists.txt文件时使用的工具有对应的命令提示，那么大小写随缘即可，不要太过在意。</p><h3 id="1-1注释"><a href="#1-1注释" class="headerlink" title="1.1注释"></a>1.1注释</h3><h4 id="1-1-1注释行"><a href="#1-1-1注释行" class="headerlink" title="1.1.1注释行"></a>1.1.1注释行</h4><p>CMake使用#进行<strong>行注释</strong>，可以放在任何位置。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 这是一个CMakeLists.txt文件</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h4 id="1-1-2注释块"><a href="#1-1-2注释块" class="headerlink" title="1.1.2注释块"></a>1.1.2注释块</h4><p>CMake使用**#[ [ ] ]<strong>形式进行</strong>块注释**</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#[[这是一个CMakeLists.txt文件</span><br><span class="hljs-comment">这是一个CMakeLists.txt文件</span><br><span class="hljs-comment">这是一个CMakeLists.txt文件</span><br><span class="hljs-comment">]]</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>1</p><h3 id="1-2源文件"><a href="#1-2源文件" class="headerlink" title="1.2源文件"></a>1.2源文件</h3><ul><li><strong>add.cpp</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>sub.cpp</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-comment">// 你好</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a-b;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>mult.cpp</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a*b;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>div.c</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)a/b;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>head.h</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _HEAD_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _HEAD_H</span><br><span class="hljs-comment">// 加法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-comment">// 减法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-comment">// 乘法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-comment">// 除法</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li><strong>main.c</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">12</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d, b = %d\n&quot;</span>, a, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a + b = %d\n&quot;</span>, <span class="hljs-built_in">add</span>(a, b));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a - b = %d\n&quot;</span>, <span class="hljs-built_in">subtract</span>(a, b));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a * b = %d\n&quot;</span>, <span class="hljs-built_in">multiply</span>(a, b));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a / b = %f\n&quot;</span>, <span class="hljs-built_in">divide</span>(a, b));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>文件结构目录：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── add.c<br>├── div.c<br>├── head.h<br>├── main.c<br>├── mult.c<br>└── sub.c<br></code></pre></td></tr></table></figure><p>添加CMakeLists.txt文件，内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">add_executable</span>(app add.cpp div.cpp main.cpp mult.cpp sub.cpp)<br></code></pre></td></tr></table></figure><p><strong>cmake_minimum_required</strong>：指定使用的 cmake 的最低版本</p><p>​可选，非必需，如果不加可能会有警告</p><p><strong>project</strong>：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言(默认支持所有语言)，如果不需要这些都是可以忽略的，只需要指出工程名字</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># PROJECT 指令的语法是：</span><br><span class="hljs-keyword">project</span>(&lt;<span class="hljs-keyword">PROJECT</span>-NAME&gt; [&lt;language-name&gt;...])<br><span class="hljs-keyword">project</span>(&lt;<span class="hljs-keyword">PROJECT</span>-NAME&gt;<br>       [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]<br>       [DESCRIPTION &lt;<span class="hljs-keyword">project</span>-description-<span class="hljs-keyword">string</span>&gt;]<br>       [HOMEPAGE_URL &lt;url-<span class="hljs-keyword">string</span>&gt;]<br>       [LANGUAGES &lt;language-name&gt;...])<br></code></pre></td></tr></table></figure><p><strong>add_executable</strong>：定义工程会生成一个可执行程序</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(可执行程序名 源文件名称)<br></code></pre></td></tr></table></figure><p>这里的可执行程序名和project中的项目名没有任何关系</p><p>源文件名可以是一个也可以是多个，如果有多个可以用<strong>空格或;间隔</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 样式1</span><br><span class="hljs-keyword">add_executable</span>(app add.cpp div.cpp main.cpp mult.cpp sub.cpp)<br><span class="hljs-comment"># 样式2</span><br><span class="hljs-keyword">add_executable</span>(app add.cpp;div.cpp;main.cpp;mult.cpp;sub.cpp)<br></code></pre></td></tr></table></figure><p>执行CMake命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">cmake 命令原型</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake CMakeLists.txt文件所在路径</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── add.c<br>├── CMakeLists.txt<br>├── div.c<br>├── head.h<br>├── main.c<br>├── mult.c<br>└── sub.c<br><br>0 directories, 7 files<br>robin@OS:~/Linux/3Day/calc$ cmake .<br></code></pre></td></tr></table></figure><p>“cmake .” 代表执行当前目录下的cmake脚本文件</p><p>当执行cmake命令后，CMakeLists.txt中的命令就会被执行，所以有一定要注意给cmake命令指定路径的时候不能出错</p><p>执行命令之后，看一下源文件所在目录中是否多了一些文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree -L 1</span><br>.<br>├── add.c<br>├── CMakeCache.txt         # new add file<br>├── CMakeFiles             # new add dir<br>├── cmake_install.cmake    # new add file<br>├── CMakeLists.txt<br>├── div.c<br>├── head.h<br>├── main.c<br>├── Makefile               # new add file<br>├── mult.c<br>└── sub.c<br></code></pre></td></tr></table></figure><p>我们可以看到在对应耳朵目录下生成了一个<strong>makefile</strong>文件，此时再执行<strong>make</strong>命令，就可以对项目进行构建得到所需的可执行程序了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>Scanning dependencies of target app<br>[ 16%] Building C object CMakeFiles/app.dir/add.c.o<br>[ 33%] Building C object CMakeFiles/app.dir/div.c.o<br>[ 50%] Building C object CMakeFiles/app.dir/main.c.o<br>[ 66%] Building C object CMakeFiles/app.dir/mult.c.o<br>[ 83%] Building C object CMakeFiles/app.dir/sub.c.o<br><span class="hljs-meta prompt_">[100%</span><span class="language-bash">] Linking C executable app</span><br><span class="hljs-meta prompt_">[100%</span><span class="language-bash">] Built target app</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看可执行程序是否已经生成</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree -L 1</span><br>.<br>├── add.c<br>├── app# 生成的可执行程序<br>├── CMakeCache.txt<br>├── CMakeFiles<br>├── cmake_install.cmake<br>├── CMakeLists.txt<br>├── div.c<br>├── head.h<br>├── main.c<br>├── Makefile<br>├── mult.c<br>└── sub.c<br></code></pre></td></tr></table></figure><p>最终可执行的app就被编译出来了（这个名字是在CMakeLists.txt中指定的）</p><h3 id="1-3build目录创建"><a href="#1-3build目录创建" class="headerlink" title="1.3build目录创建"></a>1.3build目录创建</h3><p>通过上面的例子可以看出，如果在CMakeLists.txt文件所在目录执行了cmake命令之后就会生成一些目录和文件（包括 makefile 文件），如果再基于makefile文件执行make命令，程序在编译过程中还会生成一些中间文件和一个可执行文件，这样会导致整个项目目录看起来很混乱，不太容易管理和维护，此时我们就可以把生成的这些与项目源码无关的文件统一放到一个对应的目录里边，比如将这个目录命名为<strong>build:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake ..</span><br>-- The C compiler identification is GNU 5.4.0<br>-- The CXX compiler identification is GNU 5.4.0<br>-- Check for working C compiler: /usr/bin/cc<br>-- Check for working C compiler: /usr/bin/cc -- works<br>-- Detecting C compiler ABI info<br>-- Detecting C compiler ABI info - done<br>-- Detecting C compile features<br>-- Detecting C compile features - done<br>-- Check for working CXX compiler: /usr/bin/c++<br>-- Check for working CXX compiler: /usr/bin/c++ -- works<br>-- Detecting CXX compiler ABI info<br>-- Detecting CXX compiler ABI info - done<br>-- Detecting CXX compile features<br>-- Detecting CXX compile features - done<br>-- Configuring done<br>-- Generating done<br>-- Build files have been written to: /home/robin/Linux/build<br></code></pre></td></tr></table></figure><p>现在cmake命令是在build目录中执行的，但是CMakeLists.txt文件是build目录的上一级目录中，所以cmake 命令后指定的路径为..，即当前目录的上一级目录。</p><p>当命令执行完毕之后，在build目录中会生成一个makefile文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree build -L 1</span><br>build<br>├── CMakeCache.txt<br>├── CMakeFiles<br>├── cmake_install.cmake<br>└── Makefile<br><br>1 directory, 3 files<br></code></pre></td></tr></table></figure><p>这样就可以在build目录中执行make命令编译项目，生成的相关文件自然也就被存储到build目录中了.</p><h3 id="1-4set的使用"><a href="#1-4set的使用" class="headerlink" title="1.4set的使用"></a>1.4set的使用</h3><h4 id="1-4-1定义变量"><a href="#1-4-1定义变量" class="headerlink" title="1.4.1定义变量"></a>1.4.1定义变量</h4><p>定义一个变量，<strong>将文件名对应的字符串存储起来</strong>，在cmake里定义变量需要使用<strong>set</strong>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># set指令的语法</span><br><span class="hljs-comment"># []中的参数为可选项，如不需要可以不写</span><br><span class="hljs-keyword">set</span>(VAR [BALUE] [CACHE TYPE DOCSTRING [FORCE]])<br></code></pre></td></tr></table></figure><p>VAR：变量名</p><p>VALUE:变量值</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 方式1: 各个源文件之间使用空格间隔</span><br><span class="hljs-comment"># set(SRC_LIST add.c  div.c   main.c  mult.c  sub.c)</span><br><br><span class="hljs-comment"># 方式2: 各个源文件之间使用分号 ; 间隔</span><br><span class="hljs-keyword">set</span>(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)<br><span class="hljs-keyword">add_executable</span>(app  <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p><strong>各个源文件之间可以使用空格间隔，也可以使用分号间隔</strong></p><h4 id="1-4-2指定使用的C-标准"><a href="#1-4-2指定使用的C-标准" class="headerlink" title="1.4.2指定使用的C++标准"></a>1.4.2指定使用的C++标准</h4><p>在编写C++程序的时候，可能会用到C++11，C++14，C++17，C++20等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ *.cpp -std=c++11 -o app<br></code></pre></td></tr></table></figure><p>可以在编译的时候通过参数-std&#x3D;c++11指定出要是用c++11标准编译程序，C++标准对应有一宏叫做DCMAKE_CXX_STANDARD。在CMake中想要制定C++标准有两种方式：</p><ol><li>在CMakeLists.txt中通过set命令指定</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#增加-std=c++11</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-comment">#增加-std=c++14</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)<br><span class="hljs-comment">#增加-std=c++17</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br></code></pre></td></tr></table></figure><p>​2.在执行cmake命令的时候指出这个宏的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">增加 -std=c++11</span><br>cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11<br><span class="hljs-meta prompt_"># </span><span class="language-bash">增加 -std=c++14</span><br>cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14<br><span class="hljs-meta prompt_"># </span><span class="language-bash">增加 -std=c++17</span><br>cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17<br></code></pre></td></tr></table></figure><p>在上边例子中CMake后边的路径要根据实际情况酌情修改</p><h4 id="1-4-3指定输出路径"><a href="#1-4-3指定输出路径" class="headerlink" title="1.4.3指定输出路径"></a>1.4.3指定输出路径</h4><p>在CMake中指定<strong>可执行程序输出的路径</strong>，也对应一个宏，叫做<strong>EXECUTABLE_OUTPUT_PATH</strong>，它的值还是通过set命令进行设置:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(HOME /home/jianwu/Linux)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;HOME&#125;</span>/bin)<br></code></pre></td></tr></table></figure><p>上述例子是先定一个自定义变量HOME，里边存储一个绝对路径，然后将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏</p><p><strong>由于可执行程序是基于 cmake 命令生成的 makefile 文件然后再执行 make 命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径 .&#x2F;xxx&#x2F;xxx，那么这个路径中的 .&#x2F; 对应的就是 makefile 文件所在的那个目录。</strong></p><h3 id="1-5搜索文件"><a href="#1-5搜索文件" class="headerlink" title="1.5搜索文件"></a>1.5搜索文件</h3><p>如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用<strong>aux_source_directory</strong>命令或者<strong>file</strong>命令。</p><h4 id="1-5-1aux-source-directory"><a href="#1-5-1aux-source-directory" class="headerlink" title="1.5.1aux_source_directory"></a>1.5.1<strong>aux_source_directory</strong></h4><p>在Cmake中使用<strong>aux_source_directory</strong>命令可以查找某个路径下的<strong>所有源文件</strong>，命令格式为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">aux_source_directory</span>(&lt; dir &gt; &lt; variable &gt;)<br></code></pre></td></tr></table></figure><p><strong>dir：要搜索的目录</strong></p><p><strong>variable：将从dir目录下搜索到的源文件列表存储到该变量中</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(CALC)<br>inlude_directories(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-comment"># 搜索src目录下的源文件</span><br>aux_source_directories(<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRC_LIST)<br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p><strong>PROJECT_SOURCE_DIR：代表顶级CMakeLists.txt所在的目录</strong></p><p><strong>CMAKE_CURRENT_SOURCE_DIR：代表当前访问的CMakeLists.txt所在的目录</strong></p><h4 id="1-5-2file"><a href="#1-5-2file" class="headerlink" title="1.5.2file"></a>1.5.2file</h4><p>CMake中为我们提供了搜索文件的命令，他就是<strong>file</strong>（当然，除了搜索以外通过 <strong>file 还可以做其他事情</strong>）。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)<br></code></pre></td></tr></table></figure><p>GLOB：<strong>将指定目录下搜索到的满足条件的所有文件名生成一个列表</strong>，并将其存储到变量中</p><p>GLOB_RECURSE：<strong>递归搜索指定目录</strong>，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中</p><p>关于要搜索的文件路径和类型可加双引号，也可不加:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB MAIN_HEAD <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR/src/*.h&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="1-6包含头文件"><a href="#1-6包含头文件" class="headerlink" title="1.6包含头文件"></a>1.6包含头文件</h3><p>在编译项目源文件的时候，很多时候都需要<strong>将源文件对应的头文件路径</strong>指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是<strong>include_directories</strong>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">include_directories</span>(headpath)<br></code></pre></td></tr></table></figure><p>举例说明，有源文件若干，其目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── build<br>├── CMakeLists.txt<br>├── include<br>│   └── head.h<br>└── src<br>    ├── add.cpp<br>    ├── div.cpp<br>    ├── main.cpp<br>    ├── mult.cpp<br>    └── sub.cpp<br><br>3 directories, 7 files<br></code></pre></td></tr></table></figure><p>CMakeLists.txt文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-keyword">set</span>(HOME /home/robin/Linux/calc)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;HOME&#125;</span>/bin/)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC_LIST <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-keyword">add_executable</span>(app  <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="1-7制作动态库或静态库"><a href="#1-7制作动态库或静态库" class="headerlink" title="1.7制作动态库或静态库"></a>1.7制作动态库或静态库</h3><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些<strong>静态库或动态库提供给第三方使用</strong>，下面是在cmake中生成这两类库文件的方法。</p><h4 id="1-7-1制作静态库"><a href="#1-7-1制作静态库" class="headerlink" title="1.7.1制作静态库"></a>1.7.1制作静态库</h4><p>在cmake中，如果要制作静态库，需要使用的命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(库名称 STATIC 源文件<span class="hljs-number">1</span> [源文件<span class="hljs-number">2</span>] ...)<br></code></pre></td></tr></table></figure><p>在Linux中，静态库名字分为三部分：<strong>lib</strong>+<strong>库名字</strong>+<strong>.a</strong>，粗出只需要指出库的名字就可以了，另外两部分在生成该文件的时候会自动补充。</p><p>在Windows中虽然库名和Linux格式不同，单页只需指定出名字即可</p><p>下面有一个目录，需要将src目录中的源文件编译成静态库，然后再使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── build<br>├── CMakeLists.txt<br>├── include           # 头文件目录<br>│   └── head.h<br>├── main.cpp          # 用于测试的源文件<br>└── src               # 源文件目录<br>    ├── add.cpp<br>    ├── div.cpp<br>    ├── mult.cpp<br>    └── sub.cpp<br></code></pre></td></tr></table></figure><p>根据如上的结构，编译CMakeLists.txt文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC_LIST <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-keyword">add_library</span>(calc STATIC <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p>这样就生成对应的动态库文件<strong>libcalc.a</strong></p><h4 id="1-7-2制作动态库"><a href="#1-7-2制作动态库" class="headerlink" title="1.7.2制作动态库"></a>1.7.2制作动态库</h4><p>在camke中，如果要制作动态库，需要使用的命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(库名称 SHARED 源文件<span class="hljs-number">1</span> [源文件<span class="hljs-number">2</span>] ...)<br></code></pre></td></tr></table></figure><p>在Linux中，动态库名字分为三部分：<strong>lib</strong>+<strong>库名字</strong>+<strong>.so</strong>，此处只需要指出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p><p>在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。</p><p>根据上面的目录结构，CMakeLists.txt如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC_LIST <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-keyword">add_library</span>(calc SHARED $(SRC_LIST))<br></code></pre></td></tr></table></figure><p>这样最终就会生成对应的动态库文件<strong>libcalc.so</strong>。</p><h4 id="1-7-3指定输出路径"><a href="#1-7-3指定输出路径" class="headerlink" title="1.7.3指定输出路径"></a>1.7.3指定输出路径</h4><p><strong>方式1 - 适用于动态库</strong></p><p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。由于在Linux下生成的动态库默认是有执行权限的，所以可以按照生成可执行程序的方式去指定它生成的目录：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC_LIST <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)<br><span class="hljs-comment"># 设置动态库生成路径</span><br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-keyword">add_library</span>(calc SHARED <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p>对于这种方式来说，其实就是通过set命令给<strong>EXECUTABLE_OUTPUT_PATH</strong>宏设置了一个路径，这个路径就是可执行文件生成的路径。</p><p><strong>方式2 - 都适用</strong></p><p>由于在Linux下生成的<strong>静态库默认不具有可执行权限</strong>，所以在指定静态库生成的路径的时候就<strong>不能使用EXECUTABLE_OUTPUT_PATH宏</strong>了，而应该使用<strong>LIBRARY_OUTPUT_PATH</strong>，<strong>这个宏对应静态库文件和动态库文件都适用</strong>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC_LIST <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)<br><span class="hljs-comment"># 设置动态库/静态库生成路径</span><br><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-comment"># 生成动态库</span><br><span class="hljs-comment">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span><br><span class="hljs-comment"># 生成静态库</span><br><span class="hljs-keyword">add_library</span>(calc STATIC <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="1-8包含库文件"><a href="#1-8包含库文件" class="headerlink" title="1.8包含库文件"></a>1.8包含库文件</h3><p>在编写程序的过程中，可能会用到一些<strong>系统提供的动态库</strong>或者<strong>自己制作出的动态库</strong>或者<strong>静态库文件</strong>，cmake中也为我们提供了相关的加载动态库的命令。</p><h4 id="1-8-1链接静态库"><a href="#1-8-1链接静态库" class="headerlink" title="1.8.1链接静态库"></a>1.8.1链接静态库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">src<br>├── add.cpp<br>├── div.cpp<br>├── main.cpp<br>├── mult.cpp<br>└── sub.cpp<br></code></pre></td></tr></table></figure><p>把上边的src目录中的<strong>add.cpp   div.cpp   mult.cpp   sub.cpp</strong>编译成一个静态库文件<strong>libcalc.a</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span> <br>.<br>├── build<br>├── CMakeLists.txt<br>├── include<br>│   └── head.h<br>├── lib<br>│   └── libcalc.a     # 制作出的静态库的名字<br>└── src<br>    └── main.cpp<br><br>4 directories, 4 files<br></code></pre></td></tr></table></figure><p>在cmake中，链接静态库的命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt; ... ])<br></code></pre></td></tr></table></figure><p>参数：制定出要链接的静态库的名字</p><ul><li>可以是libxxx.a</li><li>也可以是xxx</li></ul><p>如果该静态库<strong>不是系统提供的</strong>（自己制作或使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来</p><p>PS：<strong>这里说的不是系统提供的意思是不在系统环境变量中的库</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">link_directories</span>(&lt;lib path&gt;)<br></code></pre></td></tr></table></figure><p>这样，修改之后的CMakeLists.txt文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-comment"># 搜索指定目录下源文件</span><br><span class="hljs-keyword">file</span>(GLOB SRC_LIST <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-comment"># 包含头文件路径</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-comment"># 包含静态库路径</span><br><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-comment"># 链接静态库</span><br><span class="hljs-keyword">link_libraries</span>(calc)<br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p>添加了第8行的代码，就可以根据参数指定的路径找到这个静态库了。</p><p>PS：link_libraries()也可以用于链接静态库</p><h4 id="1-8-2链接动态库"><a href="#1-8-2链接动态库" class="headerlink" title="1.8.2链接动态库"></a>1.8.2链接动态库</h4><p>在程序编写过程中，除了在项目中引入静态库，好多时候也会使用一些标准的或者第三方提供的一些动态库，关于动态库的制作、使用以及在内存中的加载方式和静态库都是不同的。</p><p>在cmake中链接动态库的命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(<br>    &lt;<span class="hljs-keyword">target</span>&gt; <br>    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... <br>    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)<br></code></pre></td></tr></table></figure><p><strong>target</strong>：<strong>指定要加载动态库的文件的名字</strong></p><ul><li>该文件可能是一个源文件</li><li>该文件可能是一个动态库文件</li><li>该文件可能是一个可执行文件</li></ul><p><strong>PRIVATE|PUBLIC|INTERFACE</strong>：<strong>动态库的访问权限，默认为PUBLIC</strong></p><ul><li><p>如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，一般无需指定，使用默认的 PUBLIC 即可。</p></li><li><p>动态库的链接具有传递性，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法。</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(A B C)<br><span class="hljs-keyword">target_link_libraries</span>(D A)<br></code></pre></td></tr></table></figure><ul><li><p>PUBLIC：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。</p></li><li><p>PRIVATE：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库</p></li><li><p>INTERFACE：在interface后面引入的库不会被链接到前面的target中，只会导出符号。</p></li></ul><p><strong>动态库的链接和静态库是完全不同的：</strong></p><ul><li><p>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。</p></li><li><p>动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存</p></li></ul><p>因此，在cmake中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">TEST</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC_LIST <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)<br><span class="hljs-comment"># 添加并指定最终生成的可执行程序名</span><br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br><span class="hljs-comment"># 指定可执行程序要链接的动态库名字</span><br><span class="hljs-keyword">target_link_libraries</span>(app pthread)<br></code></pre></td></tr></table></figure><p><strong>在target_link_libraries(app pthread)中：</strong></p><ul><li>app: 对应的是最终生成的可执行程序的名字</li><li>pthread：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为libpthread.so，在指定的时候一般会掐头（lib）去尾（.so）。</li></ul><p>现在，自己生成了一个动态库，对应的目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span> <br>.<br>├── build<br>├── CMakeLists.txt<br>├── include<br>│   └── head.h            # 动态库对应的头文件<br>├── lib<br>│   └── libcalc.so        # 自己制作的动态库文件<br>└── main.cpp              # 测试用的源文件<br><br>3 directories, 4 files<br></code></pre></td></tr></table></figure><p>假设在测试文件main.cpp中既使用了<strong>自己制作的动态库libcalc.so</strong>又使用了<strong>系统提供的线程库</strong>，此时CMakeLists.txt文件可以这样写：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">TEST</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC_LIST <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)<br><span class="hljs-comment"># 指定源文件或者动态库对应的头文件路径</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-comment"># 指定要链接的动态库的路径</span><br><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-comment"># 添加并生成一个可执行程序</span><br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br><span class="hljs-comment"># 指定要链接的动态库</span><br><span class="hljs-keyword">target_link_libraries</span>(app pthread calc)<br></code></pre></td></tr></table></figure><p>在 CMake 中可以在生成可执行程序之前，通过命令<strong>指定出要链接的动态库的位置</strong>，<strong>指定静态库位置使用的也是这个命令</strong>：</p><p><strong>PS：使用 target_link_libraries 命令就可以链接动态库，也可以链接静态库文件。</strong></p><h3 id="1-9日志"><a href="#1-9日志" class="headerlink" title="1.9日志"></a>1.9日志</h3><p>在CMake中可以使<strong>用户显示一条消息</strong>，该命令的名字为<strong>message</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="hljs-string">&quot;message to display&quot;</span> ...)<br></code></pre></td></tr></table></figure><ul><li>(无)：重要消息</li><li>STATUS：非重要消息</li><li>WARING：CMake警告，会继续执行</li><li>AUTHOR_WARNING：CMake警告（dev），会继续执行</li><li>SEND_ERROR：CMake错误，继续执行，但是会跳过生成的步骤</li><li>FATAL_ERROR：CMake错误，终止所有处理过程</li></ul><p>CMake的命令行工具会在<strong>stdout</strong>上显示<strong>STATUS</strong>消息，在<strong>stderr</strong>上显示<strong>其他所有消息</strong>。CMake的GUI会在它的<strong>log区域</strong>显示所有消息。</p><p>CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间的新行做为分隔符</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 输出一般日志信息</span><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)<br><span class="hljs-comment"># 输出警告信息</span><br><span class="hljs-keyword">message</span>(WARNING <span class="hljs-string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)<br><span class="hljs-comment"># 输出错误信息</span><br><span class="hljs-keyword">message</span>(FATAL_ERROR <span class="hljs-string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="1-10变量操作"><a href="#1-10变量操作" class="headerlink" title="1.10变量操作"></a>1.10变量操作</h3><h4 id="1-10-1追加"><a href="#1-10-1追加" class="headerlink" title="1.10.1追加"></a>1.10.1追加</h4><p>有时候源文件并不都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过<strong>file</strong>命令对各个目录下的源文件进行搜索，最后还需要做一个<strong>字符串拼接</strong>的操作，关于<strong>字符串拼接</strong>可以使用<strong>set</strong>命令，也可以使用<strong>list</strong>命令。</p><p><strong>使用set拼接</strong></p><p>命令格式如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(变量名<span class="hljs-number">1</span> <span class="hljs-variable">$&#123;变量名1&#125;</span> <span class="hljs-variable">$&#123;变量名2&#125;</span> ...)<br></code></pre></td></tr></table></figure><p>关于上面的命令其实就是将从<strong>第二个参数开始往后所有的字符串进行拼接</strong>，最后将结果<strong>存储到第一个参数中</strong>，如果第一个参数中原来有数据会对原数据<strong>进行覆盖</strong>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">test</span>)<br><span class="hljs-keyword">set</span>(TEMP <span class="hljs-string">&quot;hello C++&quot;</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC_1 <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)<br><span class="hljs-keyword">file</span>(GLOB SRC_2 <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)<br><span class="hljs-comment"># 追加（拼接）</span><br><span class="hljs-keyword">set</span>(SRC_1 <span class="hljs-variable">$&#123;SRC_1&#125;</span> <span class="hljs-variable">$&#123;SRC_2&#125;</span> <span class="hljs-variable">$&#123;TEMP&#125;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;message:$&#123;SRC_1&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>使用list拼接</strong></p><p>命令格式如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span>(APPEND &lt;<span class="hljs-keyword">list</span>&gt; [&lt;element&gt; ...])<br></code></pre></td></tr></table></figure><p><strong>list</strong>命令的功能别<strong>set</strong>强大，字符串拼接只是他的功能中的一个，所以需要在它第一个参数的位置<strong>指出我们要做的操作</strong>，<strong>APPEND表示数据追加</strong>，后边的参数和<strong>set</strong>就一样了。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">TEST</span>)<br><span class="hljs-keyword">set</span>(TEMP <span class="hljs-string">&quot;hello,world&quot;</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC_1 <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)<br><span class="hljs-keyword">file</span>(GLOB SRC_2 <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)<br><span class="hljs-comment"># 追加(拼接)</span><br><span class="hljs-keyword">list</span>(APPEND SRC_1 <span class="hljs-variable">$&#123;SRC_2&#125;</span> <span class="hljs-variable">$&#123;TEMP&#125;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>list中的APPEND和set其实不一样</strong></p><p><strong>set可以理解为先拿一个空变量X，然后往X中添加你需要的变量</strong></p><p><strong>但是list的APPEND是直接在X变量后边直接添加你的Y变量和Z变量</strong></p><p>在CMake中，使用<strong>set</strong>命令可以创建一个<strong>list</strong>。一个在<strong>list内部是一个由分号</strong>;分割的一组字符串。例如，<strong>set(var a b c d e)<strong>命令将会创建一个</strong>list:a;b;c;d;e</strong>，但是最终打印变量值的时候得到的是<strong>abcde</strong>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(tmp1 a;b;c;d;e)<br><span class="hljs-keyword">set</span>(tmp2 a b c d e)<br><span class="hljs-keyword">message</span>(<span class="hljs-variable">$&#123;tmp1&#125;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-variable">$&#123;tmp2&#125;</span>)<br></code></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">abcde<br>abcde<br></code></pre></td></tr></table></figure><h4 id="1-10-2字符串移除"><a href="#1-10-2字符串移除" class="headerlink" title="1.10.2字符串移除"></a>1.10.2字符串移除</h4><p>我们在通过file搜索某个目录就得到了该目录下所有的源文件，但是其中有些源文件<strong>并不是我们所需要的</strong>，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── add.cpp<br>├── div.cpp<br>├── main.cpp<br>├── mult.cpp<br>└── sub.cpp<br><br>0 directories, 5 files<br></code></pre></td></tr></table></figure><p>假如我们要制作库文件，其中并<strong>不需要main.cpp</strong>，此时就需要将main.cpp从搜索到的数据中剔除</p><p>可以使用<strong>list</strong>实现</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span>(REMOVE_ITEM &lt;<span class="hljs-keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])<br></code></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">TEST</span>)<br><span class="hljs-keyword">set</span>(TEMP <span class="hljs-string">&quot;hello C++&quot;</span> <span class="hljs-string">&quot;hello python&quot;</span> <span class="hljs-string">&quot;hello java&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-variable">$&#123;TEMP&#125;</span>)<br><span class="hljs-keyword">list</span>(REMOVE_ITEM <span class="hljs-string">&quot;hello C++&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-variable">$&#123;TEMP&#125;</span>)<br></code></pre></td></tr></table></figure><p>用<strong>file</strong>命令的例子如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">TEST</span>)<br><span class="hljs-keyword">set</span>(TEMP <span class="hljs-string">&quot;hello,world&quot;</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC_1 <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)<br><span class="hljs-comment"># 移除前日志</span><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)<br><span class="hljs-comment"># 移除 main.cpp</span><br><span class="hljs-keyword">list</span>(REMOVE_ITEM SRC_1 <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/main.cpp)<br><span class="hljs-comment"># 移除后日志</span><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p>一定要注意通过 file 命令搜索源文件的时候得到的是文件的绝对路径（<strong>在list中每个文件对应的路径都是一个item，并且都是绝对路径</strong>），那么<strong>在移除的时候也要将该文件的绝对路径指定出来</strong>才可以，否则移除操作不会成功。</p><p><strong>获取list的长度</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span>(LENGTH &lt;<span class="hljs-keyword">list</span>&gt; &lt;output variable&gt;)<br></code></pre></td></tr></table></figure><ul><li>LENGTH：子命令LENGTH用于读取列表长度</li><li><list>：当前操作的列表</li><li><output variable>：新创建的变量，用于存储列表的长度</li></ul><p><strong>读取列表中指定索引的的元素，可以指定多个索引</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span>(GET &lt;<span class="hljs-keyword">list</span>&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;)<br></code></pre></td></tr></table></figure><ul><li><list>：当前操作的列表</li><li><element index>：列表元素的索引<ul><li>从0开始编号，索引0的元素为列表中的第一个元素；</li><li>索引也可以是负数，-1表示列表的最后一个元素，-2表示列表倒数第二个元素，以此类推</li><li>当索引（不管是正还是负）超过列表的长度，运行会报错</li></ul></li><li><output variable>：新创建的变量，存储指定索引元素的返回结果，也是一个列表。</li></ul><p><strong>将列表中的元素用连接符（字符串）连接起来组成一个字符串</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span> (JOIN &lt;<span class="hljs-keyword">list</span>&gt; &lt;glue&gt; &lt;output variable&gt;)<br></code></pre></td></tr></table></figure><ul><li><list>：当前操作的列表</li><li><glue>：指定的连接符（字符串）</li><li><output variable>：新创建的变量，存储返回的字符串</li></ul><p><strong>查找列表是否存在指定的元素，若果未找到，返回-1</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span>(FIND &lt;<span class="hljs-keyword">list</span>&gt; &lt;value&gt; &lt;output variable&gt;)<br></code></pre></td></tr></table></figure><ul><li><list>：当前操作的列表</li><li><value>：需要在列表中搜索的元素</li><li><output variable>：新创建的变量<ul><li>如果列表<list>中存在<value>，那么返回<value>在列表中的索引</li><li>如果未找到则返回-1</li></ul></li></ul><p><strong>将元素追加到列表中</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span> (APPEND &lt;<span class="hljs-keyword">list</span>&gt; [&lt;element&gt; ...])<br></code></pre></td></tr></table></figure><p><strong>在list中指定的位置插入若干元素</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span>(INSERT &lt;<span class="hljs-keyword">list</span>&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])<br></code></pre></td></tr></table></figure><p><strong>将元素插入到列表的0索引位置</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span> (PREPEND &lt;<span class="hljs-keyword">list</span>&gt; [&lt;element&gt; ...])<br></code></pre></td></tr></table></figure><p><strong>将列表中最后元素移除</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span> (POP_BACK &lt;<span class="hljs-keyword">list</span>&gt; [&lt;out-var&gt;...])<br></code></pre></td></tr></table></figure><p><strong>将列表中第一个元素移除</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span> (POP_FRONT &lt;<span class="hljs-keyword">list</span>&gt; [&lt;out-var&gt;...])<br></code></pre></td></tr></table></figure><p><strong>将指定的元素从列表中移除</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span> (REMOVE_ITEM &lt;<span class="hljs-keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])<br></code></pre></td></tr></table></figure><p><strong>将指定索引的元素从列表中移除</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span> (REMOVE_AT &lt;<span class="hljs-keyword">list</span>&gt; &lt;index&gt; [&lt;index&gt; ...])<br></code></pre></td></tr></table></figure><p><strong>移除列表中的重复元素</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span> (REMOVE_DUPLICATES &lt;<span class="hljs-keyword">list</span>&gt;)<br></code></pre></td></tr></table></figure><p><strong>列表翻转</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span>(REVERSE &lt;<span class="hljs-keyword">list</span>&gt;)<br></code></pre></td></tr></table></figure><p><strong>列表排序</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">list</span> (SORT &lt;<span class="hljs-keyword">list</span>&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;])<br></code></pre></td></tr></table></figure><ul><li><strong>COMPARE</strong>：指定排序方法。有如下几种值可选：<ul><li><strong>STRING</strong>:按照字母顺序进行排序，为默认的排序方法</li><li><strong>FILE_BASENAME</strong>：如果是一系列路径名，会使用basename进行排序</li><li><strong>NATURAL</strong>：使用自然数顺序排序</li></ul></li><li><strong>CASE</strong>：指明是否大小写敏感。有如下几种值可选：<ul><li><strong>SENSITIVE</strong>: 按照大小写敏感的方式进行排序，为默认值</li><li><strong>INSENSITIVE</strong>*：按照大小写不敏感方式进行排序</li></ul></li><li><strong>ORDER</strong>：指明排序的顺序。有如下几种值可选：<ul><li><strong>ASCENDING</strong>:按照升序排列，为默认值</li><li><strong>DESCENDING</strong>：按照降序排列</li></ul></li></ul><h3 id="1-11宏定义"><a href="#1-11宏定义" class="headerlink" title="1.11宏定义"></a>1.11宏定义</h3><p>在进行程序测试的时候，我们可以在代码中添加一些<strong>宏定义</strong>，通过这些宏来<strong>控制这些代码是否生效</strong>，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUMBER  3</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I love u forever!...\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;NUMBER; ++i)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, GCC!!!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在程序的第七行对DEBUG宏进行了判断，如果该宏<strong>被定义了</strong>，那么第八行就会<strong>进行日志输出</strong>，如果<strong>没有定义这个宏</strong>，第八行就相当于被注释掉了，因此最终<strong>无法看到日志输入</strong>（上述代码中并没有定义这个宏）。</p><p>为了让测试更灵活，我们可以不在代码中定义这个宏，而是在测试的时候去把它定义出来，其中一种方式就是在gcc&#x2F;g++命令中去指定，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc test.c -DDEBUG -o app</span><br></code></pre></td></tr></table></figure><p>在gcc&#x2F;g++命令中通过参数 <strong>-D</strong>指定出要定义的<strong>宏的名字</strong>，这样就相当于在代码中定义了一个宏，其名字为<strong>DEBUG</strong>。</p><p>在CMake中我们也可以做类似的事情，对应的命令叫做<strong>add_definitions</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">add_definition(-D宏名称<span class="hljs-number">1</span> -D宏名称<span class="hljs-number">2</span> ······)<br></code></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">TEST</span>)<br><span class="hljs-comment"># 自定义宏</span><br>add_definition(-DDEBUG)<br><span class="hljs-keyword">add_executable</span>(app ./<span class="hljs-keyword">test</span>.cpp)<br></code></pre></td></tr></table></figure><h2 id="2、预定义宏"><a href="#2、预定义宏" class="headerlink" title="2、预定义宏"></a>2、预定义宏</h2><table><thead><tr><th align="center">宏</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">PROJECT_SOURCE_DIR</td><td align="center">cmake命令后紧跟的目录，一般是工程的根目录（第一个出现CMakeLists.txt的目录）</td></tr><tr><td align="center">PROJECT_BINARY_DIR</td><td align="center">执行cmake命令的目录</td></tr><tr><td align="center">CMAKE_CURRENT_SOURCE_DIR</td><td align="center">当前处理的CMakeLists.txt所在的路径</td></tr><tr><td align="center">CMAKE_CURRENT_BINARY_DIR</td><td align="center">target 编译目录</td></tr><tr><td align="center">EXECUTABLE_OUTPUT_PATH</td><td align="center">重新定义目标二进制可执行文件的存放位置</td></tr><tr><td align="center">LIBRARAY_OUTPUT_PATH</td><td align="center">重新定义目标链接库文件的存放位置</td></tr><tr><td align="center">PROJECT_NAME</td><td align="center">返回通过PROJECT指令定义的项目名称</td></tr><tr><td align="center">CMAKE_BINARY_DIR</td><td align="center">项目实际构建路径，假设在<strong>build</strong>目录进行的构建，那么得到的就是这个目录的路径</td></tr></tbody></table><h2 id="3、嵌套的CMake"><a href="#3、嵌套的CMake" class="headerlink" title="3、嵌套的CMake"></a>3、嵌套的CMake</h2><p>如果项目很大，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果<strong>只使用一个CMakeLists.txt</strong>，那么这个文件相对会比较复杂，有一种化繁为简的方式就是<strong>给每个源码目录都添加一个CMakeLists.txt文件（头文件目录不需要）</strong>，这样每个文件都不会太复杂，而且更灵活，更容易维护。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── build<br>├── calc<br>│   ├── add.cpp<br>│   ├── CMakeLists.txt<br>│   ├── div.cpp<br>│   ├── mult.cpp<br>│   └── sub.cpp<br>├── CMakeLists.txt<br>├── include<br>│   ├── calc.h<br>│   └── sort.h<br>├── sort<br>│   ├── CMakeLists.txt<br>│   ├── insert.cpp<br>│   └── select.cpp<br>├── test1<br>│   ├── calc.cpp<br>│   └── CMakeLists.txt<br>└── test2<br>    ├── CMakeLists.txt<br>    └── sort.cpp<br><br>6 directories, 15 files<br></code></pre></td></tr></table></figure><ul><li>include目录：头文件目录</li><li>cal目录：目录中的四个源文件对应的加减乘除算法<ul><li>对应的头文件是include中的calc.h</li></ul></li><li>sort目录：目录中的两个源文件对应的是插入排序和选择排序算法<ul><li>对应的头文件是include中的sort.h</li></ul></li><li>test1目录：测试目录，对加减乘除算法进行测试</li><li>test2目录：测试目录，对排序算法进行测试</li></ul><p>可以看到各个源文件目录所需要的CMakeLists.txt文件现在已经添加完毕了。</p><h3 id="3-1准备工作"><a href="#3-1准备工作" class="headerlink" title="3.1准备工作"></a>3.1准备工作</h3><h4 id="3-1-1节点关系"><a href="#3-1-1节点关系" class="headerlink" title="3.1.1节点关系"></a>3.1.1节点关系</h4><p>众所周知，Linux的目录是树状结构，所以<strong>嵌套的 CMake 也是一个树状结构</strong>，<strong>最顶层的 CMakeLists.txt 是根节点，其次都是子节点</strong>。因此，我们需要了解一些关于 CMakeLists.txt 文件变量作用域的一些信息：</p><ul><li>根节点CMakeLists.txt中的变量全局有效</li><li>父节点CMakeLists.txt中的变量可以在子节点中使用</li><li>子节点CMakeLists.txt中的变量只能在当前节点中使用</li></ul><h4 id="3-1-2添加子目录"><a href="#3-1-2添加子目录" class="headerlink" title="3.1.2添加子目录"></a>3.1.2添加子目录</h4><p>父子节点之间的关系的建立，用到如下命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])<br></code></pre></td></tr></table></figure><ul><li><strong>source_dir</strong>：指定了CMakeLists.txt源文件和代码文件的位置，其实就是指定子目录</li><li><strong>binary_dir</strong>：指定了输出文件的路径，一般不需要指定，忽略即可。</li><li><strong>EXCLUDE_FROM_ALL</strong>：在子路径下的目标默认不会被包含到父路径的ALL目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。</li></ul><p>通过这种方式CMakeLists.txt文件之间的父子关系就被构建出来了。</p><h3 id="3-2解决问题"><a href="#3-2解决问题" class="headerlink" title="3.2解决问题"></a>3.2解决问题</h3><p>在上面的目录中我们要做如下事情：</p><ol><li>通过 test1 目录中的测试文件进行计算器相关的测试</li><li>通过 test2 目录中的测试文件进行排序相关的测试</li></ol><p>现在相当于是要进行模块化测试，对于calc和sort目录中的源文件来说，可以将它们先编译成库文件（可以是静态库也可以是动态库）然后在提供给测试文件使用即可。库文件的本质其实还是代码，只不过是从文本格式变成了二进制格式。</p><h4 id="3-2-1根目录"><a href="#3-2-1根目录" class="headerlink" title="3.2.1根目录"></a>3.2.1根目录</h4><p>根目录中的CMakeLists.txt文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">test</span>)<br><span class="hljs-comment"># 定义变量</span><br><span class="hljs-comment"># 静态库生成的路径</span><br><span class="hljs-keyword">set</span>(LIB_PATH <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-comment"># 测试程序生成的路径</span><br><span class="hljs-keyword">set</span>(EXEC_PATH <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/bin)<br><span class="hljs-comment"># 头文件目录</span><br><span class="hljs-keyword">set</span>(HEAD_PATH <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-comment"># 静态库的名字</span><br><span class="hljs-keyword">set</span>(CALC_LIB calc)<br><span class="hljs-keyword">set</span>(SORT_LIB sort)<br><span class="hljs-comment"># 可执行程序的名字</span><br><span class="hljs-keyword">set</span>(APP_NAME_1 test1)<br><span class="hljs-keyword">set</span>(APP_NAME_2 test2)<br><span class="hljs-comment"># 添加子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(calc)<br><span class="hljs-keyword">add_subdirectory</span>(sort)<br><span class="hljs-keyword">add_subdirectory</span>(test1)<br><span class="hljs-keyword">add_subdirectory</span>(test2)<br></code></pre></td></tr></table></figure><p>在根节点对应的文件中主要做了两件事情：<strong>定义全局变量和添加子目录</strong>。</p><ul><li>定义的全局变量主要是给子节点使用，目的是为了提高子节点中的CMakeLists.txt文件的可读性和可维护性，避免冗余并降低出差的概率。</li><li>一共添加了四个子目录，每个子目录中都有一个CMakeLists.txt文件，这样它们的父子关系就被确定下来了。</li></ul><h4 id="3-2-2calc目录"><a href="#3-2-2calc目录" class="headerlink" title="3.2.2calc目录"></a>3.2.2calc目录</h4><p>calc 目录中的 CMakeLists.txt文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake">cmake_minimumu_required(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(CALCLIB)<br>aux_sorce_directory(./ SRC)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;HEAD_PATH&#125;</span>)<br><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH &#123;LIB_PATH&#125;)<br><span class="hljs-keyword">add_library</span>(<span class="hljs-variable">$&#123;CALC_LIB&#125;</span> STATIC <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><ul><li>第3行aux_source_directory：<strong>搜索当前目录（calc目录）下的所有源文件</strong></li><li>第4行include_directories：<strong>包含头文件路径，HEAD_PATH是在根节点文件中定义的</strong></li><li>第5行set：<strong>设置库的生成的路径，LIB_PATH是在根节点文件中定义的</strong></li><li>第6行add_library：<strong>生成静态库，静态库名字CALC_LIB是在根节点文件中定义的</strong></li></ul><h4 id="3-2-3sort目录"><a href="#3-2-3sort目录" class="headerlink" title="3.2.3sort目录"></a>3.2.3sort目录</h4><p>sort 目录中的 CMakeLists.txt文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(SORT)<br><span class="hljs-keyword">aux_source_directory</span>(./ SRC)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;HEAD_PATH&#125;</span>)<br><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH &#123;LIB_PATH&#125;)<br><span class="hljs-keyword">add_library</span>(<span class="hljs-variable">$&#123;SORT_LIB&#125;</span> SHARED <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><p>第6行add_library：<strong>生成动态库，动态库名字SORT_LIB是在根节点文件中定义的</strong></p><p>这个文件中的内容和calc节点文件中的内容类似，只不过这次生成的是<strong>动态库</strong>。</p><p>在生成库文件的时候，这个库可以是静态库也可以是动态库，一般需要根据实际情况来确定。如果生成的库比较大，建议将其制作成动态库。</p><h4 id="3-2-4test1目录"><a href="#3-2-4test1目录" class="headerlink" title="3.2.4test1目录"></a>3.2.4test1目录</h4><p>test1目录中的CMakeLists.txt文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALCTEST)<br><span class="hljs-keyword">aux_source_directory</span>(./ SRC)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;HEAD_PATH&#125;</span>)<br><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;LIBPATH&#125;</span>)<br><span class="hljs-keyword">link_libraries</span>(<span class="hljs-variable">$&#123;CALC_LIB&#125;</span>)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;EXEC_PATH&#125;</span>)<br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;APP_NAME_1&#125;</span> <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><ul><li><p>第4行include_directories：<strong>指定头文件路径</strong>，HEAD_PATH变量是在根节点文件中定义的</p></li><li><p>第6行link_libraries：<strong>指定可执行程序要链接的静态库</strong>，CALC_LIB变量是在根节点文件中定义的</p></li><li><p>第7行set：<strong>指定可执行程序生成的路径</strong>，EXEC_PATH变量是在根节点文件中定义的</p></li><li><p>第8行add_executable：<strong>生成可执行程序</strong>，APP_NAME_1变量是在根节点文件中定义的</p></li></ul><p>此处的可执行程序链接的是静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被<strong>加载到内存中了</strong>。</p><h4 id="3-2-5test2目录"><a href="#3-2-5test2目录" class="headerlink" title="3.2.5test2目录"></a>3.2.5test2目录</h4><p>test2 目录中的 CMakeLists.txt文件内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(SORTTEST)<br><span class="hljs-keyword">aux_source_directory</span>(./ SRC)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;HEAD_PATH&#125;</span>)<br><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;LIBPATH&#125;</span>)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;EXEC_PATH&#125;</span>)<br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;APP_NAME_2&#125;</span> <span class="hljs-variable">$&#123;SRC&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;APP_NAME_2&#125;</span> <span class="hljs-variable">$&#123;SORT_LIB&#125;</span>)<br></code></pre></td></tr></table></figure><ul><li><p>第四行include_directories：<strong>包含头文件路径</strong>，HEAD_PATH变量是在根节点文件中定义的</p></li><li><p>第五行set：<strong>指定可执行程序生成的路径</strong>，EXEC_PATH变量是在根节点文件中定义的</p></li><li><p>第六行link_directories：<strong>指定可执行程序要链接的动态库的路径</strong>，LIB_PATH变量是在根节点文件中定义的</p></li><li><p>第七行add_executable：<strong>生成可执行程序</strong>，APP_NAME_2变量是在根节点文件中定义的</p></li><li><p>第八行target_link_libraries：<strong>指定可执行程序要链接的动态库的名字</strong></p></li></ul><p>在生成可执行程序的时候，<strong>动态库不会被打包到可执行程序内部</strong>。当可执行程序启动之后动态库也不会被加载到内存，<strong>只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中</strong>，且多个进程可以共用内存中的同一个动态库，所以动态库又叫<strong>共享</strong>。</p><h4 id="3-2-6构建项目"><a href="#3-2-6构建项目" class="headerlink" title="3.2.6构建项目"></a>3.2.6构建项目</h4><p>执行如下命令</p><p>在build目录下执行，cmake命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake ..<br></code></pre></td></tr></table></figure><p>可以看到在build目录中生成了一些文件和目录，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree build -L 1</span>     <br>build<br>├── calc                  # 目录<br>├── CMakeCache.txt        # 文件<br>├── CMakeFiles            # 目录<br>├── cmake_install.cmake   # 文件<br>├── Makefile              # 文件<br>├── sort                  # 目录<br>├── test1                 # 目录<br>└── test2                 # 目录<br></code></pre></td></tr></table></figure><p>然后在build 目录下执行make 命令:</p><ul><li><p>在项目根目录的lib目录中生成了静态库libcalc.a</p></li><li><p>在项目根目录的lib目录中生成了动态库libsort.so</p></li><li><p>在项目根目录的bin目录中生成了可执行程序test1</p></li><li><p>在项目根目录的bin目录中生成了可执行程序test2</p></li></ul><p>最后再来看一下上面提到的这些文件是否真的被生成到对应的目录中了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree bin/ lib/</span><br>bin/<br>├── test1<br>└── test2<br>lib/<br>├── libcalc.a<br>└── libsort.so<br></code></pre></td></tr></table></figure><p>由此可见，真实不虚，至此，项目构建完毕。</p><p><strong>写在最后：</strong></p><p><strong>在项目中，如果将程序中的某个模块制作成了动态库或者静态库并且在CMakeLists.txt 中指定了库的输出目录，而后其它模块又需要加载这个生成的库文件，此时直接使用就可以了，如果没有指定库的输出路径或者需要直接加载外部提供的库文件，此时就需要使用 link_directories 将库文件路径指定出来</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>makefile</title>
    <link href="/2023/09/01/Makefile/"/>
    <url>/2023/09/01/Makefile/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>使用 GCC 的命令行进行程序编译在单个文件下是比较方便的，当工程中的文件逐渐增多，甚至变得<strong>十分庞大</strong>的时候，使用 GCC 命令编译就会变得力不从心。这种情况下我们需要借助项目构造工具 <strong>make</strong> 帮助我们完成这个艰巨的任务。 make是一个命令工具，是一个解释<strong>makefile</strong>中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Visual C++的n<strong>make</strong>，QtCreator的q<strong>make</strong>等。</p><p>make工具在构造项目的时候需要加载一个叫做<strong>makefile</strong>的文件，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为<strong>makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</strong></p><p>makefile带来的好处就是——<strong>“自动化编译”</strong>，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><p>makefile文件有两种命名方式 makefile 和 Makefile，构建项目的时候在哪个目录下执行构建命令 make这个目录下的 makefile 文件就会别加载，因此在一个项目中可以有多个 makefile 文件，分别位于不同的项目目录中。</p><span id="more"></span><h2 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h2><p>Makefile的框架是由语法构成的。make命令执行时先在Makefile文件中查找各种规则，对各种规则进行解析后运行规则。规则的基本格式为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 每条语句的语法格式</span><br><span class="hljs-section">target1,target2...: depend1,depend2,...</span><br>command<br>.......<br>.......<br></code></pre></td></tr></table></figure><p>每条规则由三个部分组成分别是：<strong>目标（target）</strong>，**依赖(depend)<strong>和</strong>命令(command)**。</p><p>**命令(command)**：当前这条语句干了什么，一般情况下就是一条shell语句</p><p>​例如：通过某个命令编译文件、生成库文件、进入目录等</p><p>​每个命令前必须有一个Tab缩进并且独占一行</p><p>**依赖(depend)**：语句所必需的依赖文件，在命令中可以使用这些依赖</p><p>​例如：生成可执行文件的目标文件**(*.o)**可以作为依赖使用</p><p>​如果命令不需要任何依赖，那么规则的依赖可以为空</p><p>​如果当前规则中的依赖可以是其他规则中的某个目标，这样就行成了规则的嵌套</p><p>​依赖可以根据要执行的命令的实际需求，指定很多个</p><p><strong>目标（target）</strong>：须与命令中的目标对应</p><p>​通过执行规则中的命令，可以生成一个和目标同名的文件</p><p>​规则中可以有多个命令，一次可以通过这条命令来生成多个目标，所有目标也可以有很多个</p><p>​通过执行规则中的命令，可以只执行一个动作，不生成任何文件，这样的目标被称为<strong>伪目标</strong></p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 举例: 有源文件 a.c b.c c.c head.h, 需要生成可执行程序 app</span><br><span class="hljs-comment">################# 例1 #################</span><br><span class="hljs-section">app:a.c b.c c.c</span><br>gcc a.c b.c c.c -o app<br><br><span class="hljs-comment">################# 例2 #################</span><br><span class="hljs-comment"># 有多个目标, 多个依赖, 多个命令</span><br><span class="hljs-section">app,app1:a.c b.c c.c d.c</span><br>gcc a.c b.c -o app<br>gcc c.c d.c -o app1<br><br><span class="hljs-comment">################# 例3 #################</span><br><span class="hljs-comment"># 规则之间的嵌套</span><br><span class="hljs-section">app:a.o b.o c.o</span><br>gcc a.o b.o c.o -o app<br><span class="hljs-comment"># a.o 是第一条规则中的依赖</span><br><span class="hljs-section">a.o:a.c</span><br>gcc -c a.c<br><span class="hljs-comment"># b.o 是第一条规则中的依赖</span><br><span class="hljs-section">b.o:b.c</span><br>gcc -c b.c<br><span class="hljs-comment"># c.o 是第一条规则中的依赖</span><br><span class="hljs-section">c.o:c.c</span><br>gcc -c c.c<br></code></pre></td></tr></table></figure><h2 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h2><h3 id="2-1规则的执行"><a href="#2-1规则的执行" class="headerlink" title="2.1规则的执行"></a>2.1规则的执行</h3><p><strong>在调用 make 命令编译程序的时候，make 会首先找到 Makefile 文件中的第 1 个规则，分析并执行相关的动作。</strong>但是需要注意的是，好多时候要执行的动作（命令）中使用的依赖是不存在的，如果使用的依赖不存在，这个动作也就不会被执行。</p><p>对应的解决方案是先将需要的依赖生成出来，我们就可以在makefile中添加新的规则，将不存在的依赖作为这个新的规则中的目标，当这条新的规则对应的命令执行完毕，对应的目标就被生成了，同时另一条规则中需要的依赖也就存在了。</p><p>这样，makefile中的某一条规则在需要的时候，就会被其他的规则调用，直到makefile中的第一条规则中的所有的依赖全部被生成，第一条规则中的命令就可以基于这些依赖生成对应的目标，make 的任务也就完成了。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># makefile</span><br><span class="hljs-comment"># 规则之间的嵌套</span><br><span class="hljs-comment"># 规则1</span><br><span class="hljs-section">app:a.o b.o c.o</span><br>gcc a.o b.o c.o -o app<br><span class="hljs-comment"># 规则2</span><br><span class="hljs-section">a.o:a.c</span><br>gcc -c a.c<br><span class="hljs-comment"># 规则3</span><br><span class="hljs-section">b.o:b.c</span><br>gcc -c b.c<br><span class="hljs-comment"># 规则4</span><br><span class="hljs-section">c.o:c.c</span><br>gcc -c c.c<br></code></pre></td></tr></table></figure><p>在解析第一条规则的时候发现里边的三个依赖都是不存在的，因此规则对应的命令也就不能被执行。</p><p>当依赖不存在的时候，make就去查找其他的规则，看哪一条规则使用来生成需要的这个依赖的，找到之后就会执行这条规则中的命令。</p><p>因此规则2，规则3，规则4里的命令会相继被执行，当规则1中的依赖全部被生成之后，规则1的命令也会被执行，生成对应的目标。</p><p>PS：</p><p>如果想要执行 makefile 中<strong>非第一条规则</strong>对应的命令, 那么就不能直接 <strong>make</strong>, 需要将那条<strong>规则的目标也写到 make的后边</strong>,</p><p>比如只需要执行规则3中的命令, 就需要: <strong>make b.o</strong></p><h3 id="2-2-文件的时间戳"><a href="#2-2-文件的时间戳" class="headerlink" title="2.2 文件的时间戳"></a>2.2 文件的时间戳</h3><p>make 命令执行的时候会根据文件的时间戳判定是否执行makefile文件中相关规则中的命令。</p><ul><li>目标是通过依赖生成的，因此正常情况下：目标时间戳 &gt; 所有依赖的时间戳, 如果执行 make 命令的时候检测到规则中的目标和依赖满足这个条件, 那么规则中的命令就不会被执行。</li><li>当依赖文件被更新了, 文件时间戳也会随之被更新, 这时候 目标时间戳 &lt; 某些依赖的时间戳, 在这种情况下目标文件会通过规则中的命令被重新生成。</li><li>如果规则中的目标对应的文件根本就不存在， 那么规则中的命令肯定会被执行。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># makefile</span><br><span class="hljs-comment"># 规则之间的嵌套</span><br><span class="hljs-comment"># 规则1</span><br><span class="hljs-section">app:a.o b.o c.o</span><br>gcc a.o b.o c.o -o app<br><span class="hljs-comment"># 规则2</span><br><span class="hljs-section">a.o:a.c</span><br>gcc -c a.c<br><span class="hljs-comment"># 规则3</span><br><span class="hljs-section">b.o:b.c</span><br>gcc -c b.c<br><span class="hljs-comment"># 规则4</span><br><span class="hljs-section">c.o:c.c</span><br>gcc -c c.c<br></code></pre></td></tr></table></figure><p>根据上文的描述, 先执行 make 命令，基于这个 makefile 编译这几个源文件生成对应的目标文件。然后再<strong>修改例子中的 a.c</strong>, 再次通过<strong>make编译</strong>这几个源文件，那么这个时候<strong>先执行规则2更新目标文件a.o</strong>， 然后再执行规则1更新目标文件app，<strong>其余的规则是不会被执行的</strong>。</p><p><strong>简言之：谁修改则先执行谁，不修改则不执行。</strong></p><h3 id="2-3自动推导"><a href="#2-3自动推导" class="headerlink" title="2.3自动推导"></a>2.3自动推导</h3><p>make 有自动推导的能力，不会完全依赖 makefile。</p><p>比如: 使用命令 make 编译扩展名为.c 的 C 语言文件的时候，源文件的编译规则不用明确给出。这是因为 make 进行编译的时候会使用一个默认的编译规则，按照默认规则完成对.c文件的编译，生成对应的.o 文件。它使用命令cc -c来编译.c 源文件。在 Makefile 中只要给出需要构建的目标文件名（一个.o 文件），make 会自动为这个.o 文件寻找合适的依赖文件（对应的.c 文件），并且使用默认的命令来构建这个目标文件。</p><p>假设本地项目目录中有以下几个源文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── add.c<br>├── div.c<br>├── head.h<br>├── main.c<br>├── makefile<br>├── mult.c<br>└── sub.c<br></code></pre></td></tr></table></figure><p>目录中makefile文件内容如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 这是一个完整的 makefile 文件</span><br><span class="hljs-section">calc:add.o  div.o  main.o  mult.o  sub.o</span><br>        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc<br></code></pre></td></tr></table></figure><p>通过make构建项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>cc    -c -o add.o add.c<br>cc    -c -o div.o div.c<br>cc    -c -o main.o main.c<br>cc    -c -o mult.o mult.c<br>cc    -c -o sub.o sub.c<br>gcc  add.o  div.o  main.o  mult.o  sub.o -o calc<br></code></pre></td></tr></table></figure><p>我们可以发现上边的 makefile 文件中只有一条规则, 依赖中<strong>所有的 .o文件在本地项目目录中是不存在的</strong>, <strong>并且也没有其他的规则用来生成这些依赖文件</strong>, 这时候 make 会使用<strong>内部默认的构造规则先将这些依赖文件生成出来</strong>, 然后在执行规则中的命令, <strong>最后生成目标文件 calc。</strong></p><h2 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h2><p><strong>makefile</strong>中的变量分为三种：<strong>自定义变量，预定义变量和自动变量</strong>。</p><h3 id="3-1自定义变量"><a href="#3-1自定义变量" class="headerlink" title="3.1自定义变量"></a>3.1自定义变量</h3><p>用 Makefile 进行规则定义的时候，用户<strong>可以定义自己的变量</strong>，称为<strong>用户自定义变量</strong>。makefile 中的变量是<strong>没有类型</strong>的，直接<strong>创建变量然后给其赋值</strong>就可以了。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 错误, 只创建了变量名, 没有赋值</span><br>变量名 <br><span class="hljs-comment"># 正确, 创建一个变量名并且给其赋值</span><br>变量名=变量值<br></code></pre></td></tr></table></figure><p><strong>取出变量值</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 如果将变量的值取出?</span><br>$(变量的名字)<br><br><span class="hljs-comment"># 举例 add.o  div.o  main.o  mult.o  sub.o</span><br><span class="hljs-comment"># 定义变量并赋值</span><br>obj=add.o  div.o  main.o  mult.o  sub.o<br><span class="hljs-comment"># 取变量的值</span><br><span class="hljs-variable">$(obj)</span><br></code></pre></td></tr></table></figure><p><strong>自定义变量使用举例：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#普通写法</span><br><span class="hljs-section">calc:add.o div.o mult.o sub.o</span><br>gcc add.o div.o mult.o sub.o -o calc<br><br><span class="hljs-comment">#自定义变量写法</span><br>target=calc<br>obj=add.o div.o mult.o sub.o<br><span class="hljs-variable">$(target)</span>: <span class="hljs-variable">$(obj)</span><br>gcc <span class="hljs-variable">$(obj)</span> -o <span class="hljs-variable">$(target)</span><br></code></pre></td></tr></table></figure><h3 id="3-2预定义变量"><a href="#3-2预定义变量" class="headerlink" title="3.2预定义变量"></a>3.2预定义变量</h3><p>用户可以<strong>直接使用</strong>的变量，<strong>不用进行定义</strong>。在进行编译的时候，某些条件下 Makefile 会使用这些预定义变量的值进行编译。这些预定义变量的名字一般都是大写的，经常采用的预定义变量如下表所示：</p><table><thead><tr><th align="center">变量名</th><th align="center">含义</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">AR</td><td align="center">生成静态库库文件的程序名称</td><td align="center">ar</td></tr><tr><td align="center">AS</td><td align="center">汇编编译器的名称</td><td align="center">as</td></tr><tr><td align="center">CC</td><td align="center">C语言编译器的名称</td><td align="center">cc</td></tr><tr><td align="center">CPP</td><td align="center">C语言预编译器的名称</td><td align="center">$（CC） -E</td></tr><tr><td align="center">CXX</td><td align="center">C++语言编译器的名称</td><td align="center">g++</td></tr><tr><td align="center">FC</td><td align="center">FORTRAN 语言编译器的名称</td><td align="center">f77</td></tr><tr><td align="center">RM</td><td align="center">删除文件程序的名称</td><td align="center">rm -f</td></tr><tr><td align="center">ARFLAGS</td><td align="center">生成静态库库文件程序的选项</td><td align="center">无默认值</td></tr><tr><td align="center">ASFLAGS</td><td align="center">汇编语言编译器的编译选项</td><td align="center">无默认值</td></tr><tr><td align="center">CFLAGS</td><td align="center">C 语言编译器的编译选项</td><td align="center">无默认值</td></tr><tr><td align="center">CPPFLAGS</td><td align="center">C 语言预编译的编译选项</td><td align="center">无默认值</td></tr><tr><td align="center">CXXFLAGS</td><td align="center">C++语言编译器的编译选项</td><td align="center">无默认值</td></tr><tr><td align="center">FFLAGS</td><td align="center">FORTRAN 语言编译器的编译选项</td><td align="center">无默认值</td></tr></tbody></table><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 这是一个规则，普通写法</span><br><span class="hljs-section">calc:add.o  div.o  main.o  mult.o  sub.o</span><br>        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc<br>        <br><span class="hljs-comment"># 这是一个规则，里边使用了自定义变量和预定义变量</span><br>obj=add.o  div.o  main.o  mult.o  sub.o<br>target=calc<br>CFLAGS=-O3 <span class="hljs-comment"># 代码优化</span><br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br>        <span class="hljs-variable">$(CC)</span>  <span class="hljs-variable">$(obj)</span> -o <span class="hljs-variable">$(target)</span> <span class="hljs-variable">$(CFLAGS)</span><br></code></pre></td></tr></table></figure><h3 id="3-3自动变量"><a href="#3-3自动变量" class="headerlink" title="3.3自动变量"></a>3.3自动变量</h3><p>Makefile 中的变量除了用户自定义变量和预定义变量外，还有一类<strong>自动变量</strong>。Makefile 中的规则语句中经常会出现目标文件和依赖文件，<strong>自动变量用来代表这些规则中的目标文件和依赖文件，并且它们只能在规则的命令中使用</strong>。</p><p>下表中是一些常见的自动变量。</p><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$*</td><td>表示目标文件的名称，不包含目标文件的扩展名<strong>（常用）</strong></td></tr><tr><td>$+</td><td>表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后顺序，其中可能包含重复的依赖文件</td></tr><tr><td>$&lt;</td><td>表示依赖项中第一个依赖文件的名称<strong>（常用）</strong></td></tr><tr><td>$?</td><td>依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开</td></tr><tr><td>$@</td><td>表示目标文件的名称，包含文件扩展名<strong>（常用）</strong></td></tr><tr><td>$^</td><td>依赖项中，所有不重复的依赖文件，这些文件之间以空格分开<strong>（常用）</strong></td></tr></tbody></table><p>举例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 这是一个规则，普通写法</span><br><span class="hljs-section">calc:add.o  div.o  main.o  mult.o  sub.o</span><br>        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc<br>        <br><span class="hljs-comment"># 这是一个规则，里边使用了自定义变量</span><br><span class="hljs-comment"># 使用自动变量, 替换相关的内容</span><br><span class="hljs-section">calc:add.o  div.o  main.o  mult.o  sub.o</span><br>gcc <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span> <span class="hljs-comment"># 自动变量只能在规则的命令中使用</span><br></code></pre></td></tr></table></figure><h2 id="4、模式匹配"><a href="#4、模式匹配" class="headerlink" title="4、模式匹配"></a>4、模式匹配</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">calc:add.o  div.o  main.o  mult.o  sub.o</span><br>        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc<br><span class="hljs-comment"># 语法格式重复的规则, 将 .c -&gt; .o, 使用的命令都是一样的 gcc *.c -c</span><br><span class="hljs-section">add.o:add.c</span><br>        gcc add.c -c<br><br><span class="hljs-section">div.o:div.c</span><br>        gcc div.c -c<br><br><span class="hljs-section">main.o:main.c</span><br>        gcc main.c -c<br><br><span class="hljs-section">sub.o:sub.c</span><br>        gcc sub.c -c<br><br><span class="hljs-section">mult.o:mult.c</span><br>        gcc mult.c -c<br></code></pre></td></tr></table></figure><p>从上边一段makefile文件中我们可以发现后边的几个规则做的是相同的事情，只是文件名做了变化而已。</p><p>这就使得makefile变得十分冗余，我们可以将<strong>这一系列操作整理成一个模板，所有类似的操作都通过模板去匹配</strong>。</p><p>上述的过程我们称为<strong>模式匹配</strong></p><p>整理的过程如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 模式匹配 -&gt; 通过一个公式, 代表若干个满足条件的规则</span><br><span class="hljs-comment"># 依赖有一个, 后缀为.c, 生成的目标是一个 .o 的文件, % 是一个通配符, 匹配的是文件名</span><br><span class="hljs-section">%.o:%.c</span><br>gcc <span class="hljs-variable">$&lt;</span> -c<br></code></pre></td></tr></table></figure><h2 id="5、函数"><a href="#5、函数" class="headerlink" title="5、函数"></a>5、函数</h2><p>makefile中有很多函数并且所有的函数都是有返回值的。makefile中函数的格式和C&#x2F;C++中函数也不同，其写法是这样的： **$(函数名 参数1, 参数2, 参数3, …)**，主要目的是让我们能够快速方便的得到函数的返回值</p><p>两个 makefile 中使用频率比较高的函数：<strong>wildcard</strong>和<strong>patsubst</strong>。</p><h3 id="5-1wildcard"><a href="#5-1wildcard" class="headerlink" title="5.1wildcard"></a>5.1wildcard</h3><p>这个函数的主要作用是<strong>获取指定目录下指定类型的文件名</strong>，其返回值是<strong>以空格分割的、指定目录下的所有符合条件的文件名列表</strong>。函数原型如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 该函数的参数只有一个, 但是这个参数可以分成若干个部分, 通过空格间隔</span><br><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> PATTERN...)</span><br>参数:指定某个目录, 搜索这个路径下指定类型的文件，比如： *.c<br></code></pre></td></tr></table></figure><ul><li>参数功能：</li></ul><p>​PATTERN指的是某个或多个目录下的对应的某种类型的文件，比如当前目录下的**.c<strong>文件可以写成</strong><em>.c</em>*</p><p>​可以指定多个目录，每个路径之间使用空格间隔</p><ul><li>返回值：</li></ul><p>​得到的若干个文件的文件列表，文件名之间使用空格间隔</p><p>​E.G.：$(wildcard *.c .&#x2F;sub&#x2F;*.c)</p><p>​返回格式：a.c b.c c.c d.c e.c f.c .&#x2F;sub&#x2F;aa.c .&#x2F;sub&#x2F;bb&#x2F;c</p><ul><li>举例：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件</span><br>src = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> /home/robin/a/*.c /home/robin/b/*.c *.c)</span>  <span class="hljs-comment"># *.c == ./*.c</span><br><span class="hljs-comment"># 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔</span><br>/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c<br></code></pre></td></tr></table></figure><h3 id="5-2patsubst"><a href="#5-2patsubst" class="headerlink" title="5.2patsubst"></a>5.2patsubst</h3><p>这个函数的功能是按照指定的模式替换指定的文件名的后缀，函数原型如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 有三个参数, 参数之间使用 逗号间隔</span><br><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p><strong>参数功能：</strong></p><p>​pattern：这是一个模式字符串，需要指定出要被替换的文件名中的后缀是什么</p><p>​文件名和路径不需要关心，因此使用%表示即可</p><p>​在通配符后边制定出要被替换的后缀，比如：%.c，意味着.c的后缀要被替换掉</p><p>​replacement：这是一个模式字符串，指定参数pattern中的后缀最终要被替换为什么</p><p>​还是使用 % 来表示参数pattern 中文件的路径和名字</p><p>​在通配符 % 后边指定出新的后缀名, 比如: %.o 这表示原来的后缀被替换为 .o</p><p>​text：该村书中存储这要被替换的原始数据</p><p><strong>返回值：</strong></p><p>​函数返回被替换过后的字符串</p><p><strong>函数使用举例：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src = a.cpp b.cpp c.cpp e.cpp<br><span class="hljs-comment"># 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o</span><br>obj = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.cpp, %.o, <span class="hljs-variable">$(src)</span>)</span> <br><span class="hljs-comment"># obj 的值为: a.o b.o c.o e.o</span><br></code></pre></td></tr></table></figure><h2 id="6、makefile的编写（逐步精简）"><a href="#6、makefile的编写（逐步精简）" class="headerlink" title="6、makefile的编写（逐步精简）"></a>6、makefile的编写（逐步精简）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">项目目录结构</span><br>.<br>├── add.c<br>├── div.c<br>├── head.h<br>├── main.c<br>├── mult.c<br>└── sub.c<br><span class="hljs-meta prompt_"># </span><span class="language-bash">需要编写makefile对该项目进行自动化编译</span><br></code></pre></td></tr></table></figure><h3 id="6-1版本1"><a href="#6-1版本1" class="headerlink" title="6.1版本1"></a>6.1版本1</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">calc:add.c div.c sub.c mult.c main.c</span><br>gcc add.c div.c sub.c mult.c main.c -o calc<br></code></pre></td></tr></table></figure><p>这个版本的优点：<strong>书写简单</strong></p><p>这版本的缺点：<strong>只要依赖中的某一个源文件被修改，所有的源文件都需要被重新编译，太耗时、效率低</strong></p><p>改进方式：<strong>提高效率，修改哪一个源文件, 哪个源文件被重新编译, 不修改就不重新编译</strong></p><h3 id="6-2版本2"><a href="#6-2版本2" class="headerlink" title="6.2版本2"></a>6.2版本2</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 默认所有依赖都不存在，需要使用其他规则生成这些依赖</span><br><span class="hljs-comment"># 当其中的某一个依赖被更新了，则需要使用最新的依赖，生成最新的目标</span><br><span class="hljs-section">calc:add.o div.o sub.o mult.o main.c</span><br>gcc add.o div.o sub.o mult.o main.o -o calc<br><span class="hljs-section">add.o:add.c</span><br>gcc add.c -c <br><span class="hljs-section">div.o:div.c</span><br>gcc div.c -c <br><span class="hljs-section">sub.o:sub.c</span><br>gcc sub.c -c <br><span class="hljs-section">mult.o:mult.c</span><br>gcc mult.c -c <br><span class="hljs-section">main.o:main.c</span><br>gcc main.c -c<br></code></pre></td></tr></table></figure><p>这个版本的优点：<strong>相较于版本1效率提升了</strong></p><p>这个版本的缺点：<strong>规则比较冗余, 需要精简</strong></p><p>改进方式：在 makefile 中<strong>使用变量</strong>和<strong>模式匹配</strong></p><h3 id="6-3版本3"><a href="#6-3版本3" class="headerlink" title="6.3版本3"></a>6.3版本3</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target=calc<br>obj=add.o div.o sub.o mult.o main.o<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br>gcc <span class="hljs-variable">$(obj)</span> -o <span class="hljs-variable">$(target)</span><br><span class="hljs-section">%.o:%.c</span><br>gcc <span class="hljs-variable">$^</span> -c<br></code></pre></td></tr></table></figure><p>这个版本的优点：文件精简不少，变得简洁了</p><p>这个版本的缺点：<strong>变量 obj 的值需要手动的写出来, 如果需要编译的项目文件很多，都用手写出来不现实</strong></p><p>改进方式：在makefile中使用函数</p><h3 id="6-4版本4"><a href="#6-4版本4" class="headerlink" title="6.4版本4"></a>6.4版本4</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target=calc<br><span class="hljs-comment"># 添加自定义变量 -&gt; makefile中注释前 使用 # </span><br><span class="hljs-comment"># 使用函数搜索当前目录下的源文件 .c</span><br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br><span class="hljs-comment"># 将源文件的后缀替换为 .o</span><br>obj=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c,%.o,<span class="hljs-variable">$(src)</span>)</span><br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br>gcc <span class="hljs-variable">$(obj)</span> -o <span class="hljs-variable">$(target)</span><br><span class="hljs-section">%.o:%.c</span><br>gcc <span class="hljs-variable">$^</span> -c<br></code></pre></td></tr></table></figure><p>这个版本的优点：解决了自动加载项目文件的问题，解放了双手</p><p>这个版本的缺点：<em><em>没有文件删除的功能，不能删除项目编译过程中生成的目标文件（</em>.o）和可执行程序</em>*</p><p>改进方式: 在makefile文件中添加新的规则用于删除生成的目标文件（*.o）和可执行程序</p><h3 id="6-5版本5"><a href="#6-5版本5" class="headerlink" title="6.5版本5"></a>6.5版本5</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 添加自定义变量 -&gt; makefile中注释前 使用 # </span><br>target=calc<br><span class="hljs-comment"># 使用函数搜索当前目录下的源文件 .c</span><br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br><span class="hljs-comment"># 将源文件的后缀替换为 .o</span><br>obj=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span><br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br>gcc <span class="hljs-variable">$(obj)</span> -o <span class="hljs-variable">$(target)</span><br><span class="hljs-section">%o:%c</span><br>gcc <span class="hljs-variable">$^</span> -c<br><span class="hljs-comment"># 添加规则, 删除生成文件 *.o 可执行程序</span><br><span class="hljs-comment"># 这个规则比较特殊, clean根本不会生成, 这是一个伪目标</span><br><span class="hljs-section">clean:</span><br>        rm <span class="hljs-variable">$(obj)</span> <span class="hljs-variable">$(target)</span><br></code></pre></td></tr></table></figure><p>这个版本的优点: 添加了新的规则（16行）用于文件的删除, 直接 make clean 就可以执行规则中的删除命令了</p><p><strong>这个版本的缺点</strong>: 在下面有具体的问题演示和分析</p><p>改进方式: 在makefile文件中声明 clean是一个伪目标，让 make 放弃对它的时间戳检测。</p><p>正常情况下这个版本的makefile是可以正常工作的，<strong>但是我们如果在这个项目目录中添加一个叫做clean的文件（和规则中的目标名称相同）</strong>，<strong>再进行 make clean发现这个规则就不能正常工作了。</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 在项目目录中添加一个叫 clean的文件, 然后在 make clean 这个规则中的命令就不工作了</span><br>$ ls<br>add.c  calc   div.c  head.h  main.o    mult.c  sub.c<br>add.o  div.o  main.c  makefile  mult.o  sub.o  clean  ---&gt; 新添加的<br><br><span class="hljs-comment"># 使用 makefile 中的规则删除生成的目标文件和可执行程序</span><br>$ make clean<br><span class="hljs-section">make: &#x27;clean&#x27; is up to date. </span><br><br><span class="hljs-comment"># 查看目录, 发现相关文件并没有被删除, make clean 失败了</span><br>$ ls<br>add.c  calc   div.c  head.h  main.o    mult.c  sub.c<br>add.o  clean  div.o  main.c  makefile  mult.o  sub.o<br></code></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>这个问题的关键点在于 clean是一个伪目标, 不对应任何实体文件, 在前边讲关于文件时间戳更新问题的时候说过，如果目标不存在规则的命令肯定被执行， 如果目标文件存在了就需要比较规则中目标文件和依赖文件的时间戳，满足条件才执行规则的命令，否则不执行。</p><p>解决这个问题需要在 makefile 中声明 clean是一个伪目标，这样 make 就不会对文件的时间戳进行检测，规则中的命令也就每次都会被执行了。</p><p>在 makefile 中声明一个伪目标需要使用 <strong>.PHONY 关键字</strong>, 声明方式为: <strong>.PHONY:伪文件名称</strong></p><h3 id="6-6最终版"><a href="#6-6最终版" class="headerlink" title="6.6最终版"></a>6.6最终版</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 添加自定义变量 -&gt; makefile中注释前 使用 # </span><br><span class="hljs-comment"># 使用函数搜索当前目录下的源文件 .c</span><br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br><span class="hljs-comment"># 将源文件的后缀替换为 .o</span><br>obj=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span><br>target=calc<br><br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br>        gcc <span class="hljs-variable">$(obj)</span>  -o <span class="hljs-variable">$(target)</span><br><br><span class="hljs-section">%.o:%.c</span><br>        gcc <span class="hljs-variable">$&lt;</span> -c<br><br><span class="hljs-comment"># 添加规则, 删除生成文件 *.o 可执行程序</span><br><span class="hljs-comment"># 声明clean为伪文件</span><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean</span><br><span class="hljs-section">clean:</span><br>        <span class="hljs-comment"># shell命令前的 - 表示强制这个指令执行, 如果执行失败也不会终止</span><br>        -rm <span class="hljs-variable">$(obj)</span> <span class="hljs-variable">$(target)</span> <br>        echo <span class="hljs-string">&quot;hello, 我是测试字符串&quot;</span><br></code></pre></td></tr></table></figure><h2 id="7、练习"><a href="#7、练习" class="headerlink" title="7、练习"></a>7、练习</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">目录结构</span><br>.<br>├── include<br>│   └── head.h==&gt; 头文件, 声明了加减乘除四个函数<br>├── main.c==&gt; 测试程序, 调用了head.h中的函数<br>└── src<br>    ├── add.c==&gt; 加法运算<br>    ├── div.c==&gt; 除法运算<br>    ├── mult.c  ==&gt; 乘法运算<br>    └── sub.c   ==&gt; 减法运算<br> <br></code></pre></td></tr></table></figure><p>编写的makefile文件如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 最终的目标名 app</span><br>target = app<br><span class="hljs-comment"># 搜索当前项目目录下的源文件</span><br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c ./src/*.c)</span><br><span class="hljs-comment"># 将文件的后缀替换掉 .c -&gt; .o</span><br>obj=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span><br><span class="hljs-comment"># 头文件目录</span><br>include=./<span class="hljs-keyword">include</span><br><br><span class="hljs-comment"># 第一条规则</span><br><span class="hljs-comment"># 依赖中都是 xx.o yy.o zz.o</span><br><span class="hljs-comment"># gcc命令执行的是链接操作</span><br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br>        gcc <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># 模式匹配规则</span><br><span class="hljs-comment"># 执行汇编操作, 前两步: 预处理, 编译是自动完成</span><br><span class="hljs-section">%.o:%.c</span><br>        gcc <span class="hljs-variable">$&lt;</span> -c -I <span class="hljs-variable">$(include)</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># 添加一个清除文件的规则</span><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean</span><br><br><span class="hljs-section">clean:</span><br>        -rm <span class="hljs-variable">$(obj)</span> <span class="hljs-variable">$(target)</span> -f<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态库和静态库</title>
    <link href="/2023/07/28/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <url>/2023/07/28/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>不管是Linux还是Windows中的库文件其本质和工作模式都是相同的, 只不过在不同的平台上库对应的文件格式和文件后缀不同。程序中调用的库有两种 静态库和动态库，不管是哪种库文件本质是还是源文件，只不过是二进制格式只有计算机能够识别，作为一个普通人就无能为力了。</p><p>在项目中使用库一般有两个目的，一个是为了使程序更加简洁不需要在项目中维护太多的源文件，另一方面是为了源代码保密，毕竟不是所有人都想把自己编写的程序开源出来。</p><p>当我们拿到了库文件（动态库、静态库）之后要想使用还必须有这些库中提供的API函数的声明，也就是头文件，把这些都添加到项目中，就可以快乐的写代码了。</p><span id="more"></span><h1 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h1><h2 id="1、静态库"><a href="#1、静态库" class="headerlink" title="1、静态库"></a>1、静态库</h2><p>在Linux中静态库由程序 ar 生成，现在静态库已经不像之前那么普遍了，这主要是由于程序都在使用动态库。关于静态库的命名规则如下:</p><ul><li>在Linux中静态库以<strong>lib</strong>作为<strong>前缀</strong>, 以**.a<strong>作为</strong>后缀,** 中间是库的名字自己指定即可, 即: <strong>libxxx.a</strong></li><li>在Windows中静态库一般以<strong>lib</strong>作为<strong>前缀</strong>，以<strong>lib</strong>作为<strong>后缀</strong>，中间是库的名字需要自己指定, 即: <strong>libxxx.lib</strong></li></ul><h3 id="1-1生成静态库"><a href="#1-1生成静态库" class="headerlink" title="1.1生成静态库"></a>1.1生成静态库</h3><p>生成静态库，需要先对源文件进行<strong>汇编操作</strong> (使用参数 -c) 得到二进制格式的目标文件 <strong>(.o 格式)</strong>, 然后在通过 <strong>ar</strong>工具将目标文件打包就可以得到静态库文件了 **(libxxx.a)**。</p><p>使用ar工具创建静态库的时候需要三个参数:</p><ul><li><p>参数c：创建一个库，不管库是否存在，都将创建。</p></li><li><p>参数s：创建目标文件索引，这在创建较大的库时能加快时间。</p></li><li><p>参数r：在库中插入模块(替换)。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块。</p></li></ul><p><strong>生成静态链接库的具体步骤如下:</strong></p><p>1.需要将源文件进行汇编，得到.o文件，需要使用参数-c</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">执行如下操作生成.o文件</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-c参数位置没有要求</span><br>gcc *.c -c <br></code></pre></td></tr></table></figure><p>2.将得到的.o进行打包，得到静态库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ar rcs 静态库的名字(libxxx.a) 原材料(*.o)<br></code></pre></td></tr></table></figure><p>3.发布静态库</p><h3 id="1-2静态库制作举例"><a href="#1-2静态库制作举例" class="headerlink" title="1.2静态库制作举例"></a>1.2静态库制作举例</h3><h4 id="1-2-1准备测试程序"><a href="#1-2-1准备测试程序" class="headerlink" title="1.2.1准备测试程序"></a>1.2.1准备测试程序</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">目录结构 add.c div.c mult.c sub.c -&gt; 算法的源文件, 函数声明在头文件 head.h</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">main.c中是对接口的测试程序, 制作库的时候不需要将 main.c 算进去</span><br>.<br>├── add.c<br>├── div.c<br>├── include<br>│   └── head.h<br>├── main.c<br>├── mult.c<br>└── sub.c<br></code></pre></td></tr></table></figure><h4 id="1-2-2生成静态库"><a href="#1-2-2生成静态库" class="headerlink" title="1.2.2生成静态库"></a>1.2.2生成静态库</h4><p>第一步: 将源文件<strong>add.c, div.c, mult.c, sub.c</strong> 进行汇编, 得到二进制目标文件 <strong>add.o, div.o, mult.o, sub.o</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 生成.o</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc add.c div.c mult.c sub.c -c</span><br>sub.c:2:18: fatal error: head.h: No such file or directory<br>compilation terminated.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提示头文件找不到, 添加参数 -I 重新头文件路径即可</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc add.c div.c mult.c sub.c -c -I ./include/</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看目标文件是否已经生成</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── add.c<br>├── add.o            # 目标文件<br>├── div.c<br>├── div.o            # 目标文件<br>├── include<br>│   └── head.h<br>├── main.c<br>├── mult.c<br>├── mult.o           # 目标文件<br>├── sub.c<br>└── sub.o            # 目标文件<br></code></pre></td></tr></table></figure><p>第二步: 将生成的目标文件通过 ar工具打包生成静态库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 将生成的目标文件 .o 打包成静态库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ar rcs libcalc.a a.o b.o c.o    <span class="hljs-comment"># a.o b.o c.o在同一个目录中可以写成 *.o</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看目录中的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── add.c<br>├── add.o<br>├── div.c<br>├── div.o<br>├── include<br>│   └── `head.h  ===&gt; 和静态库一并发布<br>├── `libcalc.a   ===&gt; 生成的静态库<br>├── main.c<br>├── mult.c<br>├── mult.o<br>├── sub.c<br>└── sub.o<br></code></pre></td></tr></table></figure><p>第三步: 将生成的的静态库 <strong>libcalc.a</strong>和库对应的头文件<strong>head.h</strong>一并发布给使用者就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 发布静态库</span><br>1. head.h    =&gt; 函数声明<br>2. libcalc.a =&gt; 函数定义(二进制格式)<br></code></pre></td></tr></table></figure><h3 id="1-3静态库的使用"><a href="#1-3静态库的使用" class="headerlink" title="1.3静态库的使用"></a>1.3静态库的使用</h3><p>当我们得到了一个可用的静态库之后, 需要将其放到一个目录中, 然后根据得到的头文件编写测试代码, 对静态库中的函数进行调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 首先拿到了发布的静态库</span><br>`head.h` 和 `libcalc.a`<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 将静态库, 头文件, 测试程序放到一个目录中准备进行测试</span><br>.<br>├── head.h          # 函数声明<br>├── libcalc.a       # 函数定义（二进制格式）<br>└── main.c          # 函数测试<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 编译测试程序 main.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc main.c -o app</span><br>/tmp/ccR7Fk49.o: In function `main&#x27;:<br>main.c:(.text+0x38): undefined reference to `add&#x27;<br>main.c:(.text+0x58): undefined reference to `subtract&#x27;<br>main.c:(.text+0x78): undefined reference to `multiply&#x27;<br>main.c:(.text+0x98): undefined reference to `divide&#x27;<br>collect2: error: ld returned 1 exit status<br><br></code></pre></td></tr></table></figure><p>​编译的源文件中包含了头文件 <strong>head.h</strong>, 这个头文件中声明的函数对应的定义（也就是函数体实现）<strong>在静态库中</strong>，程序在编译的时候<strong>没有找到函数实现</strong>，因此提示 undefined reference to xxxx。</p><p>解决方案：在编译的时将静态库的路径和名字都指定出来</p><ul><li>-L: 指定库所在的目录(相对或者绝对路径)</li><li>-l: 指定库的名字, 需要掐头(lib)去尾(.a) 剩下的才是需要的静态库的名字</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">4. 编译的时候指定库信息</span><br>-L: 指定库所在的目录(相对或者绝对路径)<br>-l: 指定库的名字, 掐头(lib)去尾(.a) ==&gt; calc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-L -l, 参数和参数值之间可以有空格, 也可以没有  -L./ -lcalc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc main.c -o app -L ./ -l calc</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看目录信息, 发现可执行程序已经生成了</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── app   # 生成的可执行程序<br>├── head.h<br>├── libcalc.a<br>└── main.c<br></code></pre></td></tr></table></figure><h2 id="2、动态库"><a href="#2、动态库" class="headerlink" title="2、动态库"></a>2、动态库</h2><p><strong>动态链接库</strong>是程序运行时加载的库，当动态链接库正确部署之后，运行的多个程序可以使用同一个加载到内存中的<strong>动态库</strong>，因此在Linux中动态链接库也可称之为<strong>共享库</strong>。</p><p>动态链接库是<strong>目标文件的集合</strong>，目标文件在动态该链接库中的组织方式是按照特殊方式形成的。库中函数和变量的地址使用的是<strong>相对地址</strong>（静态库中使用的是绝对地址），其真实地址是在应用程序<strong>加载动态库时</strong>形成的。</p><p>关于动态库的<strong>命名规则</strong>如下：</p><ul><li><p>在Linux中动态库以lib作为前缀, 以.so作为后缀, 中间是库的名字自己指定即可, 即: libxxx.so</p></li><li><p>在Windows中动态库一般以lib作为前缀, 以dll作为后缀, 中间是库的名字需要自己指定, 即: libxxx.dll</p></li></ul><h3 id="2-1生成动态链接库"><a href="#2-1生成动态链接库" class="headerlink" title="2.1生成动态链接库"></a>2.1生成动态链接库</h3><p>生成动态链接库是直接使用gcc命令并且需要添加**-fPIC<strong>（-fpic） 以及</strong>-shared** 参数。</p><ul><li>-fPIC 或 -fpic 参数的作用是使得 gcc 生成的代码是与位置无关的，也就是使用相对位置</li><li>-shared参数的作用是告诉编译器生成一个动态链接库</li></ul><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202308031842259.png" alt="image-20230803184229204"></p><p>生成动态链接库的具体步骤如下:</p><ol><li>将源文件进行汇编操作，需要使用参数-c，海域要添加额外参数-fpic &#x2F; -fPIC</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">得到若干个 .o文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc 源文件(*.c) -c -fpic</span><br></code></pre></td></tr></table></figure><p>​2.将得到的.o文件打包成动态库, 还是使用gcc, 使用参数 -shared 指定生成动态库(位置没有要求)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -shared 与位置无关的目标文件(*.o) -o 动态库(libxxx.so)</span><br></code></pre></td></tr></table></figure><p>​3.发布动态库和头文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">发布</span><br> 1. 提供头文件: xxx.h<br> 2. 提供动态库: libxxx.so<br></code></pre></td></tr></table></figure><h3 id="2-2动态库制作举例"><a href="#2-2动态库制作举例" class="headerlink" title="2.2动态库制作举例"></a>2.2动态库制作举例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">举例, 示例目录如下:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">目录结构 add.c div.c mult.c sub.c -&gt; 算法的源文件, 函数声明在头文件 head.h</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">main.c中是对接口的测试程序, 制作库的时候不需要将 main.c 算进去</span><br>.<br>├── add.c<br>├── div.c<br>├── include<br>│   └── head.h<br>├── main.c<br>├── mult.c<br>└── sub.c<br></code></pre></td></tr></table></figure><p><strong>第一步: 使用gcc将源文件进行汇编(参数-c), 生成与位置无关的目标文件, 需要使用参数 -fpic或者-fPIC</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 将.c汇编得到.o, 需要额外的参数 -fpic/-fPIC</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc add.c div.c mult.c sub.c -c -fpic -I ./include/</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-fPIC 或 -fpic 参数的作用是使得 gcc 生成的代码是与位置无关的，也就是使用相对位置</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看目录文件信息, 检查是否生成了目标文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── add.c<br>├── add.o                # 生成的目标文件<br>├── div.c<br>├── div.o                # 生成的目标文件<br>├── include<br>│   └── head.h<br>├── main.c<br>├── mult.c<br>├── mult.o               # 生成的目标文件<br>├── sub.c<br>└── sub.o                # 生成的目标文件<br></code></pre></td></tr></table></figure><p><strong>第二步: 使用gcc将得到的目标文件打包生成动态库, 需要使用参数 -shared</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 将得到 .o 打包成动态库, 使用gcc , 参数 -shared</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -shared add.o div.o mult.o sub.o -o libcalc.so</span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">-shared参数的作用是告诉编译器生成一个动态链接库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查目录中是否生成了动态库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── add.c<br>├── add.o<br>├── div.c<br>├── div.o<br>├── include<br>│   └── `head.h   ===&gt; 和动态库一起发布<br>├── `libcalc.so   ===&gt; 生成的动态库<br>├── main.c<br>├── mult.c<br>├── mult.o<br>├── sub.c<br>└── sub.o<br></code></pre></td></tr></table></figure><p><strong>第三步: 发布生成的动态库和相关的头文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 发布库文件和头文件</span><br>1. head.h<br>2. libcalc.so<br></code></pre></td></tr></table></figure><h3 id="2-3动态库的使用"><a href="#2-3动态库的使用" class="headerlink" title="2.3动态库的使用"></a>2.3动态库的使用</h3><p>当我们得到了一个可用的动态库之后, 需要将其放到一个目录中, 然后根据得到的头文件编写测试代码, 对动态库中的函数进行调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 拿到发布的动态库</span><br>`head.h   libcalc.so<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 基于头文件编写测试程序, 测试动态库中提供的接口是否可用</span><br>`main.c`<br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例目录:</span><br>.<br>├── head.h          ==&gt; 函数声明<br>├── libcalc.so      ==&gt; 函数定义<br>└── main.c          ==&gt; 函数测试<br></code></pre></td></tr></table></figure><p><strong>编译测试程序</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 编译测试程序</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc main.c -o app</span><br>/tmp/ccwlUpVy.o: In function `main&#x27;:<br>main.c:(.text+0x38): undefined reference to `add&#x27;<br>main.c:(.text+0x58): undefined reference to `subtract&#x27;<br>main.c:(.text+0x78): undefined reference to `multiply&#x27;<br>main.c:(.text+0x98): undefined reference to `divide&#x27;<br>collect2: error: ld returned 1 exit status<br></code></pre></td></tr></table></figure><p>错误原因:</p><p>和使用静态库一样, 在编译的时候需要指定库相关的信息: 库的路径 -L和 库的名字 -l</p><p><strong>添加库信息相关参数, 重新编译测试代码:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在编译的时候指定动态库相关的信息: 库的路径 -L, 库的名字 -l</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc main.c -o app -L./ -lcalc</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-l中间可以不加空格</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看是否生成了可执行程序</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── app # 生成的可执行程序<br>├── head.h<br>├── libcalc.so<br>└── main.c<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行生成的可执行程序, 错误提示 ==&gt; 可执行程序执行的时候找不到动态库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./app</span> <br>./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory<br></code></pre></td></tr></table></figure><h3 id="2-4-解决动态库无法加载问题"><a href="#2-4-解决动态库无法加载问题" class="headerlink" title="2.4 解决动态库无法加载问题"></a>2.4 解决动态库无法加载问题</h3><h4 id="2-4-1-库的工作原理"><a href="#2-4-1-库的工作原理" class="headerlink" title="2.4.1 库的工作原理"></a>2.4.1 库的工作原理</h4><ul><li>静态库如何被加载</li></ul><p>​在程序编译的最后一个阶段也就是链接阶段，提供的静态库会被打包到可执行程序中。当可执行程序被执行，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法被加载的问题。</p><ul><li>动态库如何被加载</li></ul><p>​<strong>在程序编译的最后一个阶段也就是链接阶段：</strong></p><p>​在gcc命令中虽然指定了库路径(使用参数 -L ), 但是这个路径并没有记录到可执行程序中，只是检查了这个路径下的库文件是否存在。</p><p>​同样对应的动态库文件也没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。</p><p>​<strong>可执行程序被执行起来之后:</strong></p><p>​程序执行的时候会先检测需要的动态库是否可以被加载，加载不到就会提示上边的错误信息</p><p>​当动态库中的函数在程序中被调用了, 这个时候动态库才加载到内存，如果不被调用就不加载</p><p>​动态库的检测和内存加载操作都是由动态连接器来完成的</p><h4 id="2-4-2-动态链接器"><a href="#2-4-2-动态链接器" class="headerlink" title="2.4.2 动态链接器"></a>2.4.2 动态链接器</h4><p>动态链接器是一个独立于应用程序的进程, 属于操作系统, 当用户的程序需要加载动态库的时候动态连接器就开始工作了，很显然动态连接器根本就不知道用户通过 gcc 编译程序的时候通过参数 -L指定的路径。</p><p>那么动态链接器是如何搜索某一个动态库的呢，在它内部有一个默认的搜索顺序，按照优先级从高到低的顺序分别是：</p><ol><li>可执行文件内部的 DT_RPATH 段</li><li>系统的环境变量 LD_LIBRARY_PATH</li><li>系统动态库的缓存文件 &#x2F;etc&#x2F;ld.so.cache</li><li>存储动态库&#x2F;静态库的系统目录 &#x2F;lib&#x2F;, &#x2F;usr&#x2F;lib等</li></ol><p>按照以上四个顺序, 依次搜索, 找到之后结束遍历, 最终还是没找到, 动态连接器就会提示动态库找不到的错误信息。</p><h4 id="2-4-3-解决方案"><a href="#2-4-3-解决方案" class="headerlink" title="2.4.3 解决方案"></a>2.4.3 解决方案</h4><p>可执行程序生成之后, 根据动态链接器的搜索路径, 我们可以提供三种解决方案，我们只需要将动态库的路径放到对应的环境变量或者系统配置文件中，同样也可以将动态库拷贝到系统库目录（或者是将动态库的软链接文件放到这些系统库目录中）。</p><p><strong>方案1:</strong> 将库路径添加到环境变量 LD_LIBRARY_PATH 中</p><ol><li>找到相关的配置文件</li></ol><p>​用户级别: ~&#x2F;.bashrc —&gt; 设置对当前用户有效</p><p>​系统级别: &#x2F;etc&#x2F;profile —&gt; 设置对所有用户有效</p><p>​2.使用 vim 打开配置文件, 在文件最后添加这样一句话</p><p>​<strong>export LIBRARY_PATH&#x3D;$LIBRARY_PATH:动态库的绝对路径</strong></p><p>​3.让修改的配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改的是哪一个就执行对应的那个命令</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">source</span> 可以简写为一个 . , 作用是让文件内容被重新加载</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> ~/.bashrc          (. ~/.bashrc)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> /etc/profile       (. /etc/profile)</span><br></code></pre></td></tr></table></figure><p><strong>方案2:</strong> 更新 &#x2F;etc&#x2F;ld.so.cache 文件</p><p>1.找到动态库所在的绝对路径（不包括库的名字）比如：&#x2F;home&#x2F;robin&#x2F;Library&#x2F;</p><p>2.使用vim 修改 &#x2F;etc&#x2F;ld.so.conf 这个文件, 将上边的路径添加到文件中(独自占一行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 打开文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /etc/ld.so.conf</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 添加动态库路径, 并保存退出</span><br></code></pre></td></tr></table></figure><p>3.更新 &#x2F;etc&#x2F;ld.so.conf中的数据到 &#x2F;etc&#x2F;ld.so.cache 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">必须使用管理员权限执行这个命令</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ldconfig</span>   <br></code></pre></td></tr></table></figure><p><strong>方案3:</strong> 拷贝动态库文件到系统库目录 &#x2F;lib&#x2F; 或者 &#x2F;usr&#x2F;lib 中 (或者将库的软链接文件放进去)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">库拷贝</span><br>sudo cp /xxx/xxx/libxxx.so /usr/lib<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建软连接</span><br>sudo ln -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so<br></code></pre></td></tr></table></figure><h4 id="2-4-4-验证"><a href="#2-4-4-验证" class="headerlink" title="2.4.4 验证"></a>2.4.4 验证</h4><p>在启动可执行程序之前, 或者在设置了动态库路径之后, 我们可以通过一个命令检测程序能不能够通过动态链接器加载到对应的动态库, 这个命令叫做 <strong>ldd</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">语法:</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ldd 可执行程序名</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">举例:</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ldd app</span><br>linux-vdso.so.1 =&gt;  (0x00007ffe8fbd6000)<br>    libcalc.so =&gt; /home/robin/Linux/3Day/calc/test/libcalc.so (0x00007f5d85dd4000)<br>    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5d85a0a000)<br>    /lib64/ld-linux-x86-64.so.2 (0x00007f5d85fd6000)  ==&gt; 动态链接器, 操作系统提供<br></code></pre></td></tr></table></figure><h2 id="3、优缺点"><a href="#3、优缺点" class="headerlink" title="3、优缺点"></a>3、优缺点</h2><h3 id="3-1静态库"><a href="#3-1静态库" class="headerlink" title="3.1静态库"></a>3.1静态库</h3><p>优点：</p><ul><li>静态库被打包到应用程序中加载速度快</li><li>发布程序无需提供静态库，移植方便</li></ul><p>缺点：</p><ul><li>相同的库文件数据可能在内存中被加载多份, 消耗系统资源，浪费内存</li><li>库文件更新需要重新编译项目文件, 生成新的可执行程序, 浪费时间。</li></ul><h3 id="3-2-动态库"><a href="#3-2-动态库" class="headerlink" title="3.2 动态库"></a>3.2 动态库</h3><p>优点：</p><ul><li>可实现不同进程间的资源共享</li><li>动态库升级简单, 只需要替换库文件, 无需重新编译应用程序</li><li>程序猿可以控制何时加载动态库, 不调用库函数动态库不会被加载</li></ul><p>缺点：</p><ul><li>加载速度比静态库慢, 以现在计算机的性能可以忽略</li><li>发布程序需要提供依赖的动态库</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
      <tag>动态库和静态库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC</title>
    <link href="/2023/07/25/gcc%E5%92%8Cg++/"/>
    <url>/2023/07/25/gcc%E5%92%8Cg++/</url>
    
    <content type="html"><![CDATA[<h1 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h1><h2 id="1、GCC简介"><a href="#1、GCC简介" class="headerlink" title="1、GCC简介"></a>1、GCC简介</h2><p>GCC 官方文档网站：<a href="https://gcc.gnu.org/onlinedocs/">https://gcc.gnu.org/onlinedocs/</a></p><ul><li>官方文档是最权威的，网上所有的答案都来自官方文档</li><li>适应英语阅读，中文是母语，很多词我们自己有根深蒂固的含义和概念，再重新赋予新含义非常不容易理解或有歧义</li><li>英语用词、逻辑比较严谨，网上的翻译水平参差不齐，坑很多</li><li>国内论坛找到好答案全凭运气，好的答案可以节省时间，没有好的答案还是得花时间看官方文档，所以还是自己靠谱一点，锻炼一下英语能力</li></ul><span id="more"></span><h2 id="2、GCC的介绍"><a href="#2、GCC的介绍" class="headerlink" title="2、GCC的介绍"></a>2、GCC的介绍</h2><p>​   GCC 是 GNU项目的一个产品。</p><p>  GCC（GNU Compiler Collection，GNU编译程序集合）是最重要的开放源码软件。其他所有开放源码软件都在某种层次上依赖于它。甚至其他语言，例如 Python，都是由 C 语言开发的，由 GNU 编译程序编译的。</p><p>  这个软件对于整个自由软件运动而言具有根本性的意义。如果没有它或类似的软件，就不可能有自由软件运动。GCC 为 Linux 的出现提供了可能性。</p><p>  GCC 是由许多组件组成的，但它们也并不总是出现的。有些部分是和语言相关的，所以如果没有安装某种特定语言，系统中就不会出现相关的文件。</p><h3 id="2-1GCC常见的组成部分"><a href="#2-1GCC常见的组成部分" class="headerlink" title="2.1GCC常见的组成部分"></a>2.1GCC常见的组成部分</h3><ul><li><strong>c++：</strong> gcc 的一个版本，默认语言设置为 C++，而且在链接的时候自动包含标准 C++ 库。这和 g++ 一样</li><li><strong>configure：</strong> GCC 源代码树根目录中的一个脚本。用于设置配置值和创建 GCC 编译程序必需的 make 程序文件</li><li><strong>g++：</strong> gcc 的一个版本，默认语言设置为 C++，而且在链接的时候自动包含标准 C++库。这和 c++ 一样</li><li><strong>gcc：</strong> 该驱动程序等同于执行编译程序和连接程序以产生需要的输出</li><li><strong>libgcc：</strong> 该库包含的例程被作为编译程序的一部分，是因为它们可被链接到实际的可执行程序中。它们是特殊的例程，链接到可执行程序，来执行基本的任务，例如浮点运算。这些库中的例程通常都是平台相关的</li><li><strong>libstdc++：</strong> 运行时库，包括定义为标准语言一部分的所有的 C++类和函数</li></ul><h3 id="2-2GCC包含的常见的软件"><a href="#2-2GCC包含的常见的软件" class="headerlink" title="2.2GCC包含的常见的软件"></a>2.2GCC包含的常见的软件</h3><ul><li><strong>ar：</strong> 这是一个程序，可通过从文档中增加、删除和析取文件来维护库文件。通常使用该工具是为了创建和管理连接程序使用的目标库文档。该程序是 binutils 包的一部分</li><li><strong>as：</strong> GNU 汇编器。实际上它是一族汇编器，因为它可以被编译或能够在各种不同平台上工作。该程序是 binutjls 包的一部分 autoconf：产生的 shell 脚本自动配置源代码包去编译某个特定版本的 UNIX</li><li><strong>gdb：</strong> GNU 调试器，可用于检查程序运行时的值和行为 GNATS：GNU 的调试跟踪系统（GNU Bug Tracking System）。一个跟踪 GCC和其他 GNU 软件问题的在线系统</li><li><strong>gprof：</strong> 该程序会监督编译程序的执行过程，并报告程序中各个函数的运行时间，可以根据所提供的配置文件来优化程序。该程序是 binutils 包的一部分</li><li><strong>ld：</strong> GNU 连接程序。该程序将目标文件的集合组合成可执行程序。该程序是 binutils 包的一部分</li><li><strong>libtool：</strong> 一个基本库，支持 make 程序的描述文件使用的简化共享库用法的脚本</li><li><strong>make：</strong> 一个工具程序，它会读 makefile 脚本来确定程序中的哪个部分需要编译和连接，然后发布必要的命令。它读出的脚本（叫做 makefile 或 Makefile）定义了文件关系和依赖关系</li></ul><h2 id="3、GCC默认头文件搜索路径"><a href="#3、GCC默认头文件搜索路径" class="headerlink" title="3、GCC默认头文件搜索路径"></a>3、GCC默认头文件搜索路径</h2><p>查看命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo | gcc -v -x c -E -<br></code></pre></td></tr></table></figure><ul><li>&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7&#x2F;include</li><li>&#x2F;usr&#x2F;local&#x2F;include</li><li>&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7&#x2F;include-fixed</li><li>&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu</li><li>&#x2F;usr&#x2F;include</li></ul><h2 id="4、GCC工作流程"><a href="#4、GCC工作流程" class="headerlink" title="4、GCC工作流程"></a>4、GCC工作流程</h2><p>​GCC编译器对程序的编译分为4个阶段：预处理（预编译）、编译（优化）、汇编和链接。GCC的编译器可以将这4个步骤合并成一个。先介绍一下每一步都分别做了什么：</p><ol><li>预处理：在这个阶段主要做了三件事：<strong>展开头文件、宏替换、去掉注释行</strong>，这个阶段需要GCC调用预处理器来完成，最终得到的还是源文件</li><li>编译：这个阶段需要GCC调用编译器对文件进行编译，最终得到一个汇编文件</li><li>汇编：这个阶段需要GCC调用汇编器对文件进行汇编，最终得到一个二进制文件</li><li>链接：这个阶段需要GCC调用链接器对程序需要调用的库进行链接，最终得到一个可执行的二进制文件</li></ol><table><thead><tr><th align="center">文件名后缀</th><th align="center">说明</th><th align="center">gcc参数</th></tr></thead><tbody><tr><td align="center">.c</td><td align="center">源文件</td><td align="center">无</td></tr><tr><td align="center">.i</td><td align="center">预处理后的C文件</td><td align="center">-E</td></tr><tr><td align="center">.s</td><td align="center">编译之后得到的汇编语言的源文件</td><td align="center">-S</td></tr><tr><td align="center">.o</td><td align="center">汇编后得到的二进制文件</td><td align="center">-c</td></tr></tbody></table><p><strong>第一步：对源文件进行预处理，需要使用的gcc参数为-E</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">预处理, -o 指定生成的文件名</span><br>gcc -E test.c -o test.i<br></code></pre></td></tr></table></figure><p><strong>第二步：对预处理的文件进行编译，得到汇编文件.s，需要使用的gcc参数为-S</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">编译，得到汇编文件</span><br>gcc -S test.i -o test.s<br></code></pre></td></tr></table></figure><p><strong>第三步：对编译得到的汇编文件进行汇编，得到二进制.o文件，需要使用的gcc参数为-c</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">汇编</span><br>gcc -c test.s -o test.o<br></code></pre></td></tr></table></figure><p><strong>第四步：将得到的二进制文件和标准库进制链接，得到可执行二进制文件，不需要任何参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">链接</span><br>gcc test.o -o test <br></code></pre></td></tr></table></figure><p>在使用gcc编译程序的时候可以通过参数控制内部自动执行几个步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">参数 -c 是进行文件的汇编，汇编之前的两步会自动执行</span><br>gcc test.c -c -o app.o<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">该命令是直接进行链接生成可执行程序，链接之前的三步会自动执行</span><br>gcc test.c -o app<br></code></pre></td></tr></table></figure><h2 id="5、gcc常用参数"><a href="#5、gcc常用参数" class="headerlink" title="5、gcc常用参数"></a>5、gcc常用参数</h2><p>下边是常用的gcc参数，这些参数在gcc命令中没有位置要求，只需要编译程序的时候将需要的参数指定出来即可</p><table><thead><tr><th align="center">gcc编译选项</th><th align="center">选项的意义</th></tr></thead><tbody><tr><td align="center">-E</td><td align="center">预处理指定的源文件，不进行编译</td></tr><tr><td align="center">-S</td><td align="center">编译指定的源文件，但是不进行汇编</td></tr><tr><td align="center">-c</td><td align="center">编译、汇编指定的源文件，但是不进行链接</td></tr><tr><td align="center">-o [file1] [file2] &#x2F; [file2] -o [file1]</td><td align="center">将文件file2编译成file1</td></tr><tr><td align="center">-I(大写的i)</td><td align="center">指定include包含文件的搜索目录（中间可以加空格也可以不加）</td></tr><tr><td align="center">-g</td><td align="center">在编译的时候，生成调试信息，改程序可以被调试器调试</td></tr><tr><td align="center">-D</td><td align="center">在程序编译的时候，指定一个宏</td></tr><tr><td align="center">-w</td><td align="center">不生成任何警告信息，不建议使用，有些时候警告就是错误</td></tr><tr><td align="center">-Wall</td><td align="center">生成所有警告信息</td></tr><tr><td align="center">-On</td><td align="center">n的取值范围：0~3.编译器的优化选项的4个级别，-O0表示没有优化，-O1为默认值，-O3优化级别最高</td></tr><tr><td align="center">-l(小写L)</td><td align="center">在程序编译的时候，指定使用的库</td></tr><tr><td align="center">-L</td><td align="center">指定编译的时候，搜索的库的路径</td></tr><tr><td align="center">-fPIC&#x2F;fpic</td><td align="center">生成与位置无关的代码</td></tr><tr><td align="center">-shared</td><td align="center">生成共享目标文件。通常用在建立共享库时</td></tr><tr><td align="center">-std</td><td align="center">指定C方言，如：-std&#x3D;c99，gcc默认的方言是GNU C</td></tr></tbody></table><h3 id="5-1指定生成的文件名（-o）"><a href="#5-1指定生成的文件名（-o）" class="headerlink" title="5.1指定生成的文件名（-o）"></a>5.1指定生成的文件名（-o）</h3><p>该参数用于指定原文件通过 gcc 处理之后生成的新文件的名字, 有两种写法, 原文件可以写在参数 -o前边后缀写在后边。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">参数 -o的用法，源文件test.c最终生成的文件名为app</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">1test.c写在 -o 之前</span><br>gcc test.c -o app<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">2test.c写在 -o 之后</span><br>gcc -o app test.c<br></code></pre></td></tr></table></figure><h3 id="5-2搜索头文件（-I）"><a href="#5-2搜索头文件（-I）" class="headerlink" title="5.2搜索头文件（-I）"></a>5.2搜索头文件（-I）</h3><p>如果在程序中包含了一些头文件, 但是包含的一些头文件在程序预处理的时候因为找不到无法被展开，导致程序编译失败，这时候我们可以在gcc命令中添加 -I参数重新指定要引用的头文件路径, 保证编译顺利完成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-I, 指定头文件目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── add.c<br>├── div.c<br>├── include<br>│   └── head.h<br>├── main.c<br>├── mult.c<br>└── sub.c<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译当前目录中的所有源文件，得到可执行程序</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc *.c -o calc</span><br>main.c:2:18: fatal error: head.h: No such file or directory<br>compilation terminated.<br>sub.c:2:18: fatal error: head.h: No such file or directory<br>compilation terminated.<br></code></pre></td></tr></table></figure><p>通过编译得到的错误信息可以知道，<strong>源文件中包含的头文件无法被找到</strong>。头文件**”head.h”<strong>在</strong>include目录**中，因此可以使用   <strong>-I</strong> 参数来解决此问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc *.c -o app -I ./include<br></code></pre></td></tr></table></figure><h3 id="5-3指定一个宏（-D）"><a href="#5-3指定一个宏（-D）" class="headerlink" title="5.3指定一个宏（-D）"></a>5.3指定一个宏（-D）</h3><p>​在程序中我们可以使用宏定义一个常量, 也可以通过宏控制某段代码是否能够被执行。在下面这段程序中第8行判断是否定义了一个叫做 DEBUG的宏, 如果没有定义第9行代码就不会被执行了, 通过阅读代码能够知道这个宏是没有在程序中被定义的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;往下看&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;哈哈哈哈哈哈哈哈哈哈&quot;</span>)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果不想在程序中定义这个宏， 但是又想让它存在，通过gcc的参数 -D就可以实现了，编译器会认为参数后边指定的宏在程序中是存在的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在编译命令中定义这个DEBUG宏</span><br>gcc test.c -o app -D DEBUG<br><span class="hljs-meta prompt_">#</span><span class="language-bash">执行生成的程序，可以看到输出</span><br>往下看<br>哈哈哈哈哈哈哈哈哈哈<br></code></pre></td></tr></table></figure><p>-D参数的应用场景：</p><p>在发布程序的时候，一般都会要求将程序中所有的log输出去掉 如果不去掉会影响程序的执行效率，很显然删除这些打印log的源代码是一件很麻烦的事情，解决方案是这样的：</p><ul><li>将所有的打印log的代码都写到一个宏判定中, 可以模仿上边的例子</li><li>在编译程序的时候指定 -D 就会有log输出</li><li>在编译程序的时候不指定 -D, log就不会输出</li></ul><h2 id="6、多文件编译"><a href="#6、多文件编译" class="headerlink" title="6、多文件编译"></a>6、多文件编译</h2><p>GCC 可以自动编译链接多个文件，不管是目标文件还是源文件，都可以使用同一个命令编译到一个可执行文件中。</p><h3 id="6-1编译运行"><a href="#6-1编译运行" class="headerlink" title="6.1编译运行"></a>6.1编译运行</h3><p>因为头文件是包含在源文件中的, 因此在使用gcc编译程序的时候不需要指定头文件的名字（在头文件无法被找到的时候需要使用参数 -I 指定其具体路径而不是名字）。我们可以通过一个 gcc 命令将多个源文件编译并生成可执行程序，也可以分多步完成这个操作。</p><p><strong>直接生成可执行程序</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">直接生成可执行程序<span class="hljs-built_in">test</span></span><br>gcc -o test string .c main.c<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">运行可执行程序</span><br>./test<br></code></pre></td></tr></table></figure><p><strong>现将源文件编成目标文件，然后进行链接得到可执行程序</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">汇编生成二进制目标文件，指定了 -c 参数之后，源文件会自动生成 string.o和main.o</span><br>gcc -c string .c main.c<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">链接目标文件，生成可执行程序<span class="hljs-built_in">test</span></span><br>gcc -o test string.o main.o<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行可执行程序</span><br>./test<br></code></pre></td></tr></table></figure><h2 id="7、gcc和g"><a href="#7、gcc和g" class="headerlink" title="7、gcc和g++"></a>7、gcc和g++</h2><p>关于对gcc和g++很多人的理解都是比较片面的或者是对二者的理解有一些误区，下边从三个方面介绍一下二者的区别:</p><p>1在代码编译阶段（第二个阶段）:</p><p>​后缀为 <strong>.c</strong> 的，gcc 把它当作是<strong>C程序</strong>，而 g++ 当作是 <strong>C++</strong> 程序<br>​后缀为**.cpp<strong>的，</strong>两者都会认为是 C++ 程序**，C++ 的语法规则更加严谨一些<br>​g++会调用gcc，对于C++代码，两者是等价的, 也就是说 gcc 和 g++ 都可以编译 C&#x2F;C++代码</p><p>2在链接阶段（最后一个阶段）:</p><p>​gcc 和 g++ 都可以自动链接到标准C库<br>​g++ 可以自动链接到标准C++库, gcc如果要链接到标准C++库需要加参数 <strong>-lstdc++</strong><br>3关于 <strong>cplusplus宏的定义</strong></p><p>​g++ 会自动定义__cplusplus宏，但是这个不影响它去编译C程序__</p><p>​    gcc 需要根据文件后缀判断是否需要定义 __cplusplus 宏 （规则参考第一条）</p><p>综上所述：</p><ul><li><p>不管是 gcc 还是 g++ 都可以编译 C 程序，编译程序的规则和参数都相同</p></li><li><p>g++可以直接编译C++程序， gcc 编译 C++程序需要添加额外参数 -lstdc++</p></li><li><p>不管是 gcc 还是 g++ 都可以定义 __cplusplus宏</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编译 c 程序</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc test.c -o <span class="hljs-built_in">test</span><span class="hljs-comment"># 使用gcc</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ test.c -o <span class="hljs-built_in">test</span><span class="hljs-comment"># 使用g++</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译 c++ 程序</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ test.cpp -o <span class="hljs-built_in">test</span>              <span class="hljs-comment"># 使用g++</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc test.cpp -lstdc++ -o <span class="hljs-built_in">test</span>     <span class="hljs-comment"># 使用gcc</span></span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Transformer论文合集</title>
    <link href="/2023/07/13/100%E7%AF%87%E9%A1%B6%E4%BC%9A%E8%AE%BA%E6%96%87transformer/"/>
    <url>/2023/07/13/100%E7%AF%87%E9%A1%B6%E4%BC%9A%E8%AE%BA%E6%96%87transformer/</url>
    
    <content type="html"><![CDATA[<p><strong>1.Video swin transformer</strong> </p><p>代码：<a href="https://github.com/SwinTransformer/Video-Swin-Transformer">https://github.com/SwinTransformer/Video-Swin-Transformer</a> </p><p>会议：CVPR 2022 </p><p><strong>2.A survey on vision transformer</strong> </p><p>期刊：IEEE transactions on pattern analysis and machine intelligence </p><p><strong>3.Survey: Transformer based video-language pre-training</strong> </p><p>期刊：AI Open </p><p><strong>4.Cswin transformer: A general vision transformer backbone with cross-shaped windows</strong></p><p>代码：<a href="https://github.com/microsoft/CSWin-Transformer">https://github.com/microsoft/CSWin-Transformer</a> </p><p>会议：CVPR 2022 </p><p><strong>5.Swin transformer v2: Scaling up capacity and resolution</strong> </p><p>代码：<a href="https://github.com/microsoft/Swin-Transformer">https://github.com/microsoft/Swin-Transformer</a> </p><p>会议：CVPR 2022</p><p><strong>6.Transformer quality in linear time</strong> </p><p>会议：ICML 2022</p><p><strong>7.Uformer: A general u-shaped transformer for image restoration</strong> </p><p>代码：<a href="https://github.com/ZhendongWang6/Uformer">https://github.com/ZhendongWang6/Uformer</a> </p><p>会议：CVPR 2022 </p><p><strong>8.Transfg: A transformer architecture for fine-grained recognition</strong> </p><p>代码：<a href="https://github.com/TACJu/TransFG">https://github.com/TACJu/TransFG</a> </p><p>会议：AAAI 2022 </p><p><strong>9.Restormer: Efficient transformer for high-resolution image restoration</strong></p><p> 代码：<a href="https://github.com/swz30/restormer">https://github.com/swz30/restormer</a> </p><p>会议：CVPR 2022 </p><p><strong>10.TubeFormer-DeepLab: Video Mask Transformer</strong> </p><p>会议：CVPR 2022 </p><p><strong>11.Mobile-former: Bridging mobilenet and transformer</strong> </p><p>代码：<a href="https://github.com/BR-IDL/PaddleViT">https://github.com/BR-IDL/PaddleViT</a> </p><p>会议：CVPR 2022 </p><p><strong>12.Transformer for single image super-resolution</strong> </p><p>代码：<a href="https://github.com/luissen/esrt">https://github.com/luissen/esrt</a></p><p>会议：CVPR 2022 </p><p><strong>13.Anchor detr: Query design for transformer-based detector</strong> </p><p>代码：<a href="https://github.com/megvii-research/AnchorDETR">https://github.com/megvii-research/AnchorDETR</a> </p><p>会议：AAAI 2022 </p><p><strong>14.Towards robust vision transformer</strong> </p><p>代码：<a href="https://github.com/vtddggg/Robust-Vision-Transformer">https://github.com/vtddggg/Robust-Vision-Transformer</a> </p><p>会议：CVPR 2022 </p><p><strong>15.Maskgit: Masked generative image transformer</strong> </p><p>代码：<a href="https://github.com/google-research/maskgit">https://github.com/google-research/maskgit</a></p><p>会议：CVPR 2022 </p><p><strong>16.Contextual transformer networks for visual recognition</strong></p><p>代码：<a href="https://github.com/yehli/imagenetmodel">https://github.com/yehli/imagenetmodel</a> </p><p>期刊：IEEE Transactions on Pattern Analysis and Machine Intelligence </p><p><strong>17.Vision transformer with deformable attention</strong></p><p>代码：<a href="https://github.com/leaplabthu/dat">https://github.com/leaplabthu/dat</a> </p><p>会议：CVPR 2022 </p><p><strong>18.SwinFusion: cross-domain long-range learning for general image fusion via swin transformer</strong></p><p>期刊：IEEE&#x2F;CAA Journal of Automatica Sinica </p><p><strong>19.1OW-DETR: Open-world detection transformer</strong></p><p>代码：<a href="https://github.com/akshitac8/ow-detr">https://github.com/akshitac8/ow-detr</a></p><p>会议：CVPR 2022 </p><p><strong>20.PatchFormer: An Efficient Point Transformer With Patch Attention</strong></p><p>会议：CVPR 2022</p><p><strong>21.Pvt v2: Improved baselines with pyramid vision transformer</strong></p><p>代码：<a href="https://github.com/whai362/PVT">https://github.com/whai362/PVT</a> </p><p>期刊：Computational Visual Media </p><p><strong>22.Uctransnet: rethinking the skip connections in u-net from a channel-wise perspective with tr ansformer</strong></p><p>代码：<a href="https://github.com/mcgregorwwww/uctransnet">https://github.com/mcgregorwwww/uctransnet</a></p><p>会议：AAAI 2022 </p><p><strong>23.Masked-attention mask transformer for universal image segmentation</strong></p><p>代码：<a href="https://github.com/facebookresearch/Mask2Former">https://github.com/facebookresearch/Mask2Former</a></p><p>会议：CVPR 2022</p><p><strong>24.P2T: Pyramid pooling transformer for scene understanding</strong></p><p>代码：<a href="https://github.com/yuhuan-wu/P2T">https://github.com/yuhuan-wu/P2T</a></p><p>期刊：IEEE Transactions on Pattern Analysis and Machine Intelligence </p><p><strong>25.Prompting decision transformer for few-shot policy generalization</strong></p><p>代码：<a href="https://mxu34.github.io/PromptDT/">https://mxu34.github.io/PromptDT/</a></p><p>会议：ICML 2022 </p><p><strong>26.Nested hierarchical transformer: Towards accurate, data-efficient and interpretable visual u nderstanding</strong></p><p>代码：<a href="https://github.com/google-research/nested-transformer">https://github.com/google-research/nested-transformer</a></p><p>会议：AAAI 2022 </p><p><strong>27.Pale transformer: A general vision transformer backbone with pale-shaped attention</strong></p><p>代码：<a href="https://github.com/BR-IDL/PaddleViT">https://github.com/BR-IDL/PaddleViT</a></p><p>会议：AAAI 2022 </p><p><strong>28.Transmorph: Transformer for unsupervised medical image registration</strong></p><p>代码：<a href="https://github.com/junyuchen245/TransMorph_Transformer_for_Medical_Image_Registration">https://github.com/junyuchen245/TransMorph_Transformer_for_Medical_Image_Registration</a></p><p>期刊：Medical Image Analysis </p><p><strong>29.Transformer-based Multimodal Information Fusion for Facial Expression Analysis</strong></p><p>会议：CVPR 2022 </p><p><strong>30.Structure-aware transformer for graph representation learning</strong></p><p>代码：<a href="https://github.com/borgwardtlab/sat">https://github.com/borgwardtlab/sat</a> </p><p>会议：ICML 2022 </p><p><strong>31.Mst++: Multi-stage spectral-wise transformer for efficient spectral reconstruction</strong> </p><p>代码：<a href="https://github.com/caiyuanhao1998/MST-plus-plus">https://github.com/caiyuanhao1998/MST-plus-plus</a> </p><p>会议：CVPR 2022</p><p><strong>32.Cat: Cross attention in vision transformer</strong> </p><p>代码：<a href="https://github.com/linhezheng19/CAT">https://github.com/linhezheng19/CAT</a> </p><p>会议：ICME 2022 </p><p><strong>33.Ssast: Self-supervised audio spectrogram transformer</strong></p><p>代码：<a href="https://github.com/YuanGongND/ssast">https://github.com/YuanGongND/ssast</a></p><p>会议：AAAI 2022 </p><p><strong>34.Ds-transunet: Dual swin transformer u-net for medical image segmentation</strong></p><p>代码：<a href="https://github.com/TianBaoGe/DS-TransUNet">https://github.com/TianBaoGe/DS-TransUNet</a></p><p>期刊：IEEE Transactions on Instrumentation and Measurement </p><p><strong>35.Styleswin: Transformer-based gan for high-resolution image generation</strong></p><p>代码：<a href="https://github.com/microsoft/StyleSwin">https://github.com/microsoft/StyleSwin</a></p><p>会议：CVPR 2022</p><p><strong>36.Unified transformer tracker for object tracking</strong></p><p>代码：<a href="https://github.com/flowerfan/trackron">https://github.com/flowerfan/trackron</a></p><p>会议：CVPR 2022</p><p><strong>37.Video Frame Interpolation with Transformer</strong></p><p>代码：<a href="https://github.com/dvlab-research/vfiformer">https://github.com/dvlab-research/vfiformer</a></p><p>会议：CVPR 2022</p><p><strong>38.Few-shot object detection with fully cross-transformer</strong></p><p>代码：<a href="https://github.com/guangxinghan/fct">https://github.com/guangxinghan/fct</a></p><p>会议：CVPR 2022</p><p><strong>39.An efficient spatio-temporal pyramid transformer for action detection</strong></p><p>会议：ECCV 2022 </p><p><strong>40.Feature selection and classification of transformer faults based on novel meta-heuristic algo rithm</strong></p><p>会议：Mathematics</p><p><strong>41.MPViT: Multi-path vision transformer for dense prediction</strong></p><p>代码：<a href="https://github.com/youngwanLEE/MPViT">https://github.com/youngwanLEE/MPViT</a></p><p>会议：CVPR 2022</p><p><strong>42.Knowledge Distillation via the Target-aware Transformer</strong></p><p>代码：<a href="https://github.com/sihaoevery/TaT">https://github.com/sihaoevery/TaT</a></p><p>会议：CVPR 2022</p><p><strong>43.Fast Point Transformer</strong></p><p>代码：<a href="https://github.com/POSTECH-CVLab/FastPointTransformer">https://github.com/POSTECH-CVLab/FastPointTransformer</a></p><p>会议：CVPR 2022</p><p><strong>44.Chemformer: a pre-trained transformer for computational chemistry</strong></p><p>代码：<a href="https://github.com/MolecularAI/Chemformer">https://github.com/MolecularAI/Chemformer</a></p><p>期刊：Machine Learning: Science and Technology</p><p><strong>45.Lite vision transformer with enhanced self-attention</strong></p><p>代码：<a href="https://github.com/chenglin-yang/lvt">https://github.com/chenglin-yang/lvt</a></p><p>会议：CVPR 2022</p><p><strong>46.End-to-end temporal action detection with transformer</strong></p><p>代码：<a href="https://github.com/xlliu7/TadTR">https://github.com/xlliu7/TadTR</a></p><p>期刊：IEEE Transactions on Image Processing</p><p><strong>47.Stratified Transformer for 3D Point Cloud Segmentation</strong></p><p>代码：<a href="https://github.com/dvlab-research/stratified-transformer">https://github.com/dvlab-research/stratified-transformer</a></p><p>会议：CVPR 2022</p><p><strong>48.Image fusion transformer</strong></p><p>代码：<a href="https://github.com/Vibashan/Image-Fusion-Transformer">https://github.com/Vibashan/Image-Fusion-Transformer</a></p><p>会议：ICIP 2022</p><p><strong>49.Embracing single stride 3d object detector with sparse transformer</strong></p><p>代码：<a href="https://github.com/tusimple/sst">https://github.com/tusimple/sst</a></p><p>会议：CVPR 2022</p><p><strong>50.Msg-transformer: Exchanging local spatial information by manipulating messenger tokens 代码：<a href="https://github.com/hustvl/MSG-Transformer">https://github.com/hustvl/MSG-Transformer</a></strong></p><p>会议：CVPR 2022</p><p><strong>51.Danceformer: Music conditioned 3d dance generation with parametric motion transformer</strong></p><p> 代码：<a href="https://huiye-tech.github.io/post/danceformer/">https://huiye-tech.github.io/post/danceformer/</a> </p><p>会议：AAAI 2022</p><p><strong>52.Video frame interpolation transformer</strong></p><p>代码：<a href="https://github.com/dvlab-research/vfiformer">https://github.com/dvlab-research/vfiformer</a></p><p>会议：CVPR 2022</p><p><strong>53.A-ViT: Adaptive Tokens for Efficient Vision Transformer</strong></p><p>代码：<a href="https://a-vit.github.io/">https://a-vit.github.io/</a></p><p>会议：CVPR 2022</p><p><strong>54.Geometric transformer for fast and robust point cloud registration</strong></p><p>代码：<a href="https://github.com/qinzheng93/geotransformer">https://github.com/qinzheng93/geotransformer</a></p><p>会议：CVPR 2022</p><p><strong>55.Temporally Efficient Vision Transformer for Video Instance Segmentation</strong></p><p>代码：<a href="https://github.com/hustvl/tevit">https://github.com/hustvl/tevit</a></p><p>会议：CVPR 2022</p><p><strong>56.Multi-scale high-resolution vision transformer for semantic segmentation</strong></p><p>代码：<a href="https://github.com/facebookresearch/HRViT">https://github.com/facebookresearch/HRViT</a></p><p>会议：CVPR 2022</p><p><strong>57.Latr: Layout-aware transformer for scene-text vqa</strong></p><p>代码：<a href="https://github.com/uakarsh/latr">https://github.com/uakarsh/latr</a></p><p>会议：CVPR 2022</p><p><strong>58.Mask-guided spectral-wise transformer for efficient hyperspectral image reconstruction</strong></p><p>代码：<a href="https://github.com/caiyuanhao1998/MST">https://github.com/caiyuanhao1998/MST</a></p><p>会议：CVPR 2022</p><p><strong>59.Mvster: Epipolar transformer for efficient multi-view stereo</strong></p><p>代码：<a href="https://github.com/jeffwang987/mvster">https://github.com/jeffwang987/mvster</a></p><p>会议：ECCV 2022</p><p><strong>60.Recurrent glimpse-based decoder for detection with transformer</strong></p><p>代码：<a href="https://github.com/zhechen/deformable-detr-rego">https://github.com/zhechen/deformable-detr-rego</a> </p><p>会议：CVPR 2022</p><p><strong>61.Mhformer: Multi-hypothesis transformer for 3d human pose estimation</strong> </p><p>代码：<a href="https://github.com/Vegetebird/MHFormer">https://github.com/Vegetebird/MHFormer</a></p><p>会议：CVPR 2022</p><p><strong>62.Shapeformer: Transformer-based shape completion via sparse representation</strong> </p><p>代码：<a href="https://shapeformer.github.io/">https://shapeformer.github.io/</a></p><p>会议：CVPR 2022</p><p><strong>63.Styleformer: Transformer based generative adversarial networks with style vector</strong></p><p>代码：<a href="https://github.com/Jeeseung-Park/Styleformer">https://github.com/Jeeseung-Park/Styleformer</a></p><p>会议：CVPR 2022</p><p><strong>64.Transweather: Transformer-based restoration of images degraded by adverse weather condi tions</strong></p><p>代码：<a href="https://github.com/jeya-maria-jose/TransWeather">https://github.com/jeya-maria-jose/TransWeather</a></p><p>会议：CVPR 2022</p><p><strong>65.Opt: Open pre-trained transformer language models</strong></p><p>代码：<a href="https://github.com/facebookresearch/metaseq">https://github.com/facebookresearch/metaseq</a> 预印：arXiv preprint arXiv</p><p><strong>66.Transformer in transformer</strong></p><p>代码：<a href="https://github.com/huawei-noah/CV-Backbones">https://github.com/huawei-noah/CV-Backbones</a></p><p>期刊：Advances in Neural Information Processing Systems</p><p><strong>67.Msa transformer</strong></p><p>代码：<a href="https://github.com/The-AI-Summer/self-attention-cv">https://github.com/The-AI-Summer/self-attention-cv</a></p><p>会议：ICML 2021</p><p><strong>68.Point transformer</strong></p><p>代码：<a href="https://github.com/POSTECH-CVLab/point-transformer">https://github.com/POSTECH-CVLab/point-transformer</a></p><p>会议：ICCV 2021</p><p><strong>69.Transformer tracking 代码：<a href="https://github.com/chenxin-dlut/TransT">https://github.com/chenxin-dlut/TransT</a></strong></p><p>会议：CVPR 2021</p><p><strong>70.Vivit: A video vision transformer</strong></p><p>代码：<a href="https://github.com/google-research/scenic">https://github.com/google-research/scenic</a></p><p>会议：ICCV 2021</p><p><strong>71.Video transformer network</strong></p><p>代码：<a href="https://github.com/bomri/SlowFast/blob/master/projects/vtn/README.md">https://github.com/bomri/SlowFast/blob/master/projects/vtn/README.md</a> </p><p>会议：ICCV 2021 </p><p><strong>72.Swin transformer: Hierarchical vision transformer using shifted windows</strong></p><p>代码：<a href="https://github.com/microsoft/Swin-Transformer">https://github.com/microsoft/Swin-Transformer</a> 会议：ICCV 2021</p><p><strong>73.Swinir: Image restoration using swin transformer</strong></p><p>代码：<a href="https://github.com/JingyunLiang/SwinIR">https://github.com/JingyunLiang/SwinIR</a></p><p>会议：ICCV 2021</p><p><strong>74.Pre-trained image processing transformer</strong> </p><p>代码：<a href="https://github.com/huawei-noah/Pretrained-IPT">https://github.com/huawei-noah/Pretrained-IPT</a></p><p>会议：CVPR 2021</p><p><strong>75.Segmenter: Transformer for semantic segmentation</strong></p><p>代码：<a href="https://github.com/rstrudel/segmenter">https://github.com/rstrudel/segmenter</a></p><p>会议：ICCV 2021</p><p><strong>76.Pct: Point cloud transformer</strong> </p><p>代码：<a href="https://github.com/MenghaoGuo/PCT">https://github.com/MenghaoGuo/PCT</a> </p><p>期刊：Computational Visual Media</p><p><strong>77.Decision transformer: Reinforcement learning via sequence modeling</strong></p><p>代码：<a href="https://github.com/kzl/decision-transformer">https://github.com/kzl/decision-transformer</a></p><p>期刊：Advances in neural information processing systems</p><p><strong>78.Vilt: Vision-and-language transformer without convolution or region supervision</strong> </p><p>代码：<a href="https://github.com/dandelin/vilt">https://github.com/dandelin/vilt</a></p><p>会议：ICML 2021</p><p><strong>79.Rethinking transformer-based set prediction for object detection</strong></p><p>代码：<a href="https://github.com/edward-sun/tsp-detection">https://github.com/edward-sun/tsp-detection</a></p><p>会议：ICCV 2021</p><p><strong>80.Informer: Beyond efficient transformer for long sequence time-series forecasting</strong></p><p>代码：<a href="https://github.com/zhouhaoyi/Informer2020">https://github.com/zhouhaoyi/Informer2020</a></p><p>会议：AAAI 2021</p><p><strong>81.Crossvit: Cross-attention multi-scale vision transformer for image classification</strong></p><p>代码：<a href="https://github.com/IBM/CrossViT">https://github.com/IBM/CrossViT</a></p><p>会议：ICCV 2021</p><p><strong>82.Transformer interpretability beyond attention visualization</strong></p><p>代码：<a href="https://github.com/hila-chefer/Transformer-Explainability">https://github.com/hila-chefer/Transformer-Explainability</a> </p><p>会议：CVPR 2021</p><p><strong>83.Learning spatio-temporal transformer for visual tracking</strong></p><p>代码：<a href="https://github.com/researchmm/Stark">https://github.com/researchmm/Stark</a></p><p>会议：ICCV 2021</p><p><strong>84.Synthesizer: Rethinking self-attention for transformer models</strong></p><p>代码：<a href="https://github.com/10-zin/Synthesizer">https://github.com/10-zin/Synthesizer</a></p><p>会议：ICML 2021</p><p><strong>85.Transreid: Transformer-based object re-identification</strong></p><p>代码：<a href="https://github.com/heshuting555/TransReID">https://github.com/heshuting555/TransReID</a></p><p>会议：ICCV 2021</p><p><strong>86.Meshed-memory transformer for image captioning</strong></p><p>代码：<a href="https://github.com/aimagelab/meshed-memory-transformer">https://github.com/aimagelab/meshed-memory-transformer</a></p><p>会议：CVPR 2020</p><p><strong>87.Learning texture transformer network for image super-resolution</strong></p><p>代码：<a href="https://github.com/researchmm/TTSR">https://github.com/researchmm/TTSR</a></p><p>会议：CVPR 2020</p><p><strong>88.Streaming automatic speech recognition with the transformer model</strong></p><p>会议：ICASSP 2020</p><p><strong>89.On layer normalization in the transformer architecture</strong></p><p>代码：<a href="https://github.com/facebookresearch/xformers">https://github.com/facebookresearch/xformers</a></p><p>会议：ICML 2020 </p><p><strong>90.Intellicode compose: Code generation using transformer</strong></p><p>会议：ESEC&#x2F;FSE 2020</p><p><strong>91.BEHRT: transformer for electronic health records</strong></p><p>代码：<a href="https://github.com/yikuanli/BEHRT">https://github.com/yikuanli/BEHRT</a></p><p>期刊：Scientific reports </p><p><strong>92.Heterogeneous graph transformer</strong></p><p>代码：<a href="https://github.com/acbull/pyHGT">https://github.com/acbull/pyHGT</a></p><p>会议：Proceedings of The Web Conference 2020 </p><p><strong>93.Transformer transducer: A streamable speech recognition model with transformer encoders and rnn-t loss</strong></p><p>代码：<a href="https://github.com/hasangchun/Transformer-Transducer">https://github.com/hasangchun/Transformer-Transducer</a></p><p>会议：ICASSP 2020 </p><p><strong>94.Exploring the limits of transfer learning with a unified text-to-text transformer.</strong></p><p>代码：<a href="https://github.com/google-research/text-to-text-transfer-transformer">https://github.com/google-research/text-to-text-transfer-transformer</a></p><p>期刊：J. Mach. Learn. Res. </p><p><strong>95.Multi-modal transformer for video retrieval</strong></p><p>代码：<a href="https://github.com/gabeur/mmt">https://github.com/gabeur/mmt</a></p><p>会议：ECCV 2020 </p><p><strong>96.Self-supervised graph transformer on large-scale molecular data</strong></p><p>代码：<a href="https://github.com/tencent-ailab/grover">https://github.com/tencent-ailab/grover</a></p><p>期刊：Advances in Neural Information Processing Systems</p><p><strong>97.Transformer-based acoustic modeling for hybrid speech recognition</strong></p><p>会议：ICASSP 2020</p><p><strong>98.State-of-the-art augmented NLP transformer models for direct and single-step retrosynthesis</strong></p><p>代码：<a href="https://github.com/bigchem/synthesis">https://github.com/bigchem/synthesis</a></p><p>会议：Nature communications</p><p><strong>99.Graph transformer for graph-to-sequence learning</strong></p><p>代码：<a href="https://github.com/jcyk/gtos">https://github.com/jcyk/gtos</a></p><p>会议：AAAI 2020</p><p><strong>100.Tanda: Transfer and adapt pre-trained transformer models for answer sentence selection</strong></p><p>代码：<a href="https://github.com/alexa/wqa_tanda">https://github.com/alexa/wqa_tanda</a></p><p>会议：AAAI 2020</p>]]></content>
    
    
    <categories>
      
      <category>Transformer</category>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Transformer</tag>
      
      <tag>深度学习</tag>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux韩顺平</title>
    <link href="/2023/06/29/Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%9F%A9%E9%A1%BA%E5%B9%B3%EF%BC%89/"/>
    <url>/2023/06/29/Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%9F%A9%E9%A1%BA%E5%B9%B3%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>Linux的文件系统是采用级层式的树状目录结构，在此结构上的最上层是根目录“&#x2F;“，然后在此目录下在创建其他的目录。</li><li>深刻理解linux树状文件目录是非常重要的</li><li>记住一句很经典的话：在LInux世界里，一切皆文件</li></ul><span id="more"></span><h1 id="Linux学习（韩顺平）"><a href="#Linux学习（韩顺平）" class="headerlink" title="Linux学习（韩顺平）"></a>Linux学习（韩顺平）</h1><h2 id="一、Linux目录结构（重点）"><a href="#一、Linux目录结构（重点）" class="headerlink" title="一、Linux目录结构（重点）"></a>一、Linux目录结构（重点）</h2><h3 id="1-1基本介绍"><a href="#1-1基本介绍" class="headerlink" title="1.1基本介绍"></a>1.1基本介绍</h3><ul><li>linux的文件系统是采用级层式的树状目录结构，在此结构上的最上层是根目录“&#x2F;“，然后在此目录下在创建其他的目录。</li><li>深刻理解linux树状文件目录是非常重要的</li><li>记住一句很经典的话：在Linux世界里，一切皆文件</li></ul><h3 id="2-2具体的目录结构"><a href="#2-2具体的目录结构" class="headerlink" title="2.2具体的目录结构"></a>2.2具体的目录结构</h3><ul><li><p>&#x2F;bin 【常用】（&#x2F;usr&#x2F;bin、&#x2F;uer&#x2F;local&#x2F;bin)</p><p>是Binary的缩写，这个目录存放着最常使用的命令，例如ls cd cp等指令</p></li><li><p>&#x2F;sbin （&#x2F;usr&#x2F;sbin、&#x2F;usr&#x2F;local&#x2F;sbin）</p></li></ul><p>​s就是Super user的意思，这里存放的是系统管理员使用的系统管理程序</p><p>​里边存放管理员权限才能用的指令，例如reboot，shutdown等</p><ul><li><p>&#x2F;home 【常用】</p><p>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录是以用户的账号命名</p></li><li><p>root 【常用】</p></li></ul><p>​该目录为系统管理员，也称作超级权限者的用户主目录</p><ul><li><p>&#x2F;lib 系统开机所需要的最基本的动态链接共享库，起作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库</p></li><li><p>&#x2F;lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件</p></li><li><p>etc 【常用】</p><p>所有的系统管理所需要的配置文件和子目录，比如安装mysql数据库，my.conf</p></li><li><p>&#x2F;usr 【常用】</p><p>这是一个非常重要的目录，用户很多应用程序都放在这个目录下，类似于windows下的program files目录。&#x2F;usr中有bin和sbin，usr中的bin和sbin命令是应用级命令，是系统必备的命令，但非必需的命令，例如bin下的vi,ssh,gcc,ping等是usr&#x2F;bin下的，sendmail、samba、netconfig等是usr&#x2F;sbin下的指令，是管理员级别的指令。</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307060853555.png" alt="image-20230706085339834"></p></li><li><p>&#x2F;boot 【常用】</p><p>存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</p></li><li><p>&#x2F;proc 这个目录是一个虚拟的目录，他是系统内存的映射，访问这个目录来获取系统信息</p></li><li><p>&#x2F;srv service缩写，该目录存放一些服务器启动后需要提取的数据</p></li><li><p>&#x2F;sys 这是linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs</p></li><li><p>&#x2F;tmp这个目录是用来存放一些临时文件的</p></li><li><p>&#x2F;dev</p></li></ul><p>​类似于windows的设备管理器，把所有的硬件用文件的形式存储</p><ul><li><p>&#x2F;media[常用]linux系统会自动识别一些设备，例如U盘，光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</p></li><li><p>&#x2F;mnt [常用]</p><p>系统提供该目录是为了让用户临时挂载别的系统文件，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看里面的内容了。D:&#x2F;mushare</p></li><li><p>&#x2F;opt 这是给主机额外的安装软件所存放的目录。如安装ORACLE数据库就可以放到该目录下。默认为空</p></li><li><p>&#x2F;usr&#x2F;local【常用】</p><p>这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码的方式安装的程序</p></li><li><p>&#x2F;var 【常用】</p><p>这个目录中存放着在不断扩充的东西 ，习惯的将经常修改的目录放在这个目录下。包括各种日志文件</p></li><li><p>&#x2F;selinux 【security-enhanced linux】</p><p>SELinux是一种安全子系统，他能控制程序自能访问特定的文件，有三种工作模式，可以自行设置</p></li></ul><h2 id="二、vi和vim编辑器"><a href="#二、vi和vim编辑器" class="headerlink" title="二、vi和vim编辑器"></a>二、vi和vim编辑器</h2><h3 id="2-1-vi和vim的基本介绍"><a href="#2-1-vi和vim的基本介绍" class="headerlink" title="2.1 vi和vim的基本介绍"></a>2.1 vi和vim的基本介绍</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">Linux系统会内置<span class="hljs-keyword">vi</span>文本编辑器<br><br>Vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译错误跳转等方便编程的功能相当丰富，在程序员中被广泛使用。（<span class="hljs-keyword">vim</span>就是<span class="hljs-keyword">vi</span>的增强版）<br></code></pre></td></tr></table></figure><p>Linux系统会内置vi文本编辑器</p><p>Vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译错误跳转等方便编程的功能相当丰富，在程序员中被广泛使用。（vim就是vi的增强版）</p><h3 id="2-2-vi和vim常用的三种模式"><a href="#2-2-vi和vim常用的三种模式" class="headerlink" title="2.2 vi和vim常用的三种模式"></a>2.2 vi和vim常用的三种模式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>、正常模式<br><br>以vim打开一个档案就直接进入一般模式了（这是默认的模式）<br>在这个模式中，可以使用【上下左右】键来移动光标<br>可以使用【删除字符】或【删除整行】来处理档案内容<br>也可以使用【复制、粘贴】来处理你的文件数据。<br><br><span class="hljs-number">2</span>、插入模式<br><br>按下<span class="hljs-selector-tag">i</span>，<span class="hljs-selector-tag">I</span>，o，O，<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">A</span>，r，R等任何一个字母之后才会进入编辑模式，一般来说按<span class="hljs-selector-tag">i</span>就可<br><br><span class="hljs-number">3</span>、命令行模式<br><br>在这个模式中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等动作则是在此模式中达成的！<br></code></pre></td></tr></table></figure><h3 id="2-3-vi-和-vim-基本使用"><a href="#2-3-vi-和-vim-基本使用" class="headerlink" title="2.3. vi 和 vim 基本使用"></a>2.3. vi 和 vim 基本使用</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino">案例：使用 vim 开发一个 Hello.java 程序<br><br>使用xshell登录编写(因为以后工作都是这样写的)：<br>首先输入：vi Hello.java 或者 vim Hello.<span class="hljs-built_in">java</span> (使用vim编辑器编写java程序)<br>回车后进入正常模式<br>之后输入i等字母，进入插入模式(编辑模式)<br>然后可是写代码：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span></span>&#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>&#125;<br>&#125;<br>然后保存，怎么保存？<br>先 按 Esc 回到正常模式<br>然后输入冒号:  接着输入<span class="hljs-built_in">wq</span> (代表写入并退出write quit)<br>回车<br>结束<br><br>输入ls命令，就可以看到Hello.java文件<br>还想修该文件：再输入 vim Hello.<span class="hljs-built_in">java</span> (按Tab键 代码补全) 就有回到了上面<br></code></pre></td></tr></table></figure><h3 id="2-4各种模式的相互切换"><a href="#2-4各种模式的相互切换" class="headerlink" title="2.4各种模式的相互切换"></a>2.4各种模式的相互切换</h3><p><img src="F:\Typora笔记\Linux学习（韩顺平）.assets\image-20230529170744717.png" alt="image-20230529170744717"></p><h3 id="2-5vi和vim快捷键"><a href="#2-5vi和vim快捷键" class="headerlink" title="2.5vi和vim快捷键"></a>2.5vi和vim快捷键</h3><table><thead><tr><th>快捷键</th><th>模式</th><th>介绍</th></tr></thead><tbody><tr><td><code>yy</code></td><td>正常模式</td><td>复制当前行</td></tr><tr><td><code>p</code></td><td>正常模式</td><td>粘贴</td></tr><tr><td><code>5yy</code></td><td>正常模式</td><td>复制当前行向下的5行</td></tr><tr><td><code>dd</code></td><td>正常模式</td><td>删除当前行</td></tr><tr><td><code>5dd</code></td><td>正常模式</td><td>删除当前行向下的5行</td></tr></tbody></table><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros">在文件中查找某个单词：<br>初始在正常模式，输入/，进入命令行模式，然后输入要查找的单词，回车查找<br>输入n查找到下一个<br>想查找另一个单词：输入/，重复上述即可<br><br>正常模式---&gt;命令行模式<br>给文件每行设置行号：<br>先冒号: <br>然后<span class="hljs-built_in">set</span> nu  (<span class="hljs-built_in">set</span> number)<br>回车<br>取消行号：<br>先冒号:<br>然后<span class="hljs-built_in">set</span> nonu<br>回车<br><br>快捷键到该文档的最首行(正常模式)：gg<br><br>快捷键到该文档的最末行(正常模式)：G<br><br>撤销动作(比如删除某一行，发现删错了，然后恢复这一行)(正常模式)：u<br><br>在某个文件中，想让光标移动到第20行(正常模式)：输入20，再输入 shift+g<br><br>更多的快捷键：有整理的文档和下图<br><br></code></pre></td></tr></table></figure><p><img src="F:\Typora笔记\Linux学习（韩顺平）.assets\image-20230529171033651.png" alt="image-20230529171033651"></p><h2 id="三、Linux-实操篇-开机、重启和用户登录注销"><a href="#三、Linux-实操篇-开机、重启和用户登录注销" class="headerlink" title="三、Linux 实操篇-开机、重启和用户登录注销"></a>三、Linux 实操篇-开机、重启和用户登录注销</h2><h3 id="3-1关机重启命令"><a href="#3-1关机重启命令" class="headerlink" title="3.1关机重启命令"></a>3.1关机重启命令</h3><table><thead><tr><th>命令</th><th align="center">介绍</th></tr></thead><tbody><tr><td>shutdown -h now</td><td align="center">立即关机(h—&gt;halt停止)</td></tr><tr><td>halt</td><td align="center">立即关机，同上</td></tr><tr><td>shutdown</td><td align="center">1分钟后关机</td></tr><tr><td>shutdown -h 1</td><td align="center">同上，给每一个登录到Linux系统的用户发一条消息：1分钟后关机</td></tr><tr><td>shutdown -h 2</td><td align="center">2分钟后关机</td></tr><tr><td>shutdonw -r now</td><td align="center">现在重新启动(r—&gt;rboot重启)</td></tr><tr><td>reboot</td><td align="center">现在重新启动，同上</td></tr><tr><td>sync</td><td align="center">把内存的数据同步到磁盘</td></tr><tr><td>注意</td><td align="center">不管是重启还是关机，首先要运行 sync 命令，把内存中的数据写到磁盘中；目前的 shutdown&#x2F;reboot&#x2F;halt 等命令均已经在关机前进行了sync，但还是手动执行一下sync保险</td></tr></tbody></table><h3 id="3-2用户登录和注销"><a href="#3-2用户登录和注销" class="headerlink" title="3.2用户登录和注销"></a>3.2用户登录和注销</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">用户登录：<br>登录时尽量少用 root 帐号登录，因为它是系统管理员，最大的权限，避免操作失误。<br>而且以后也用不到root，除非你是系统管理员。<br>可以利用普通用户登录，登录后再用”su - 用户名’命令来切换成系统管理员身份<br>注销：<br>在提示符下输入 <span class="hljs-built_in">logout</span>  即可注销用户<br><br>注意：<span class="hljs-built_in">logout</span> 注销指令在图形运行级别无效，在运行级别 3 下有效.<br>运行级别后面讲。<br><br>验证：<br>使用普通用户登录<br>使用Xshell远程登陆Linux<br>输入命令：su - root   变为root用户<br>再输入：<span class="hljs-built_in">logout</span>  注销用户回到普通用户<br>再输入：<span class="hljs-built_in">logout</span> 退出系统<br><br>注意：退出系统后，如何要重新连接到Linux，双击左栏会话再重新输入即可。<br></code></pre></td></tr></table></figure><h2 id="四、Linux-实操篇-用户管理"><a href="#四、Linux-实操篇-用户管理" class="headerlink" title="四、Linux 实操篇-用户管理"></a>四、Linux 实操篇-用户管理</h2><h3 id="4-1-基本介绍"><a href="#4-1-基本介绍" class="headerlink" title="4.1.基本介绍"></a>4.1.基本介绍</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery">Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。<br><br>一个Linux系统中只有一<span class="hljs-built_in">个root</span>用户，但是<span class="hljs-built_in">由root</span>用户可以创建多个其他用户，可以给这些用户分配权限，<br>其中每个用户会对应一个目录，这个目录叫做home目录。<br></code></pre></td></tr></table></figure><h3 id="4-2添加用户"><a href="#4-2添加用户" class="headerlink" title="4.2添加用户"></a>4.2添加用户</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino">语法：useradd 用户名<br>比如：useradd klay 注册新用户klay<br><br>注意：当创建用户成功后，会自动创建和用户同名的家目录，该用户的家目录默认在home目录下<br><br>也可以给新用户指定家目录：useradd -d 指定目录 新用户名<br>比如：useradd -d /home/test king 创建一个新用户king，其家目录test<br></code></pre></td></tr></table></figure><h3 id="4-3指定-x2F-修改密码"><a href="#4-3指定-x2F-修改密码" class="headerlink" title="4.3指定&#x2F;修改密码"></a>4.3指定&#x2F;修改密码</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq">语法：passwd 用户名  给某个用户设置/更改密码<br>注意：要写用户名。不写用户名默认设置当前用户，如果当前用户是root就麻烦了。<br>比如：给milan设置密码 <br><br>命令：pwd ---&gt;显示当前用户所在目录 <span class="hljs-keyword">Print</span> Working Directory<br></code></pre></td></tr></table></figure><h3 id="4-4删除用户"><a href="#4-4删除用户" class="headerlink" title="4.4删除用户"></a>4.4删除用户</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">语法： userdel 用户名<br><br>普通用户不能删除别的用户，只有root用户可以；并且不能自己删除自己<br><br><span class="hljs-number">1</span>.删掉用户，但是保留其家目录：<br>userdel 用户名<br><span class="hljs-number">2</span>.将用户和其家目录一起删除(这个操作要谨慎)：<br><span class="hljs-keyword">user</span> <span class="hljs-title">-r</span> 用户名<br><br>一般情况，建议保留家目录(不删除)<br></code></pre></td></tr></table></figure><h3 id="4-5查询用户信息"><a href="#4-5查询用户信息" class="headerlink" title="4.5查询用户信息"></a>4.5查询用户信息</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xquery">语法<span class="hljs-built_in">：id</span> 用户名<span class="hljs-built_in"></span><br><span class="hljs-built_in">id</span><span class="hljs-built_in"> root</span>:<br>uid=<span class="hljs-number">0</span><span class="hljs-built_in">(root</span>) gid=<span class="hljs-number">0</span><span class="hljs-built_in">(root</span>) 组=<span class="hljs-number">0</span><span class="hljs-built_in">(root</span>)  userid是<span class="hljs-number">0</span> gruopid<span class="hljs-built_in">组id</span>是<span class="hljs-number">0</span> 所在组<span class="hljs-number">0</span><br><br>当用户不存在：返回无此用户 no such user<br></code></pre></td></tr></table></figure><h3 id="4-6切换用户"><a href="#4-6切换用户" class="headerlink" title="4.6切换用户"></a>4.6切换用户</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">在操作 Linux 中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户(比如 root)<br><br>语法： su - 切换用户名<br><br>创建一个用户lucy，指定密码，然后切换到lucy<br><br>注意：<br><span class="hljs-number">1</span>.从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。<br><span class="hljs-number">2</span>.当需要返回到原来用户时，使用 <span class="hljs-keyword">exit</span>/logout 指令<br></code></pre></td></tr></table></figure><h3 id="4-7查看当前用户-x2F-登录用户"><a href="#4-7查看当前用户-x2F-登录用户" class="headerlink" title="4.7查看当前用户&#x2F;登录用户"></a>4.7查看当前用户&#x2F;登录用户</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">语法：who am <span class="hljs-selector-tag">i</span> 或者 who am <span class="hljs-selector-tag">I</span><br>who am <span class="hljs-selector-tag">i</span> ---&gt;第一个登录该系统的用户信息<br>假设<span class="hljs-selector-tag">A</span>用户登录系统，切换到<span class="hljs-selector-tag">B</span>用户，<span class="hljs-selector-tag">B</span>输入命令who am <span class="hljs-selector-tag">i</span>，输出的还是<span class="hljs-selector-tag">A</span>用户的信息<br></code></pre></td></tr></table></figure><h3 id="4-8用户组"><a href="#4-8用户组" class="headerlink" title="4.8用户组"></a>4.8用户组</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs routeros">介绍：类似于角色，系统可以对有共性/有相同的权限的多个用户进行统一的管理<br><br>新增组：groupadd 组名<br>假如A用户和B用户有相同的权限，一个一个赋权限太麻烦了；<br>可以把A用户和B用户放在一个组里，然后给这个组赋权限，组里的用户有相同的权限。<br><br>新增一个用户，其实会默认生成一个跟用户名相同的组，然后把用户放到该组里。<br>就像是 id root：<span class="hljs-attribute">uid</span>=0(root) <span class="hljs-attribute">gid</span>=0(root) 组=0(root)---&gt;root组<br><br>例子：增加一个用户zwj，把他直接放到组wudang中<br>命令：<br>groupadd wudang<br>useradd -g wudang zwj<br>id zwj：<span class="hljs-attribute">uid</span>=1001(zwj) <span class="hljs-attribute">gid</span>=1001(wudang) 组=1001(wudang)<br><br><br><br>修改用户的组：usermod -g 用户组 用户名<br>例子：把zwj 放到组 mojiao 中<br>命令：<br>groupadd mojiao<br>usermod -g mojiao zwj<br>id zwj：<span class="hljs-attribute">uid</span>=1001(zwj) <span class="hljs-attribute">gid</span>=1002(mojiao) 组=1002(mojiao)<br><br>新增一个用户john，怎么把john放进组mojiao中？<br>useradd jhon<br>usermod -g mojiao jhon<br>新增一个用户john，john在以自己的名字命名的组john中，从john组到mojiao组<br><br><br>删除组：groupdel 组名<br></code></pre></td></tr></table></figure><h3 id="4-9用户和组的相关文件"><a href="#4-9用户和组的相关文件" class="headerlink" title="4.9用户和组的相关文件"></a>4.9用户和组的相关文件</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gradle">(<span class="hljs-number">1</span>)<span class="hljs-regexp">/etc/</span>passwd 文件<br>每增加一个用户，就会把用户的信息保存到该文件。<br>用户（user）的配置文件，记录用户的各种信息<br>每行都是一个用户，每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell<br><br>主目录：用户所在的家目录<br><br>shell：命令解释程序<br>将发布的指令通过shell解析，再传给Linux内核<br>Linux是看不懂发布的指令的<br>shell有很多种，中国一般用的是bash<br><br>命令：viw <span class="hljs-regexp">/etc/</span>passwd 可以查看该文件(还有其他命令)<br><br>(<span class="hljs-number">2</span>)<span class="hljs-regexp">/etc/</span>shadow 文件<br>口令的配置文件<br>每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志<br><br>(<span class="hljs-number">3</span>)<span class="hljs-regexp">/etc/g</span>roup 文件<br>组(<span class="hljs-keyword">group</span>)的配置文件，记录 Linux 包含的组的信息每行含义：组名:口令:组标识号:组内用户列表<br></code></pre></td></tr></table></figure><h2 id="五、Linux-实操篇-实用指令"><a href="#五、Linux-实操篇-实用指令" class="headerlink" title="五、Linux 实操篇-实用指令"></a>五、Linux 实操篇-实用指令</h2><h3 id="5-1指定运行级别"><a href="#5-1指定运行级别" class="headerlink" title="5.1指定运行级别"></a>5.1指定运行级别</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">Linux</span>系统运行级别：<br><span class="hljs-string">0</span>：关机<br><span class="hljs-string">1</span>：单用户【可以找回丢失密码】<br><span class="hljs-string">2</span>：多用户状态没有网络服务(一般不用，没网络)<br><span class="hljs-string">3</span>：多用户状态有网络服务<br><span class="hljs-string">4</span>：系统未使用保留给用户<br><span class="hljs-string">5</span>：图形界面<br><span class="hljs-string">6</span>：系统重启<br>常用运行级别是 <span class="hljs-string">3</span> 和 <span class="hljs-string">5</span><br><br>切换运行级别命令：<span class="hljs-string">init</span> 选<span class="hljs-string">0-6</span><br><br>指定默认运行级别：<br><span class="hljs-string">CentOS7</span>之前是在文件/<span class="hljs-string">etc</span>/<span class="hljs-string">inittab</span>文件中设置<br><span class="hljs-string">CentOS7</span>之后对设置进行了简化：<br>用 <span class="hljs-string">multi-user</span>.<span class="hljs-string">target</span> 代表<span class="hljs-string">3</span>运行级别<br>用 <span class="hljs-string">graphical</span>.<span class="hljs-string">target</span> 代表<span class="hljs-string">5</span>运行级别<br><span class="hljs-string">7</span>版本之后主要用<span class="hljs-string">3</span>和<span class="hljs-string">5</span>运行级别。<br><br>用命令：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">get-default</span> 查看当前系统运行级别<br>用命令：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">set-default</span> <span class="hljs-string">multi-user</span>.<span class="hljs-string">target</span> /<span class="hljs-string">graphical</span>.<span class="hljs-string">target</span>  设置默认运行级别<br></code></pre></td></tr></table></figure><h3 id="5-2找回-root-密码"><a href="#5-2找回-root-密码" class="headerlink" title="5.2找回 root 密码"></a>5.2找回 root 密码</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">在登录系统时，忘记<span class="hljs-built_in">了root</span>密码，如何找<span class="hljs-built_in">回root</span>密码？<br>资料中有，不同版本方式不同，介绍CentOS7之后的版本解决方法：<br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307131100781.png" alt="image-20230713110054718"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307131101406.png" alt="image-20230713110128323"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307131101160.png" alt="image-20230713110141117"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307131102323.png" alt="image-20230713110202243"></p><h3 id="5-3帮助指令"><a href="#5-3帮助指令" class="headerlink" title="5.3帮助指令"></a>5.3帮助指令</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">语法：man 命令或配置文件<br>是manual的简写，manual是手册的意思<br><br>功能：获得帮助信息<br>例子：查看<span class="hljs-keyword">ls</span>命令的帮助信息<br><br>输入 man <span class="hljs-keyword">ls</span> 之后，会看到<span class="hljs-keyword">ls</span>的具体信息<span class="hljs-params">(要回到前一个页面，输入q)</span><br>注意：可能不止一页，使用空格或下键，可以往下看<br><br><span class="hljs-params">---------------------------------------------------------------------</span><br><span class="hljs-keyword">ls</span>命令：列出目录内容<br>格式：<span class="hljs-keyword">ls</span> [选项] [文件名<span class="hljs-string">...</span>]     <br> <span class="hljs-keyword">ls</span>  -a  <span class="hljs-params">---</span>&gt;列出所有文件，包括隐藏文件<span class="hljs-params">(隐藏文件以 . 开头)</span><br> <span class="hljs-keyword">ls</span>  -l  <span class="hljs-params">---</span>&gt;单列输出 <br><br>选项以 - 开始<br>选项可以组合使用，没有顺序：<br>比如： <span class="hljs-keyword">ls</span> -al  也可以 <span class="hljs-keyword">ls</span> -a -l  表示列出所有的文件 并 单列输出<br><br><span class="hljs-keyword">ls</span>默认是对当前目录下的文件<br>也可以指定某个目录：<br>如： <span class="hljs-keyword">ls</span> -al <span class="hljs-string">/root</span>  把root目录下的所有文件单列输出<br><span class="hljs-params">---------------------------------------------------------------------</span><br><br>语法：<span class="hljs-keyword">help</span> 命令<br>功能：获得 shell 内置命令的帮助信息<br>例子：查看 <span class="hljs-keyword">cd</span> 命令的帮助信息<br><span class="hljs-keyword">help</span> <span class="hljs-keyword">cd</span><br><br>语法：man [命令或配置文件]<br>功能：获得帮助信息<br>例子：查看<span class="hljs-keyword">ls</span>命令的帮助信息<br>man <span class="hljs-keyword">ls</span><br></code></pre></td></tr></table></figure><h3 id="5-4关于文件目录的指令"><a href="#5-4关于文件目录的指令" class="headerlink" title="5.4关于文件目录的指令"></a>5.4关于文件目录的指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs bash">基本语法：<span class="hljs-built_in">pwd</span>    (<span class="hljs-built_in">print</span> working directory)<br>功能：显示当前目录的绝对路径<br>---------------------------------------------------------------------<br><br>基本语法：<span class="hljs-built_in">ls</span> [选项] [目录或是文件]<br>常用选项：<br>-a：显示当前目录所有的文件和目录，包括隐藏的。<br>-l：以列表的方式显示信息<br>---------------------------------------------------------------------<br><br>基本语法：<span class="hljs-built_in">cd</span> [参数]<br>功能：切换到指定目录<br><br><span class="hljs-built_in">cd</span> ~ 或者 <span class="hljs-built_in">cd</span> ---&gt;回到当前用户的家目录 <br><span class="hljs-built_in">cd</span> ..   ---&gt;回到当前目录的上一级目录<br><br>案例 1：使用绝对路径切换到 root 目录<br><span class="hljs-built_in">cd</span> /root<br><br>案例 2：使用相对路径到 root 目录<br>比如当前在 /home/tom <br><span class="hljs-built_in">cd</span> ../../root    ../..回到了根目录,再/root<br><br>---------------------------------------------------------------------<br><br>基本语法：<span class="hljs-built_in">mkdir</span> [选项] 要创建的目录路径<br>功能：创建目录<br>常用选项：<br>-p：创建多级目录<br><br>案例1：在home下创建一个目录dog<br><span class="hljs-built_in">mkdir</span> /home/dog<br><br>案例2：在home下创建多级目录 /home/animal/tiger <br><span class="hljs-built_in">mkdir</span> -p /home/animal/tiger<br><br>---------------------------------------------------------------------<br><br>基本语法：<span class="hljs-built_in">rmdir</span> [选项] 要删除的空目录路径<br>功能：删除一个空目录<br><br>案例:删除一个目录 /home/dog<br><span class="hljs-built_in">rmdir</span> /home/dog<br><br>注意：<br><span class="hljs-built_in">rmdir</span> 删除的是空目录，如果目录下有内容是无法删除的。<br>如果需要删除非空目录，需要使用命令：<span class="hljs-built_in">rm</span> -rf 要删除的目录<br>比如： 删除animal目录<br><span class="hljs-built_in">rm</span> -rf /home/animal<br>---------------------------------------------------------------------<br><br>基本语法：<span class="hljs-built_in">touch</span> 文件名称<br>功能：创建空文件<br><br>案例:：在/home 目录下，创建一个空文件 hello.txt<br><span class="hljs-built_in">touch</span> /home/hello.txt<br>或者当前目录是home：<span class="hljs-built_in">touch</span> hello.text<br><span class="hljs-built_in">touch</span>创建的是一个文件，而非一个目录，故不能对其进行目录的命令<br>---------------------------------------------------------------------<br><br>基本语法：<span class="hljs-built_in">cp</span> [选项] 被拷贝的文件 拷贝到哪个地方<br>功能：拷贝文件到指定目录<br>常用选项：<br>-r：递归复制整个文件夹<br><br>案例1：将 /home/hello.txt  拷贝到/home/bbb  目录下<br>若在根目录下操作：<br>先创建 bbb目录<br><span class="hljs-built_in">mkdir</span> /home/bbb<br>然后复制<br><span class="hljs-built_in">cp</span> /home/hello.txt /home/bbb<br><br>案例2：递归复制整个文件夹，比如将 /home/bbb 整个目录，拷贝到 /opt <br><span class="hljs-built_in">cp</span> -r /home/bbb /opt<br><br>注意：强制覆盖不提示的方法：\<span class="hljs-built_in">cp</span><br>\<span class="hljs-built_in">cp</span> -r /home/bbb /opt<br><br>---------------------------------------------------------------------<br><br>基本语法：<span class="hljs-built_in">rm</span>[选项] 要删除的文件或目录<br>功能：移除文件或目录<br>常用选项：<br>-r：递归删除整个文件夹<br>-f：强制删除不提示<br><br>案例1：将 /home/hello.txt 删除 <br><span class="hljs-built_in">rm</span>/home/hello.txt<br><br>案例2：递归删除整个文件夹 /home/bbb ，并不提示<br><span class="hljs-built_in">rm</span> -rf /home/bbb <br><br>注意：强制删除不提示的方法：带上 -f 参数即可<br>---------------------------------------------------------------------<br><br>功能：移动文件与目录或重命名<br>基本语法：<br><span class="hljs-built_in">mv</span>原文件名 新文件名      (功能描述：重命名)<br>如果就文件和新文件在同一个目录，即为更改文件名<br><span class="hljs-built_in">mv</span>  被移动的文件 移动到哪   (功能描述：移动文件)<br><br>案例 1: 将 /home/cat.txt 文件 重新命名为 pig.txt<br>[root@hspEdu01 ~]<span class="hljs-comment"># cd /home</span><br>[root@hspEdu01 home]<span class="hljs-comment"># touch cat.txt</span><br>[root@hspEdu01 home]<span class="hljs-comment"># ls</span><br>cat.txt  jack  king  milan  zwj<br>[root@hspEdu01 home]<span class="hljs-comment"># mv cat.txt pig.txt</span><br>[root@hspEdu01 home]<span class="hljs-comment"># ls</span><br>jack  king  milan  pig.txt  zwj<br><br>案例 2:将 /home/pig.txt文件 移动到 /root 目录下<br>[root@hspEdu01 home]<span class="hljs-comment"># mv pig.txt /root</span><br>[root@hspEdu01 home]<span class="hljs-comment"># ls</span><br>jack  king  milan  zwj<br>[root@hspEdu01 home]<span class="hljs-comment"># cd /root</span><br>[root@hspEdu01 ~]<span class="hljs-comment"># ls</span><br>Hello.java  pig.txt <br><br>移动并重名：<span class="hljs-built_in">mv</span> pig.txt /root/cow.txt<br><br>案例 3: 移动整个目录,比如将 /opt/bbb  移动到 /home 下<br> <span class="hljs-built_in">mv</span> /opt/bbb /home/<br> 移动整个目录，移动到/home下并改名为aaa<br> <span class="hljs-built_in">mv</span> /opt/bbb /home/aaa<br><br>---------------------------------------------------------------------<br>前面学过一个查看：vim<br><span class="hljs-built_in">cat</span>也可以查看，<span class="hljs-built_in">cat</span>只能查看不能修改，<span class="hljs-built_in">cat</span>更安全。<br><br>基本语法：<span class="hljs-built_in">cat</span>[选项] 要查看的文件<br>功能：查看文件内容<br>常用选项：<br>-n：显示行号<br><br>案例1：查看 /etc/profile 文件内容，并显示行号。<br><span class="hljs-built_in">cat</span>-n /etc/profile <br>注意：<br><span class="hljs-built_in">cat</span> 只能浏览文件，而不能修改文件；为了浏览方便再加上管道命令 | more <br>管道命令：把前面的结果再交给下一个指令进行处理。<br>语法：| 其他指令<br><br><span class="hljs-built_in">cat</span>-n /etc/profile | more <br>意思：先执行<span class="hljs-built_in">cat</span> -n /etc/profile 然后，按回车键输出一行，按空格翻页等。<br><br>---------------------------------------------------------------------<br><br>基本语法：more 要查看的文件<br>功能：<br>more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。<br>more 指令中内置了若干快捷键(交互的指令)，详见操作说明：<br>例如：<br>查看前两行内容<br>more -2 mydata.txt<br>从第二行开始看<br>more +2 mydata.txt<br></code></pre></td></tr></table></figure><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>Enter</td><td>向下翻一行</td></tr><tr><td>q</td><td>立刻离开more，不在显示该文件内容</td></tr><tr><td>Ctrl+F</td><td>向下滚动一屏</td></tr><tr><td>Ctrl+B</td><td>返回上一屏</td></tr><tr><td>&#x3D;</td><td>输出当前行的行号</td></tr><tr><td>：f</td><td>输出文件名和当前行的行号</td></tr></tbody></table><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cmake">基本语法：<span class="hljs-keyword">less</span> 要查看的文件<br>功能：<br><span class="hljs-keyword">less</span> 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。<br><span class="hljs-keyword">less</span> 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。<br><br>有一个文件是<span class="hljs-number">100</span>M，用vim查看会将其全部加载再显示出来，这样会很慢。<br>使用<span class="hljs-keyword">less</span>，会先加载一部分显示出来，再根据指令显示剩下的，这样更快。<br><br>所以要查找一些大的文件，建议用<span class="hljs-keyword">less</span>。<br><br>案例: 采用 <span class="hljs-keyword">less</span> 查看一个大文件文件 /opt/杂文.txt<br>首先使用xftp将杂文.txt传输到opt下<br>然后输入指令：<span class="hljs-keyword">less</span> /opt/杂文.txt  <br><br>下面操作中：<br>想要找某个字或词<br>输入：/要找的字或词    然后按n向下找  按N向上找<br>操作说明：<br></code></pre></td></tr></table></figure><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>pagedown</td><td>向下翻一页</td></tr><tr><td>pageup</td><td>向上翻一页</td></tr><tr><td>&#x2F;字串</td><td>向下搜寻[字串]的功能；n：向下查找；N：向上查找</td></tr><tr><td>?字串</td><td>向上搜寻[字串]的功能；n：向下查找；N：向上查找</td></tr><tr><td>q</td><td>离开less这个程序</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs bash">基本语法：<span class="hljs-built_in">echo</span> [选项][输出内容]<br>功能：输出内容到控制台<br><br>案例: 使用 <span class="hljs-built_in">echo</span>  指令输出环境变量<br>比如输出 <span class="hljs-variable">$PATH</span> <span class="hljs-variable">$HOSTNAME</span><br>输入：<span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOSTNAME</span> (环境变量一般加$)<br><br>案例: 使用 <span class="hljs-built_in">echo</span> 指令输出 hello,world!<br>输入：<span class="hljs-built_in">echo</span> hello,world!<br> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello,world!&quot;</span>  加不加引号都可以<br>---------------------------------------------------------------------<br><br>功能：<span class="hljs-built_in">head</span> 用于显示文件的开头部分内容，默认情况下 <span class="hljs-built_in">head</span> 指令显示文件的前 10 行内容。<br>基本语法：<br><span class="hljs-built_in">head</span>  文件    (功能描述：查看文件头 10 行内容)<br><span class="hljs-built_in">head</span> -n 5 文件(功能描述：查看文件头 5 行内容，5 可以是任意行数)<br><br>案例: 查看/etc/profile 的前面 5 行代码<br><span class="hljs-built_in">head</span> -n 5 /etc/profile<br><br>---------------------------------------------------------------------<br><br>功能：<span class="hljs-built_in">tail</span> 用于输出文件中尾部的内容，默认情况下 <span class="hljs-built_in">tail</span> 指令显示文件的前 10 行内容。<br>基本语法：<br><span class="hljs-built_in">tail</span> 文件    （功能描述：查看文件尾 10 行内容）<br><span class="hljs-built_in">tail</span> -n 5 文件（功能描述：查看文件尾 5 行内容，5 可以是任意行数）<br><span class="hljs-built_in">tail</span> -f文件    （功能描述：实时追踪该文档的所有更新，只要该文件改动了什么内容就可实时看到）(例如一直查看output.log)<br><span class="hljs-built_in">tail</span> -f output.log<br><br>---------------------------------------------------------------------<br><br>&gt;指令和&gt;&gt;指令：<br>&gt; 输出重定向(覆盖)<br>    &gt;&gt; 追加<br>基本语法：<br><span class="hljs-built_in">ls</span> -l &gt;文件1         (功能描述：将列表的内容写入文件1中(覆盖写))<br><span class="hljs-built_in">ls</span> -al &gt;&gt;文件1        (功能描述：将列表的内容追加到文件1的末尾)<br><span class="hljs-built_in">cat</span> 文件 1 &gt; 文件 2  (功能描述：将文件 1 的内容覆盖到文件 2)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;内容&quot;</span>&gt;&gt; 文件1     (将内容追加到文件1的末尾)<br><br>案例 1: 将 /home 目录下的文件列表 写入到 /home/info.txt 中,覆盖写入。<br><span class="hljs-built_in">ls</span> -l /home &gt; /home/info.txt[如果 info.txt 没有，则会自动创建] <br><br>案例 2: 将当前日历信息 追加到/home/mycal 文件中<br>cal &gt;&gt; /home/mycal<br><br>---------------------------------------------------------------------<br><br>功能：给原文件创建一个软链接<br> 软链接也称为符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径<br>基本语法：<br><span class="hljs-built_in">ln</span> -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）<br><span class="hljs-built_in">ln</span>是<span class="hljs-built_in">link</span><br><br>案例1：在/home 目录下创建一个软连接 myroot，连接到 /root 目录<br>(这样 切换到myroot 其实就是切换到root)<br><span class="hljs-built_in">ln</span> -s /root/home/myroot<br><br>案例2: 删除软连接 myroot <br><span class="hljs-built_in">rm</span>/home/myroot<br><br>当我们使用 <span class="hljs-built_in">pwd</span> 指令查看目录时，仍然看到的是软链接所在目录。<br><br>---------------------------------------------------------------------<br><br>功能：查看已经执行过历史命令,也可以执行历史指令<br>基本语法：<br><span class="hljs-built_in">history</span> （功能描述：查看已经执行过历史命令）<br>可以看其他登录的用户做了什么操作。<br><br>案例 1: 显示所有的历史命令<br><span class="hljs-built_in">history</span><br>案例 2: 显示最近使用过的 10 个指令。<br><span class="hljs-built_in">history</span> 10<br>案例 3：执行历史编号为 5 的指令<br>!5<br></code></pre></td></tr></table></figure><h3 id="5-5关于时间日期的指令"><a href="#5-5关于时间日期的指令" class="headerlink" title="5.5关于时间日期的指令"></a>5.5关于时间日期的指令</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs perl">date指令：<br><span class="hljs-number">1</span>.显示当前日期<br>基本语法：<br>date  （功能描述：显示当前时间）<br>date +%Y  （功能描述：显示当前年份）<br>date +%m  （功能描述：显示当前月份）<br>date +%d  （功能描述：显示当前是哪一天）<br>date <span class="hljs-string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span>（功能描述：显示年月日时分秒）<br><br>Y year<br>m month<br>d day<br>H hour<br>M minute<br>S second<br><br>案例 <span class="hljs-number">1</span>: 显示当前时间信息<br>date<br>案例 <span class="hljs-number">2</span>: 显示当前时间年月日<br>date <span class="hljs-string">&quot;+%Y-%m-%d&quot;</span><br>案例 <span class="hljs-number">3</span>: 显示当前时间年月日时分秒<br>date <span class="hljs-string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span><br>案例 <span class="hljs-number">4</span>：显示某个文件的修改时间<br>date -r info.txt<br><br><span class="hljs-number">2</span>.设置日期<br>基本语法：<br>date -s字符串时间<br><br>案例 <span class="hljs-number">1</span>: 设置系统当前时间<br>date -s <span class="hljs-string">&quot;2020-11-03 20:02:10&quot;</span><br><br><br>cal指令：<br>查看日历指令 cal<br><br>基本语法：<br>cal [选项]（功能描述：不加选项，显示本月日历）<br><br>案例 <span class="hljs-number">1</span>: 显示当前日历 <br>cal<br>案例 <span class="hljs-number">2</span>: 显示 <span class="hljs-number">2020</span> 年日历 <br>cal <span class="hljs-number">2020</span><br></code></pre></td></tr></table></figure><h3 id="5-6关于搜索查找有关的指令"><a href="#5-6关于搜索查找有关的指令" class="headerlink" title="5.6关于搜索查找有关的指令"></a>5.6关于搜索查找有关的指令</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> 指令<br>从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。<br>    <br>    基本语法：<br><span class="hljs-built_in">find</span> [搜索范围] [选项]<br><br>选项说明：<br></code></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name&lt;查询方式&gt;</td><td>按照指定的文件名查找模式查找文件</td></tr><tr><td>-user&lt;用户名&gt;</td><td>查找属于指定用户名所有的文件</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定的文件大小查找文件</td></tr></tbody></table><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs gradle">案例 <span class="hljs-number">1</span>: 按文件名：根据名称查找 /home 目录下的 hello.txt 文件<br><span class="hljs-keyword">find</span> /home -name hello.txt<br>如果当前在home目录下,则可以写为<br><span class="hljs-keyword">find</span> -name hello.txt<br>如果不指定查找目录即为当前目录<br><br>案例 <span class="hljs-number">2</span>：按拥有者：查找 /opt 目录下，用户名称为 nobody 的文件<br><span class="hljs-keyword">find</span> /opt -user nobody<br><br>案例 <span class="hljs-number">3</span>：查找整个 linux 系统下大于 <span class="hljs-number">200</span>M 的文件<br>+n 大于 -n 小于 n 等于<br>单位有 k,M,G <br><span class="hljs-keyword">find</span> / -<span class="hljs-keyword">size</span> +<span class="hljs-number">200</span>M<br><br>[root@hspEdu01 opt]# <span class="hljs-keyword">find</span> / -<span class="hljs-keyword">size</span> +<span class="hljs-number">200</span>M<br><span class="hljs-regexp">/proc/</span>kcore<br><span class="hljs-keyword">find</span>: ‘<span class="hljs-regexp">/proc/</span><span class="hljs-number">12775</span><span class="hljs-regexp">/task/</span><span class="hljs-number">12775</span><span class="hljs-regexp">/fd/</span><span class="hljs-number">5</span>’: 没有那个文件或目录<br><span class="hljs-keyword">find</span>: ‘<span class="hljs-regexp">/proc/</span><span class="hljs-number">12775</span><span class="hljs-regexp">/task/</span><span class="hljs-number">12775</span><span class="hljs-regexp">/fdinfo/</span><span class="hljs-number">5</span>’: 没有那个文件或目录<br><span class="hljs-keyword">find</span>: ‘<span class="hljs-regexp">/proc/</span><span class="hljs-number">12775</span><span class="hljs-regexp">/fd/</span><span class="hljs-number">6</span>’: 没有那个文件或目录<br><span class="hljs-keyword">find</span>: ‘<span class="hljs-regexp">/proc/</span><span class="hljs-number">12775</span><span class="hljs-regexp">/fdinfo/</span><span class="hljs-number">6</span>’: 没有那个文件或目录<br><span class="hljs-regexp">/run/m</span>edia<span class="hljs-regexp">/root/</span>CentOS <span class="hljs-number">7</span> x86_64<span class="hljs-regexp">/LiveOS/</span>squashfs.img (这个文件大于<span class="hljs-number">200</span>M)<br>[root@hspEdu01 opt]# cd <span class="hljs-regexp">/run/m</span>edia<span class="hljs-regexp">/root/</span>CentOS\ <span class="hljs-number">7</span>\ x86_64<span class="hljs-regexp">/LiveOS/</span><br>[root@hspEdu01 LiveOS]# ls<br>squashfs.img  TRANS.TBL<br>[root@hspEdu01 LiveOS]# ls -l<br>总用量 <span class="hljs-number">442741</span><br>-rw-r--r--. <span class="hljs-number">1</span> root root <span class="hljs-number">453365760</span> <span class="hljs-number">11</span>月 <span class="hljs-number">26</span> <span class="hljs-number">2018</span> squashfs.img<br>-r--r--r--. <span class="hljs-number">1</span> root root       <span class="hljs-number">224</span> <span class="hljs-number">11</span>月 <span class="hljs-number">26</span> <span class="hljs-number">2018</span> TRANS.TBL<br>[root@hspEdu01 LiveOS]# ls -lh  (上面的总用量大小看不懂，加上h human 能看懂的内容)<br>总用量 <span class="hljs-number">433</span>M<br>-rw-r--r--. <span class="hljs-number">1</span> root root <span class="hljs-number">433</span>M <span class="hljs-number">11</span>月 <span class="hljs-number">26</span> <span class="hljs-number">2018</span> squashfs.img<br>-r--r--r--. <span class="hljs-number">1</span> root root  <span class="hljs-number">224</span> <span class="hljs-number">11</span>月 <span class="hljs-number">26</span> <span class="hljs-number">2018</span> TRANS.TBL<br><br><br><br><br>locate 指令<br>可以快速定位文件路径。<br>利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给定的文件。<br>Locate 指令无需遍历整个文件系统，查询速度较快。<br>为了保证查询结果的准确度，管理员必须定期更新 locate 时刻<br><br>基本语法:<br>locate 搜索文件<br><br>注意：<br>由于 locate 指令基于数据库进行查询，<br>所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。<br><br>案例 <span class="hljs-number">1</span>: 请使用 locate 指令快速定位 hello.txt 文件所在目录<br>updatedb<br>locate hello.txt<br><br><br><br><br>which 指令<br>可以查看某个指令在哪个目录下<br>案例：ls 指令在哪个目录<br>which ls<br><br><br><br><br><span class="hljs-keyword">grep</span> 指令和 管道符号 |  <br><span class="hljs-keyword">grep</span>指令往往和管道符号 | 结合使用<br><span class="hljs-keyword">grep</span>：过滤查找<br>管道符：“|”<br>表示将前一个命令的处理结果输出传递给后面的命令处理。<br>比如：先 cat a.txt，然后又想看a.txt文件中有没有hello这个词<br>那么就 cat a.txt | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;hello&quot;</span> ---&gt;先找到a.txt，然后再在a.txt中找hello<br><br>基本语法：<br><span class="hljs-keyword">grep</span> [选项] 查找内容 源文件<br><br>常用选项：<br>-n  显示匹配行及行号<br>-i   忽略字母大小写<br><br>案例 <span class="hljs-number">1</span>: 请在 hello.txt 文件中，查找<span class="hljs-string">&quot;yes&quot;</span>所在行，并且显示行号<br>写法 <span class="hljs-number">1</span>:  cat <span class="hljs-regexp">/home/</span>hello.txt| <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;yes&quot;</span>  引号写不写都行<br>cat <span class="hljs-regexp">/home/</span>hello.txt| <span class="hljs-keyword">grep</span> -n <span class="hljs-string">&quot;yes&quot;</span>   显示行号    <br>写法 <span class="hljs-number">2</span>:  <span class="hljs-keyword">grep</span> -n <span class="hljs-string">&quot;yes&quot;</span> <span class="hljs-regexp">/home/</span>hello.txt<br></code></pre></td></tr></table></figure><h3 id="5-7关于压缩和解压的指令"><a href="#5-7关于压缩和解压的指令" class="headerlink" title="5.7关于压缩和解压的指令"></a>5.7关于压缩和解压的指令</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gzip/gunzip 指令<br>gzip    用于压缩文件<br>gunzip  用于解压的<br>    <br>    基本语法：<br>gzip 文件  （功能描述：压缩文件，只能将文件压缩为*<span class="hljs-selector-class">.gz</span> 文件）<br>gunzip 文件<span class="hljs-selector-class">.gz</span> （功能描述：解压缩文件命令）<br><br><br>案例 <span class="hljs-number">1</span>: gzip 压缩，将 /home 下的 hello<span class="hljs-selector-class">.txt</span> 文件进行压缩<br>gzip /home/hello<span class="hljs-selector-class">.txt</span><br><br>案例 <span class="hljs-number">2</span>: gunzip 解缩，将 /home 下的 hello<span class="hljs-selector-class">.txt</span><span class="hljs-selector-class">.gz</span> 文件进行解压<br>gunzip /home/hello<span class="hljs-selector-class">.txt</span><span class="hljs-selector-class">.gz</span><br><br><br><br><br>zip/unzip 指令<br>zip 用于压缩文件<br>unzip 用于解压的 <br>（这个在项目打包发布中很有用的）<br><br>基本语法：<br>zip<span class="hljs-selector-attr">[选项]</span> XXX<span class="hljs-selector-class">.zip</span> 将要压缩的内容    （功能描述：压缩文件和目录的命令）<br>unzip <span class="hljs-selector-attr">[选项]</span> XXX<span class="hljs-selector-class">.zip</span>              （功能描述：解压文件）<br>    <br>    zip 常用选项<br>-r：递归压缩，即压缩目录<br><br>unzip 的常用选项<br>-d&lt;目录&gt; ：指定解压后文件的存放目录<br><br><br>案例 <span class="hljs-number">1</span>:将 /home 下的所有文件/文件夹压缩成 myhome<span class="hljs-selector-class">.zip</span><br>zip -r myhome<span class="hljs-selector-class">.zip</span> /home/<span class="hljs-selector-attr">[将 home 目录及其包含的文件和子文件夹都压缩]</span> <br>zip -r 压缩后的文件名 需要压缩的目录<br><br>案例 <span class="hljs-number">2</span>:将 myhome<span class="hljs-selector-class">.zip</span> 解压到 /opt/tmp 目录下<br>mkdir /opt/tmp<br>unzip -d /opt/tmp /home/myhome<span class="hljs-selector-class">.zip</span><br>unzip -d 解压到 需要解压的文件<br><br><br><br><br>tar 指令<br>tar 指令是打包指令，最后打包后的文件是 <span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> 的文件。<br>把一个或者多个文件（夹）用压缩软件进行压缩的过程，一般可称之为打包。<br><br>tar指令可以压缩也可以解压。<br>根据选项来 压缩还是解压。<br><br>基本语法：<br>tar<span class="hljs-selector-attr">[选项]</span> XXX<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> 打包的内容  (功能描述：打包目录，压缩后的文件格式<span class="hljs-selector-class">.tar</span>.gz)<br><br>选项说明：<br></code></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包.tar文件</td></tr></tbody></table><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">案例 <span class="hljs-number">1</span>:压缩多个文件，将 /home/pig<span class="hljs-selector-class">.txt</span> 和 /home/cat<span class="hljs-selector-class">.txt</span> 压缩成 pc<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> <br>tar -zcvf pc<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> /home/pig<span class="hljs-selector-class">.txt</span> /home/cat<span class="hljs-selector-class">.txt</span><br>使用了选项：-z -c -v -f<br>多个文件就 空格直接写在后面就好了<br>模板：<br>tar -zcvf file_name<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> 打包的文件<span class="hljs-number">1</span> 打包的文件<span class="hljs-number">2</span> ···<br><br>案例 <span class="hljs-number">2</span>:将 /home 的文件夹压缩成 myhome<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> <br>tar -zcvf myhome<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> /home/<br>模板：<br>tar -zcvf file_name<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> 打包的目录或文件夹<br><br><br>案例 <span class="hljs-number">3</span>:将 pc<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> 解压到当前目录<br>tar -zxvf pc<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span><br><br>案例 <span class="hljs-number">4</span>:将 myhome<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> 解压到 /opt/tmp2 目录下<br>(<span class="hljs-number">1</span>)mkdir /opt/tmp2 <br>(<span class="hljs-number">2</span>) tar -zxvf /home/myhome<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> -C /opt/tmp2<br>注意：-C 后写要解压到的位置<br></code></pre></td></tr></table></figure><h2 id="六、Linux-实操篇-组管理和权限管理"><a href="#六、Linux-实操篇-组管理和权限管理" class="headerlink" title="六、Linux 实操篇-组管理和权限管理"></a>六、Linux 实操篇-组管理和权限管理</h2><h3 id="10-1Linux-组基本介绍"><a href="#10-1Linux-组基本介绍" class="headerlink" title="10.1Linux 组基本介绍"></a>10.1Linux 组基本介绍</h3><p>蓝色代表目录，绿色代表普通文件，红色代表压缩文件<br>“ls -al”命令用于显示一个目录中文件和文件夹的详细信息。下面是该命令显示的每一列的解释：</p><ol><li><strong>权限</strong>：第一列表示文件或文件夹的权限。它显示文件（-）或文件夹（d），后跟所有者、组和其他用户的三组权限。每组由三个字符组成：读取（r）、写入（w）和执行（x）。例如，”-rw-r–r–”表示一个文件，所有者具有读取和写入权限，而组和其他用户只有读取权限。</li><li><strong>链接数</strong>：第二列显示文件或文件夹的硬链接数。硬链接是对同一个文件或文件夹的引用。</li><li><strong>所有者</strong>：第三列显示文件或文件夹的所有者。</li><li><strong>组</strong>：第四列显示与文件或文件夹关联的组。</li><li><strong>大小</strong>：第五列表示文件的大小（以字节为单位）。对于文件夹，此列通常显示文件夹元数据所占用的空间大小。</li><li><strong>最后修改时间</strong>：第六列显示文件或文件夹的最后修改日期和时间。</li><li><strong>名称</strong>：第七列表示文件或文件夹的名称。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">在 linux 中的每个用户必须属于一个组，不能独立于组外。<br>在 linux 中每个文件都有所有者、所在组、其它组的概念。<br><br>1)所有者<br>2)所在组<br>3)其它组<br>4)改变用户所在的组<br></code></pre></td></tr></table></figure><h3 id="10-2文件-x2F-目录的所有者"><a href="#10-2文件-x2F-目录的所有者" class="headerlink" title="10.2文件&#x2F;目录的所有者"></a>10.2文件&#x2F;目录的所有者</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs tap">一般为文件的创建者，谁创建了该文件，就自然的成为该文件的所有者。<br>但是所有者也可以更改。<br><br>1.查看文件/目录的所有者(在/home下才能看到)<br>指令：ls –ahl<br>-ahl是三个选项<br>-h human 让输出的结果方便人看(文件的大小容易看)<br><br>drwxr-xr-x. <span class="hljs-number"> 6 </span>root root   4.0K 2月 <span class="hljs-number"> 23 </span>13:59 .<br>dr-xr-xr-x.<span class="hljs-number"> 18 </span>root root   4.0K 2月 <span class="hljs-number"> 20 </span>16:45 ..<br>-rw-r--r--. <span class="hljs-number"> 1 </span>root root    <span class="hljs-number"> 24 </span>2月 <span class="hljs-number"> 22 </span>21:59 hello.txt<br>...<br>第三列就是文件的所有者<br><br><br><br>2.修改文件/目录所有者指令：chown 新所有者 文件名<br>案例：<br>要求：使用 root 创建一个文件 apple.txt ，然后将其所有者修改成 tom<br>  chown tom apple.txt<br><br></code></pre></td></tr></table></figure><h3 id="10-3组的创建"><a href="#10-3组的创建" class="headerlink" title="10.3组的创建"></a>10.3组的创建</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">基本指令:<br><span class="hljs-code">groupadd 组名</span><br><span class="hljs-code"></span><br>案例：<br>创建一个组 monster <br><span class="hljs-code">groupadd monster</span><br><span class="hljs-code"></span><br>创建一个用户 fox ，并放入到monster 组中<br><span class="hljs-code">useradd -g monster fox</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h3 id="10-4文件-x2F-目录的所在组"><a href="#10-4文件-x2F-目录的所在组" class="headerlink" title="10.4文件&#x2F;目录的所在组"></a>10.4文件&#x2F;目录的所在组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash">当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组(默认)。<br><br><br>查看文件/目录所在组<br>指令:<br><span class="hljs-built_in">ls</span> –ahl  或者ll<br><br>ll并不是linux下一个基本的命令，它实际上是<span class="hljs-built_in">ls</span> -l的一个别名。<br>Ubuntu默认不支持命令ll，必须用 <span class="hljs-built_in">ls</span> -l，这样使用起来不是很方便。<br><br>案例：使用 fox 来创建一个文件，看看该文件属于哪个组?<br>使用fox创建一个文件：<br>su fox<br>然后<span class="hljs-built_in">touch</span> ok.txt<br>然后ll<br><br>-rw-r--r--. 1 fox monster 0 11 月 5 12:50 ok.txt<br>第三列：文件的所有者(谁创建了这个文件，就是这个文件的所有者)<br>第四列：文件的所在组(某个用户创建了一个文件，该文件所在组=该用户所在组)<br><br><br>注意：/etc/group下存放着所有的组<br>使用指令：<span class="hljs-built_in">cat</span> /etc/group 可以查看所有的组<br><br>比如查看有没有mojiao这个组<br>可以使用管道命令和grep过滤<br><span class="hljs-built_in">cat</span> /etc/group | grep mojiao<br>当一个文件很大，想找某个关键词就可以这个过滤！<br><br><br><br><br>修改文件/目录所在的组<br>指令：<br><span class="hljs-built_in">chgrp</span> 组名 文件名<br><br>案例：使用 root 用户创建文件 orange.txt ,看看当前这个文件属于哪个组，<br> 然后将这个文件所在组，修改到 fruit 组。<br><br>groupadd fruit<br><span class="hljs-built_in">touch</span> orange.txt<br>看看当前这个文件属于哪个组 -&gt; root 组<br><span class="hljs-built_in">chgrp</span> fruit orange.txt<br><br></code></pre></td></tr></table></figure><h3 id="10-5其它组"><a href="#10-5其它组" class="headerlink" title="10.5其它组"></a>10.5其它组</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">除文件的所有者和所在组的用户外，系统的其它用户都是该文件的其它组<br></code></pre></td></tr></table></figure><h3 id="10-6改变用户所在的组"><a href="#10-6改变用户所在的组" class="headerlink" title="10.6改变用户所在的组"></a>10.6改变用户所在的组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">在添加用户时，可以指定将该用户添加到哪个组中，同样的用 root 的管理权限可以改变某个用户所在的组。<br><br>改变用户所在组<br>usermod–g新组名用户名<br>usermod–d目录名用户名 (改变该用户登陆的初始目录)<br><br>特别说明：用户需要有进入到新目录的权限。<br><br>如何查看用户所在的组？<br><span class="hljs-built_in">id</span> 用户名  ---&gt;显示用户信息<br><br>案例：<br>将 zwj 这个用户从原来所在组，修改到 wudang 组<br>先查看zwj在哪个组：<span class="hljs-built_in">id</span> zwj<br>然后查看有没有wudang这个组：<span class="hljs-built_in">cat</span> /etc/group | grep wudang<br>修改：usermod -g wudang zwj<br></code></pre></td></tr></table></figure><h3 id="10-7权限基本介绍"><a href="#10-7权限基本介绍" class="headerlink" title="10.7权限基本介绍"></a>10.7权限基本介绍</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> -l 中显示的内容如下：<br>-rwxrw-r-- 1 root root 1213 Feb 2 09<span class="hljs-function">:39</span> abc<br>第一列共10位<br><br>0-9 位说明：<br>第 0 位确定文件类型<span class="hljs-params">(d, - , l , c , b)</span><br>d 是目录，相当于 windows 的文件夹<br>- 代表是普通文件<span class="hljs-params">(.txt)</span><br>l 是链接，相当于 windows 的快捷方式<br>c 是字符设备文件，比如鼠标，键盘    <span class="hljs-params">---</span>&gt; <span class="hljs-string">/dev/</span>目录下可以看到<br>b 是块设备，比如硬盘    <span class="hljs-params">---</span>&gt; <span class="hljs-string">/dev/</span>目录下可以看到<br><br>第 1-3 位确定 该文件的所有者 对该文件的 权限。<span class="hljs-params">---User</span><br>第 4-6 位确定 该文件所属的组和该组中的用户 对该文件的 权限。<span class="hljs-params">---Group</span> <br>第 7-9 位确定 其他用户<span class="hljs-params">(不是所有者，也不是同一组的其他用户)</span> 对该文件的权限 <span class="hljs-params">---Other</span><br><br></code></pre></td></tr></table></figure><h3 id="10-8rwx权限详解"><a href="#10-8rwx权限详解" class="headerlink" title="10.8rwx权限详解"></a>10.8rwx权限详解</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dts">权限有三种：<br>r 代表可读(read)<br>w 代表可写(write)<br>x 代表可执行(execute)<br><br>rwx 作用到文件：<br><span class="hljs-symbol">r:</span> 可以读取,查看<br><span class="hljs-symbol">w:</span> 可以修改,但是不代表可以删除该文件<br>   删除一个文件的前提条件是 对该文件所在的目录有写权限 ，才能删除该文件.<br><span class="hljs-symbol">x:</span> 可以被执行,前提是可执行文件<br><br>rwx 作用到目录：<br><span class="hljs-symbol">r:</span> 可以读取，可以用 ls 查看目录内容<br><span class="hljs-symbol">w:</span> 可以修改, 可以对目录进行 创建+删除+重命名目录<br><span class="hljs-symbol">x:</span> 可以进入该目录<br><br></code></pre></td></tr></table></figure><h3 id="10-9文件-x2F-目录权限实际案例"><a href="#10-9文件-x2F-目录权限实际案例" class="headerlink" title="10.9文件&#x2F;目录权限实际案例"></a>10.9文件&#x2F;目录权限实际案例</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs gcode">ls -l 中显示的内容如下：<br><span class="hljs-comment">(ll 是 ls -l的别名缩写)</span><br>-rwxrw-r-- <span class="hljs-number">1</span> root root <span class="hljs-number">1213</span> Feb <span class="hljs-number">2</span> <span class="hljs-number">09</span>:<span class="hljs-number">39</span> abc<br><br>第一列中 <span class="hljs-number">10</span> 个字符 确定不同用户能对文件干什么<span class="hljs-comment">(权限)</span>：<br>第一个字符代表文件类型： - l d c b<br>其余字符每 <span class="hljs-number">3</span> 个一组<span class="hljs-comment">(rwx)</span> 读<span class="hljs-comment">(r)</span> 写<span class="hljs-comment">(w)</span> 执行<span class="hljs-comment">(x)</span> <br><br>第一组 rwx：文件所有者的权限是 读、写和执行<br>第二组 rw-：与文件所有者同一组的用户的权限是 读、写但不能执行<br>第三组 r- ：不与文件拥所有者同组的其他用户 的权限是 读不能写和执行<br><br>也可以用数字表示对应的权限：<br>r=<span class="hljs-number">4</span>,w=<span class="hljs-number">2</span>,x=<span class="hljs-number">1</span>  <br>因此 rwx=<span class="hljs-number">4</span><span class="hljs-number">+2</span><span class="hljs-number">+1</span>=<span class="hljs-number">7</span> <br>数字可以进行组合<br><br>其它说明：<br>第二列：<span class="hljs-number">1</span>如果是普通文件，直接就是<span class="hljs-number">1</span>；<br>如果是目录，代表该目录下有多少内容<span class="hljs-comment">(即子目录数+文件数)</span><br><br>第三列：root该文件/目录的所有者<br>第四列：root该文件/目录的所在组<br>第五列：<span class="hljs-number">1213</span>文件大小<span class="hljs-comment">(这里是字节)</span><br>第六列：Feb <span class="hljs-number">2</span> <span class="hljs-number">09</span>:<span class="hljs-number">39</span>最后修改日期<br>第七列：abc文件名<br><br></code></pre></td></tr></table></figure><h3 id="10-10修改权限-chmod"><a href="#10-10修改权限-chmod" class="headerlink" title="10.10修改权限-chmod"></a>10.10修改权限-chmod</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs routeros">基本说明：<br>通过 chmod 指令，可以修改文件或者目录的权限。<br>如果目录没有x权限，则代表不能进入该文件夹<br>如果父目录没有x权限，即便父目录中的文件有可读权限，依然无法访问<br>如果父目录有x权限但是没有rw权限，而目录中的文件有rw权限，则便可以对目录中的文件进行修改<br><br>第一种方式：通过 + 、-、=  变更权限<br>u:所有者<br>g:所在组(同一个组的其他用户)<br>o:其他人(不同一个组的其他用户)<br>a:所有人(所有用户)(u、g、o 的总和)<br><br>chmod <span class="hljs-attribute">u</span>=rwx,g=rx,o=x文件/目录名  (该文件/目录的u的权限是rwx，g的权限是rx，o的权限是x)<br>chmodo+w文件/目录名  (该文件/目录的o的权限加上w)<br>chmoda-x文件/目录名  (取消该文件/目录的a的x权限)<br><br><br>案例演示：<br>1.给 abc 文件 的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。<br>chmod <span class="hljs-attribute">u</span>=rwx,g=rx,o=rx abc<br><br>2.给 abc 文件的所有者除去执行的权限，增加组写的权限<br>chmod u-x,g+w abc<br><br>3.给 abc 文件的所有用户添加读的权限<br>chmod a+r abc<br><br><br><br>注意：<br>可执行文件 图标   绿色<br>普通文件 图标    白色<br>目录/文件夹图标    蓝色<br>压缩文件图标    红色<br><br><br><br>第二种方式：通过数字变更权限<br>权限可以用数字代替：<span class="hljs-attribute">r</span>=4 <span class="hljs-attribute">w</span>=2 <span class="hljs-attribute">x</span>=1<br> <br>chmod <span class="hljs-attribute">u</span>=rwx,g=rx,o=x 文件/目录名<br>相当于 <br>chmod 751     文件/目录名<br><br><span class="hljs-attribute">rwx</span>=4+2+1=7<br><span class="hljs-attribute">rx</span>=4+1=5<br><span class="hljs-attribute">x</span>=1<br><br>案例演示<br>要求：将 /home/abc.txt 文件的权限修改成rwxr-xr-x,使用给数字的方式实现：<br>rwxr-xr-x：u-rwx <span class="hljs-attribute">g</span>=r-x <span class="hljs-attribute">o</span>=r-x<br>chmod 755 /home/abc.txt<br><br></code></pre></td></tr></table></figure><h3 id="10-11修改文件-x2F-目录的所有者-chown"><a href="#10-11修改文件-x2F-目录的所有者-chown" class="headerlink" title="10.11修改文件&#x2F;目录的所有者-chown"></a>10.11修改文件&#x2F;目录的所有者-chown</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">基本介绍<br>chownnewowner文件/目录(修改所有者)<br>chown newowner:newgroup文件/目录 (同时修改所有者和所在组)<br><br>选项：-R如果是目录 则使其下所有子文件或目录递归生效<br><br>案例演示<br><span class="hljs-number">1</span>.请将 <span class="hljs-regexp">/home/</span>abc.txt 文件的所有者修改成 tom<br>chown tom <span class="hljs-regexp">/home/</span>abc.txt<br><br><span class="hljs-number">2</span>.请将 <span class="hljs-regexp">/home/</span>test 目录下所有的文件和目录的所有者都修改成 tom <br>chown -R tom <span class="hljs-regexp">/home/</span>test<br><br>R:Recursive递归<br><br></code></pre></td></tr></table></figure><h3 id="10-12修改文件-x2F-目录的所在组-chgrp"><a href="#10-12修改文件-x2F-目录的所在组-chgrp" class="headerlink" title="10.12修改文件&#x2F;目录的所在组-chgrp"></a>10.12修改文件&#x2F;目录的所在组-chgrp</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">chgrp  newgroup  文件/目录(改变所在组)<br><br>案例演示:<br><span class="hljs-number">1</span>.请将 <span class="hljs-regexp">/home/</span>abc.txt 文件的所在组修改成 shaolin (少林) <br>groupadd shaolin<br>chgrp shaolin <span class="hljs-regexp">/home/</span>abc.txt<br><br><span class="hljs-number">2</span>.请将 <span class="hljs-regexp">/home/</span>test 目录下所有的文件和目录的所在组都修改成 shaolin(少林) <br>chgrp -R shaolin <span class="hljs-regexp">/home/</span>test<br><br></code></pre></td></tr></table></figure><h3 id="10-13最佳实践-警察和土匪游戏"><a href="#10-13最佳实践-警察和土匪游戏" class="headerlink" title="10.13最佳实践-警察和土匪游戏"></a>10.13最佳实践-警察和土匪游戏</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs bash">有两个组：police组，bandit组<br>有四个用户：jackie,jerry,xh,xq<br>jackie,jerry: 警察<br>xh,xq: 土匪<br><br>1.创建组<br>groupadd police<br>groupadd bandit<br>2.创建用户(直接放到对应组)<br>useradd -g police jackie<br>useradd -g police jerry<br>useradd -g bandit xh<br>useradd -g bandit xq<br>3.jackie 创建一个文件，自己可以读 r 写 w，本组人可以读，其它组没人任何权限<br>首先jackie登录，可以使用切换用户：su jackie ----&gt;这样不行，无法创建文件，权限不够<br><br>使用jackie登录，先设置密码123，然后退出系统用jackie登录：passwd jackie<br>然后创建文件：<span class="hljs-built_in">touch</span> jackie.txt <br>权限设置：<br>原权限：rw-r--r--<br><span class="hljs-built_in">chmod</span> o-r jackie.txt <br>修改后权限：rw-r-----<br><br>也可以直接使用数字方式：<span class="hljs-built_in">chmod</span> 640 jackie.txt<br><br>4.jackie 修改该文件，让其它组人可以读，本组人可以读写<br><span class="hljs-built_in">chmod</span> g+w o+r jackie.txt <br>或者<br><span class="hljs-built_in">chmod</span> 664 jackie.txt<br><br>改后权限：rw-rw-r--<br><br>5.xh投靠警察<br>由root执行这条指令<br>usermod -g police xh<br><br>6.测试xh和xq能不能对jackie.txt文件进行读写<br>分别使用xh和xq登录(首先对其设置密码123)<br><br>jackie.txt文件在jackie目录下<br>要想对jackie.txt文件进行操作，首先进入jackie目录<br>但是jackie目录权限是：rwx------<br>所以xh连jackie目录都进不去<br><br>解决办法：登录jackie，对jackie目录权限进行修改(也可以登录root进行修改)(必须都在home下才能执行这个修改权限命令)<br>登录<br><span class="hljs-built_in">cd</span> /home/<br>ll<br>得到jackie原目录权限：rwx------<br>修改权限：<span class="hljs-built_in">chmod</span> 770 jackie(权限中有x才能进入目录)<br>修改后jackie目录权限：rwxrwx---<br><br>这时xh就可以进入jackie目录，并对jackie.txt进行读写<br><br><br>结论：如果要对目录内的文件进行操作，首先要有对该目录有相应权限<br><br></code></pre></td></tr></table></figure><h3 id="10-14课后练习1"><a href="#10-14课后练习1" class="headerlink" title="10.14课后练习1"></a>10.14课后练习1</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">1.建立两个组（神仙<span class="hljs-params">(sx)</span>,妖怪<span class="hljs-params">(yg)</span>）<br>groupadd sx<br>groupadd yg<br>2.建立四个用户<span class="hljs-params">(唐僧,悟空，八戒，沙僧)</span><br>useradd ts<br>useradd wk<br>useradd bj<br>useradd ss<br>3.设置密码<span class="hljs-params">(都为123)</span><br>passwd ts<br>passwd wk<br>passwd bj<br>passwd ss<br>4.妖怪组：悟空，八戒；神仙组：唐僧，沙僧<br>usermod -g yg wk<br>usermod -g yg bj<br>usermod -g sx ts<br>usermod -g sx ss<br>5.用悟空建立一个文件 monkey.txt ，该文件要输出 i am a monkey<br>先使用悟空登录<br>vim monkey.txt<br>i am a monkey<br><span class="hljs-function">:wq</span><br>6.给八戒一个可以 r w 的权限<br>悟空和八戒是一组的<br>当前monkey.txt权限：-rw-r<span class="hljs-params">--r--</span><br>此时八戒只能r<br>命令：chmod g+w monkey.txt<br>现在monkey.txt权限：-rw-rw-r--<br><br>7.八戒修改 monkey.txt 加入一句话<span class="hljs-params">( i am a pig)</span><br>monkey.txt文件在wk目录下<br>八戒要修改monkey.txt文件就要先进入wk目录<br>但是此时wk目录权限：rwx<span class="hljs-params">------</span><br>八戒进不去wk目录<br>所以先修改wk目录权限：chmod g+r+w+x wk  <span class="hljs-params">(先把所以权限都给，在wk的home下写指令或root的home下写指令，因为目录在home下)</span><br>现在wk目录权限：rwxrwx<span class="hljs-params">---</span><br>这时八戒就能进入wk目录了<br><br>8.唐僧 沙僧 对该文件没有权限<br>唐僧和沙僧是其他组，进不去wk目录<br><br>9.把 沙僧 放入妖怪组<br>usermod -g yg ss<br><br>10.让沙僧修改该文件 monkey.txt, 加入一句话 <span class="hljs-params">(&quot;我是沙僧，我是妖怪!&quot;)</span>;<br>使用沙僧登录<br><span class="hljs-keyword">cd</span> <span class="hljs-string">/home/wk</span><br>viw monkey.txt<br><span class="hljs-string">...</span><br><span class="hljs-function">:wq</span><br><br><br>注意：<br>rwx权限对于 文件夹<span class="hljs-params">(目录)</span> 的细节讨论和测试!!!<br>x: 表示可以进入到该目录,比如 <span class="hljs-keyword">cd</span><br>r: 表示可以 <span class="hljs-keyword">ls</span> ,将目录的内容显示<br>w: 表示可以在该目录下删除或者创建文件<span class="hljs-params">(不代表：修改已有的文件)</span><br><br></code></pre></td></tr></table></figure><h3 id="10-15课后练习2"><a href="#10-15课后练习2" class="headerlink" title="10.15课后练习2"></a>10.15课后练习2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">1)用 root 登录，建立用户 mycentos,自己设定密码<br>2)用 mycentos 登录，在主目录下建立目录 <span class="hljs-built_in">test</span>/t11/t1<br>3)在 t1 中建立一个文本文件 aa,用 vi 编辑其内容为 <span class="hljs-built_in">ls</span>  –al<br>4)改变 aa 的权限为可执行文件[可以将当前日期追加到一个文件],运行该文件./aa<br>5)删除新建立的目录 <span class="hljs-built_in">test</span>/t11/t1<br>6)删除用户 mycentos 及其主目录中的内容<br>7)将 linux 设置成进入到图形界面的<br>8)重新启动 linux 或关机<br><br></code></pre></td></tr></table></figure><h2 id="七、Linux实操篇-定时任务调度"><a href="#七、Linux实操篇-定时任务调度" class="headerlink" title="七、Linux实操篇-定时任务调度"></a>七、Linux实操篇-定时任务调度</h2><h3 id="7-1-crond任务调度"><a href="#7-1-crond任务调度" class="headerlink" title="7.1 crond任务调度"></a>7.1 crond任务调度</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>.概述<br>任务调度：是指系统在某个时间执行特定的命令或程序。<br>crond---&gt;周期任务<br><br>任务调度分类：<br>(<span class="hljs-number">1</span>)系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等<br>(<span class="hljs-number">2</span>)个别用户工作：个别用户可能希望执行某些程序，比如对 mysql 数据库的备份。<br><br>示意图：<br><br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307040946819.png" alt="image-20230704094649102"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">2</span>.基本语法<br>crontab <span class="hljs-selector-attr">[选项]</span><br>功能：进行定时任务的设置<br><br><span class="hljs-number">3</span>.常用选项<br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307040947523.png" alt="image-20230704094730437"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">4</span>.快速入门<br>在<span class="hljs-regexp">/etc/</span>下有一个crontab文件，在这个文件中写入所有的定时任务<br><br>输入crontab -e  就会进入crontab文件<br>然后在文件中写入定时任务：*<span class="hljs-regexp">/1 * * * * ls –l/</span>etc<span class="hljs-regexp">/ &gt; /</span>tmp/to.txt<br>意思说每小时的每分钟执行 ls –l <span class="hljs-regexp">/etc/</span> &gt; <span class="hljs-regexp">/tmp/</span>to.txt 命令<br>最后保存退出<br><br><br>参数细节说明：<br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307040948096.png" alt="image-20230704094804003"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307040948666.png" alt="image-20230704094821573"></p><p>特定时间执行任务案例</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307040948564.png" alt="image-20230704094842459"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">5</span>.应用实例<br>案例 <span class="hljs-number">1</span>：每隔 <span class="hljs-number">1</span> 分钟，就将当前的日期信息，追加到 <span class="hljs-regexp">/tmp/my</span>date 文件中<br>crontab -e<br>*<span class="hljs-regexp">/1 * * * * date &gt;&gt; /</span>tmp/mydate<br><br><br>案例 <span class="hljs-number">2</span>：每隔 <span class="hljs-number">1</span> 分钟，将当前日期和日历都追加到 <span class="hljs-regexp">/home/my</span>cal 文件中<br>第一种方法：<br>crontab -e<br>在crontab文件中输入：<br>*<span class="hljs-regexp">/1 * * * * date &gt;&gt; /</span>home/mycal <br>*<span class="hljs-regexp">/1 * * * * cal &gt;&gt; /</span>home/mycal <br>保存退出<br><br>第二种方法：<br>将 date &gt;&gt; <span class="hljs-regexp">/home/my</span>cal 和  cal &gt;&gt; <span class="hljs-regexp">/home/my</span>cal 命令写在文件 <span class="hljs-regexp">/home/my</span>.sh中<br>就是将命令都写在shell脚本中，直接调用shell脚本<br><br>步骤：<br>vim <span class="hljs-regexp">/home/my</span>.sh<br>在my.sh中写入：<br>date &gt;&gt; <span class="hljs-regexp">/home/my</span>cal<br>cal &gt;&gt; <span class="hljs-regexp">/home/my</span>cal<br>:wq<br>给 my.sh 增加执行权限：chmod u+x <span class="hljs-regexp">/home/my</span>.sh (否则无法使用crontab命令)<br>crontab -e<br>在crontab中写入：*<span class="hljs-regexp">/1 * * * */</span>home/my.sh<br><br>注意：可以写脚本也可以不写脚本<br><br><br>案例 <span class="hljs-number">3</span>:每天凌晨 <span class="hljs-number">2</span>:<span class="hljs-number">00</span>  将 mysql 数据库 testdb 备份到文件中。<br>提示: 指令为 mysqldump -u root -p密码 数据库 &gt; <span class="hljs-regexp">/home/</span>db.bak<br>步骤(<span class="hljs-number">1</span>) crontab -e<br>步骤(<span class="hljs-number">2</span>) <span class="hljs-number">0</span> <span class="hljs-number">2</span> * * * mysqldump -u root -proot testdb &gt; <span class="hljs-regexp">/home/</span>db.bak<br><br><br><br><br><span class="hljs-number">6</span>. crond 相关指令<br>conrtab –r：终止任务调度。<br>crontab –l：列出当前有那些任务调度<br>service crond restart：重启任务调度<br><br></code></pre></td></tr></table></figure><h3 id="7-2-at定时任务"><a href="#7-2-at定时任务" class="headerlink" title="7.2 at定时任务"></a>7.2 at定时任务</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1.</span>基本介绍<br><span class="hljs-comment">(1)</span>at 命令是一次性定时计划任务，at 的守护进程 atd 会以后台模式运行，检查作业队列来运行；<br><span class="hljs-comment">(2)</span> 每个作业队列<span class="hljs-comment">(任务队列)</span>中都有作业<span class="hljs-comment">(作业里是指令/脚本)</span>；<br><span class="hljs-comment">(3)</span>默认情况下，atd 守护进程每 <span class="hljs-number">60</span> 秒检查作业队列；<br>有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业；<br>运行完这个作业<span class="hljs-comment">(任务)</span>之后，这个作业就不会再被执行了；<br><span class="hljs-comment">(4)</span>at 命令是一次性定时计划任务，执行完一个任务后不再执行此任务了；<br><span class="hljs-comment">(5)</span>在使用 at 命令的时候，一定要保证 atd 进程的启动，可以使用相关指令来查看<br>ps -ef| grep atd <span class="hljs-comment">//可以检测 atd 是否在运行</span><br>ps -ef ---&gt; 查看所有的进程<br><br>总结：at命令就是对某个定时任务只执行一次<br><br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307040951719.png" alt="image-20230704095107649"></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">2</span>. <span class="hljs-keyword">at</span> 命令格式<br><span class="hljs-keyword">at</span> [选项] [时间]<br>然后输入两次：Ctrl + D(结束 <span class="hljs-keyword">at</span> 命令的输入)<br><br><span class="hljs-number">3</span>. <span class="hljs-keyword">at</span> 命令选项：<br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307040951176.png" alt="image-20230704095124057"></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">4.</span> at 指定时间的方法：<br><br>(<span class="hljs-number">1</span>)接受在当天的 hh:mm（小时:分钟）式的时间指定。<br>假如该时间已过去，那么就放在第二天执行。 例如：<span class="hljs-number">04</span>:<span class="hljs-number">00</span><br>(<span class="hljs-number">2</span>)使用 midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午 <span class="hljs-number">4</span> 点）等比较模糊的词语来指定时间。<br>(<span class="hljs-number">3</span>)采用 <span class="hljs-number">12</span> 小时计时制，即在时间后面加上 AM（上午）或 PM（下午）来说明是上午还是下午。 <br>例如：<span class="hljs-number">12</span>pm<br>(<span class="hljs-number">4</span>)指定命令执行的具体日期，指定格式为 <span class="hljs-built_in">month</span> <span class="hljs-built_in">day</span>（月 日）或 mm/dd/yy（月/日/年）或 dd.mm.yy（日.月.年），指定的日期必须跟在指定时间的后面。 <br>例如：<span class="hljs-number">04</span>:<span class="hljs-number">00</span> <span class="hljs-number">2021</span><span class="hljs-number">-03</span><span class="hljs-number">-1</span> (小的时间写前面，大的时间写后面)<br>(<span class="hljs-number">5</span>)使用相对计时法。<br>指定格式为：<span class="hljs-built_in">now</span> + <span class="hljs-built_in">count</span> time-units<br><span class="hljs-built_in">now</span> 就是当前时间，time-units 是时间单位，这里能够是 minutes（分钟）、hours（小时）、days（天）、weeks（星期）。<br><span class="hljs-built_in">count</span> 是时间的数量，几天，几小时。 <br>例如：<span class="hljs-built_in">now</span> + <span class="hljs-number">5</span> minutes<br>(<span class="hljs-number">6</span>)直接使用 <span class="hljs-built_in">today</span>（今天）、tomorrow（明天）来指定完成命令的时间。<br><br><br><br><span class="hljs-number">5.</span>应用实例<br>案例 <span class="hljs-number">1</span>：<span class="hljs-number">2</span> 天后的下午 <span class="hljs-number">5</span> 点执行 /bin/ls /home<br>at <span class="hljs-number">5</span>pm + <span class="hljs-number">2</span> days<br>/bin/ls /home<br>两次ctrl+D<br><br>案例 <span class="hljs-number">2</span>：atq 命令来查看系统中没有执行的工作任务<br>直接输入atq 查询<br><br>案例 <span class="hljs-number">3</span>：明天<span class="hljs-number">17</span>点钟，输出时间到指定文件内 比如 /root/date100.<span class="hljs-built_in">log</span><br>at <span class="hljs-number">5</span>pm tomorrow<br><span class="hljs-built_in">date</span> &gt; <span class="hljs-regexp">/root/</span>date100.<span class="hljs-built_in">log</span><br>两次ctrl+D<br><br>案例 <span class="hljs-number">4</span>：<span class="hljs-number">2</span>分钟后，输出时间到指定文件内 比如 /root/date200.<span class="hljs-built_in">log</span><br>at <span class="hljs-built_in">now</span> + <span class="hljs-number">2</span> minutes<br><span class="hljs-built_in">date</span> &gt; <span class="hljs-regexp">/root/</span>date200.<span class="hljs-built_in">log</span><br>两次ctrl+D<br><br>案例 <span class="hljs-number">5</span>：删除已经设置的任务<br>atrm 任务编号<br>atrm <span class="hljs-number">4</span> <span class="hljs-comment">//表示将 job 队列，编号为 4 的 job 删除.</span><br><br>atq:<br><span class="hljs-number">2</span>Thu Feb <span class="hljs-number">24</span> <span class="hljs-number">09</span>:<span class="hljs-number">53</span>:<span class="hljs-number">00</span> <span class="hljs-number">2022</span> a root<br><span class="hljs-number">1</span>Fri Feb <span class="hljs-number">25</span> <span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">2022</span> a root<br>第一列就是编号<br><br><br>注意：也可以执行脚本<br>比如：<br>at <span class="hljs-built_in">now</span> +<span class="hljs-number">2</span> minutes<br>/root/my.sh  <br>但要有这个脚本，并且有执行权限x<br><br></code></pre></td></tr></table></figure><h2 id="八、Linux-实操篇-Linux-磁盘分区、挂载"><a href="#八、Linux-实操篇-Linux-磁盘分区、挂载" class="headerlink" title="八、Linux 实操篇-Linux 磁盘分区、挂载"></a>八、Linux 实操篇-Linux 磁盘分区、挂载</h2><h3 id="8-1-Linux-分区"><a href="#8-1-Linux-分区" class="headerlink" title="8.1 Linux 分区"></a>8.1 Linux 分区</h3><h4 id="8-1-1原理介绍"><a href="#8-1-1原理介绍" class="headerlink" title="8.1.1原理介绍"></a>8.1.1原理介绍</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) Linux 无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 <br>Linux 中每个分区都是用来组成整个文件系统的一部分。<br><br>(<span class="hljs-number">2</span>)Linux 采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。<br>这时要载入的一个分区将使它的存储空间在一个目录下获得。<br><br>(<span class="hljs-number">3</span>)图解：<br>硬盘上的一个分区 通过挂载mount机制 与文件系统中的某个目录联系起来<br>即分区挂载到目录<br>访问这个目录即访问这个分区<br>可以通过指令查看挂载情况，下面会说。<br><br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307040952057.png" alt="image-20230704095240952"></p><h4 id="8-1-2硬盘说明"><a href="#8-1-2硬盘说明" class="headerlink" title="8.1.2硬盘说明"></a>8.1.2硬盘说明</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(<span class="hljs-number">1</span>)Linux 硬盘主要分为：<br> IDE 硬盘和 <span class="hljs-keyword">SCSI </span>硬盘<br> 目前基本上是 <span class="hljs-keyword">SCSI </span>硬盘<br><br>(<span class="hljs-number">2</span>)对于 IDE 硬盘，驱动器标识符为“hdx~”<br>其中“hd”表明分区所在设备的类型，这里是指 IDE 硬盘<br><br>“x”为盘号<br>a 为基本盘 第一个硬盘<br><span class="hljs-keyword">b </span>为基本从属盘 第二个硬盘<br>c 为辅助主盘 第三个硬盘<br>d 为辅助从属盘 第四个硬盘<br><br>“~”代表分区<br>前四个分区用数字 <span class="hljs-number">1</span> 到 <span class="hljs-number">4</span> 表示，它们是主分区或扩展分区，从 <span class="hljs-number">5</span> 开始就是逻辑分区<br><br>例：hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区<br>     hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区<br>     <br>(<span class="hljs-number">3</span>)对于 <span class="hljs-keyword">SCSI </span>硬盘则标识为“sdx~”<br><span class="hljs-keyword">SCSI </span>硬盘是用“sd”来表示分区所在设备的类型的，其余则和 IDE 硬盘的表示方法一样<br><br></code></pre></td></tr></table></figure><h4 id="8-1-3查看所有设备挂载情况"><a href="#8-1-3查看所有设备挂载情况" class="headerlink" title="8.1.3查看所有设备挂载情况"></a>8.1.3查看所有设备挂载情况</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs subunit">命令 ：lsblk或者 lsblk -f<br><br>lsblk：list block devices <br><br>NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>sda      8:0    0   20G  0 disk <br>├─sda1   8:1    0    1G  0 part /boot<br>├─sda2   8:2    0    2G  0 part [SWAP]<br>└─sda3   8:3    0   17G  0 part /<br>sr0     11:0    1  4.3G  0 rom <br><br>sda1分区挂载到/boot目录<br>sda2分区挂载到swap目录<br>sda3分区挂载到根目录<br><br><br><br>lsblk -f (更加详细的显示)<br><br>NAME   FSTYPE  LABEL           UUID                                 MOUNTPOINT<br>sda                                                                 <br>├─sda1 ext4                    bd7b7249-b3fa<span class="hljs-string">-434</span>f-acfd<span class="hljs-string">-5127</span>a56c0673 /boot<br>├─sda2 swap                    4381675a<span class="hljs-string">-652</span>c<span class="hljs-string">-4</span>ffa<span class="hljs-string">-9</span>a9d-cb23d19be79b [SWAP]<br>└─sda3 ext4                    531c2867-a7e9<span class="hljs-string">-4</span>ae7<span class="hljs-string">-8</span>f79<span class="hljs-string">-4453</span>ceb76c5b /<br>sr0    iso9660 CentOS 7 x86_64 2018<span class="hljs-string">-11</span><span class="hljs-string">-25</span><span class="hljs-string">-23</span><span class="hljs-string">-54</span><span class="hljs-string">-16</span><span class="hljs-string">-00</span>    <br><br>第一列可以看到设备/硬盘分区情况<br>FSTYPE:文件系统类型<br>UUID:格式化之后，会给每一个分区分配一个 唯一的 不重复的 40位 的 字符串<br>MOUNTPOINT:挂载点<br><br></code></pre></td></tr></table></figure><h3 id="8-2挂载的经典案例"><a href="#8-2挂载的经典案例" class="headerlink" title="8.2挂载的经典案例"></a>8.2挂载的经典案例</h3><h4 id="8-2-1说明"><a href="#8-2-1说明" class="headerlink" title="8.2.1说明"></a>8.2.1说明</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">下面我们以增加一块硬盘为例来熟悉一下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念。<br></code></pre></td></tr></table></figure><h4 id="8-2-2如何增加一块硬盘"><a href="#8-2-2如何增加一块硬盘" class="headerlink" title="8.2.2如何增加一块硬盘"></a>8.2.2如何增加一块硬盘</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">1)虚拟机添加硬盘<br>2)分区<br>3)格式化<br>4)挂载<br>5)设置可以自动挂载<br><br></code></pre></td></tr></table></figure><h4 id="8-2-3虚拟机增加硬盘步骤-1-虚拟机添加硬盘"><a href="#8-2-3虚拟机增加硬盘步骤-1-虚拟机添加硬盘" class="headerlink" title="8.2.3虚拟机增加硬盘步骤 1-虚拟机添加硬盘"></a>8.2.3虚拟机增加硬盘步骤 1-虚拟机添加硬盘</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tap">在【虚拟机】菜单中选择【设置】<br>然后设备列表里添加硬盘<br>然后一路【下一步】<br>中间只有选择磁盘大小的地方需要修改，至到完成<br><br>使用命令lsblk发现没有新增的硬盘？<br>需要重启系统（才能识别）<br><br>NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>sda      8:0   <span class="hljs-number"> 0 </span>  20G <span class="hljs-number"> 0 </span>disk <br>├─sda1   8:1   <span class="hljs-number"> 0 </span>   1G <span class="hljs-number"> 0 </span>part /boot<br>├─sda2   8:2   <span class="hljs-number"> 0 </span>   2G <span class="hljs-number"> 0 </span>part [SWAP]<br>└─sda3   8:3   <span class="hljs-number"> 0 </span>  17G <span class="hljs-number"> 0 </span>part /<br>sdb      8:16  <span class="hljs-number"> 0 </span>   1G <span class="hljs-number"> 0 </span>disk <br>sr0     11:0   <span class="hljs-number"> 1 </span> 4.3G <span class="hljs-number"> 0 </span>rom  <br>新增硬盘sdb，还未分区。<br><br></code></pre></td></tr></table></figure><h4 id="8-2-4-虚拟机增加硬盘步骤-2-分区"><a href="#8-2-4-虚拟机增加硬盘步骤-2-分区" class="headerlink" title="8.2.4 虚拟机增加硬盘步骤 2-分区"></a>8.2.4 虚拟机增加硬盘步骤 2-分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs sql">对sdb进行分区：<br><br>分区命令：fdisk <span class="hljs-operator">/</span>dev<span class="hljs-operator">/</span>sdb   (dev目录下是一些设备)<br>步骤：<br>开始分区后输入 n  (新增分区)<br>然后选择 p     (分区类型为主分区)<br>两次回车<br>最后输入 w  (写入分区并退出)(若不保存并退出输入 q，即上面步骤出错了想重来就可以输入q)<br><br>说明：<br>m显示命令列表           <br>p显示磁盘分区 (同 fdisk –l) <br>n新增分区<br>d删除分区<br>w写入并退出<br><br><br>命令(输入 m 获取帮助)：m<br>命令操作<br>   a   toggle a bootable flag<br>   b   edit bsd disklabel<br>   c   toggle the dos compatibility flag<br>   d   <span class="hljs-keyword">delete</span> a <span class="hljs-keyword">partition</span><br>   g   <span class="hljs-keyword">create</span> a <span class="hljs-keyword">new</span> <span class="hljs-keyword">empty</span> GPT <span class="hljs-keyword">partition</span> <span class="hljs-keyword">table</span><br>   G   <span class="hljs-keyword">create</span> an IRIX (SGI) <span class="hljs-keyword">partition</span> <span class="hljs-keyword">table</span><br>   l   list known <span class="hljs-keyword">partition</span> types<br>   m   print this menu<br>   n   <span class="hljs-keyword">add</span> a <span class="hljs-keyword">new</span> <span class="hljs-keyword">partition</span><br>   o   <span class="hljs-keyword">create</span> a <span class="hljs-keyword">new</span> <span class="hljs-keyword">empty</span> DOS <span class="hljs-keyword">partition</span> <span class="hljs-keyword">table</span><br>   p   print the <span class="hljs-keyword">partition</span> <span class="hljs-keyword">table</span><br>   q   quit <span class="hljs-keyword">without</span> saving changes<br>   s   <span class="hljs-keyword">create</span> a <span class="hljs-keyword">new</span> <span class="hljs-keyword">empty</span> Sun disklabel<br>   t   change a <span class="hljs-keyword">partition</span><span class="hljs-string">&#x27;s system id</span><br><span class="hljs-string">   u   change display/entry units</span><br><span class="hljs-string">   v   verify the partition table</span><br><span class="hljs-string">   w   write table to disk and exit</span><br><span class="hljs-string">   x   extra functionality (experts only)</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">选择分区类型：主分区/扩展分区</span><br><span class="hljs-string">命令(输入 m 获取帮助)：n</span><br><span class="hljs-string">Partition type:</span><br><span class="hljs-string">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="hljs-string">   e   extended</span><br><span class="hljs-string">Select (default p): p</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">分区号 (1-4，默认 1)：                  ---&gt;输入2，硬盘就有2个分区</span><br><span class="hljs-string">起始 扇区 (2048-2097151，默认为 2048)：</span><br><span class="hljs-string">将使用默认值 2048</span><br><span class="hljs-string">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-2097151，默认为 2097151)：</span><br><span class="hljs-string">将使用默认值 2097151</span><br><span class="hljs-string">分区 1 已设置为 Linux 类型，大小设为 1023 MiB</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">命令(输入 m 获取帮助)：w</span><br><span class="hljs-string">The partition table has been altered!</span><br><span class="hljs-string"></span><br><span class="hljs-string">Calling ioctl() to re-read partition table.</span><br><span class="hljs-string">正在同步磁盘。</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">lsblk</span><br><span class="hljs-string">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="hljs-string">sda      8:0    0   20G  0 disk </span><br><span class="hljs-string">├─sda1   8:1    0    1G  0 part /boot</span><br><span class="hljs-string">├─sda2   8:2    0    2G  0 part [SWAP]</span><br><span class="hljs-string">└─sda3   8:3    0   17G  0 part /</span><br><span class="hljs-string">sdb      8:16   0    1G  0 disk </span><br><span class="hljs-string">└─sdb1   8:17   0 1023M  0 part </span><br><span class="hljs-string">sr0     11:0    1  4.3G  0 rom  </span><br><span class="hljs-string">分区成功</span><br><span class="hljs-string">硬盘sdb中只有一个分区sdb1</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h4 id="8-2-5-虚拟机增加硬盘步骤-3-格式化"><a href="#8-2-5-虚拟机增加硬盘步骤-3-格式化" class="headerlink" title="8.2.5 虚拟机增加硬盘步骤 3-格式化"></a>8.2.5 虚拟机增加硬盘步骤 3-格式化</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs subunit">格式化磁盘<br><br>为什么要格式化？<br>给这个分区指定它的文件类型<br><br>[root@Edu01 ~]# lsblk -f<br>NAME   FSTYPE  LABEL           UUID                                 MOUNTPOINT<br>sda                                                                 <br>├─sda1 ext4                    bd7b7249-b3fa<span class="hljs-string">-434</span>f-acfd<span class="hljs-string">-5127</span>a56c0673 /boot<br>├─sda2 swap                    4381675a<span class="hljs-string">-652</span>c<span class="hljs-string">-4</span>ffa<span class="hljs-string">-9</span>a9d-cb23d19be79b [SWAP]<br>└─sda3 ext4                    531c2867-a7e9<span class="hljs-string">-4</span>ae7<span class="hljs-string">-8</span>f79<span class="hljs-string">-4453</span>ceb76c5b /<br>sdb                                                                 <br>└─sdb1                                                              <br>sr0    iso9660 CentOS 7 x86_64 2018<span class="hljs-string">-11</span><span class="hljs-string">-25</span><span class="hljs-string">-23</span><span class="hljs-string">-54</span><span class="hljs-string">-16</span><span class="hljs-string">-00</span>    <br><br>sdb1的UUID为空，说明还没有格式化。<br><br>格式化命令:<br>mkfs -text4 /dev/sdb1 其中 ext4 是分区类型<br><br></code></pre></td></tr></table></figure><h4 id="8-2-6虚拟机增加硬盘步骤-4-挂载"><a href="#8-2-6虚拟机增加硬盘步骤-4-挂载" class="headerlink" title="8.2.6虚拟机增加硬盘步骤 4-挂载"></a>8.2.6虚拟机增加硬盘步骤 4-挂载</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs subunit">挂载: 将一个分区与一个目录联系起来，<br>命令：mount 设备名称 挂载目录<br><br>首先创建一个目录newdisk (目录位置随便)<br>假如在根目录下创建：mkdir newdisk<br>进行挂载：mount /dev/sdb1 /newdisk<br><br>NAME   FSTYPE  LABEL           UUID                                 MOUNTPOINT<br>sda                                                                 <br>├─sda1 ext4                    bd7b7249-b3fa<span class="hljs-string">-434</span>f-acfd<span class="hljs-string">-5127</span>a56c0673 /boot<br>├─sda2 swap                    4381675a<span class="hljs-string">-652</span>c<span class="hljs-string">-4</span>ffa<span class="hljs-string">-9</span>a9d-cb23d19be79b [SWAP]<br>└─sda3 ext4                    531c2867-a7e9<span class="hljs-string">-4</span>ae7<span class="hljs-string">-8</span>f79<span class="hljs-string">-4453</span>ceb76c5b /<br>sdb                                                                 <br>└─sdb1 ext4                    d1856552-dee4<span class="hljs-string">-4</span>fbc<span class="hljs-string">-9953</span>-f650231ecaac /newdisk<br>sr0    iso9660 CentOS 7 x86_64 2018<span class="hljs-string">-11</span><span class="hljs-string">-25</span><span class="hljs-string">-23</span><span class="hljs-string">-54</span><span class="hljs-string">-16</span><span class="hljs-string">-00</span>  <br>挂载点有了，挂载成功。<br><br><br>卸载(去除分区与目录的联系)：<br>命令：umount设备名称 或者挂载目录<br>例如：umount/dev/sdb1 或者 umount /newdisk<br><br><br>注意: 用命令行挂载,重启后会失效。<br><br></code></pre></td></tr></table></figure><h4 id="8-2-7虚拟机增加硬盘步骤-5-设置可以自动挂载"><a href="#8-2-7虚拟机增加硬盘步骤-5-设置可以自动挂载" class="headerlink" title="8.2.7虚拟机增加硬盘步骤 5-设置可以自动挂载"></a>8.2.7虚拟机增加硬盘步骤 5-设置可以自动挂载</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs awk">解决  用命令行挂载,重启后会失效 问题<br><br>永久挂载: <br>通过修改<span class="hljs-regexp">/etc/</span>fstab 实现挂载<br>添加完成后 执行 mount–a 即刻生效 或者 重启系统reboot<br><br>步骤：<br>vim <span class="hljs-regexp">/etc/</span>fstab<br>增加一行：UUID=上面sdb1的UUID    /newdisk    ext4    defaults     <span class="hljs-number">0</span> <span class="hljs-number">0</span><br>也可以是：<span class="hljs-regexp">/dev/</span>sdb1      /newdisk    ext4    defaults     <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><br><br><br><br>要挂载的设备或伪文件系统  挂载点  文件系统类型  挂载选项 转储频率 自检次序<br>UUID=上面sdb1的UUID   /newdisk    ext4    defaults   <span class="hljs-number">0</span>    <span class="hljs-number">0</span><br><br>要挂载的设备或伪文件系统：<br>设备文件、LABEL(LABEL=<span class="hljs-string">&quot;&quot;</span>)、UUID(UUID=<span class="hljs-string">&quot;&quot;</span>)、伪文件系统名称(proc, sysfs)<br><br>挂载点：指定的文件夹<br><br>挂载选项：defaults<br><br>转储频率：<br>  <span class="hljs-number">0</span>：不做备份<br>  <span class="hljs-number">1</span>：每天转储<br>  <span class="hljs-number">2</span>：每隔一天转储<br><br>自检次序：<br>  <span class="hljs-number">0</span>：不自检<br>  <span class="hljs-number">1</span>：首先自检；一般只有rootfs才用<span class="hljs-number">1</span>；<br><br></code></pre></td></tr></table></figure><h3 id="8-3磁盘情况查询"><a href="#8-3磁盘情况查询" class="headerlink" title="8.3磁盘情况查询"></a>8.3磁盘情况查询</h3><h4 id="8-3-1查询系统整体磁盘使用情况"><a href="#8-3-1查询系统整体磁盘使用情况" class="headerlink" title="8.3.1查询系统整体磁盘使用情况"></a>8.3.1查询系统整体磁盘使用情况</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">基本语法:<br><span class="hljs-built_in">df</span> -h   (disk free)<br><br>查询系统整体磁盘使用情况<br><br></code></pre></td></tr></table></figure><h4 id="8-3-2查询指定目录的磁盘占用情况"><a href="#8-3-2查询指定目录的磁盘占用情况" class="headerlink" title="8.3.2查询指定目录的磁盘占用情况"></a>8.3.2查询指定目录的磁盘占用情况</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">基本语法：<br><span class="hljs-built_in">du</span> -h  指定目录    (disk usage)<br>功能：查询指定目录的磁盘占用情况，默认为当前目录<br>-s 指定目录占用大小汇总<br>-h 带计量单位<br>-a 含文件<br>--max-depth=1子目录深度<br>-c 列出明细的同时，增加汇总值<br><br>应用实例<br>查询 /opt 目录的磁盘占用情况，深度为 1<br><span class="hljs-built_in">du</span> -hac --max-depth=1 /opt<br><br></code></pre></td></tr></table></figure><h3 id="8-4磁盘情况-工作实用指令"><a href="#8-4磁盘情况-工作实用指令" class="headerlink" title="8.4磁盘情况-工作实用指令"></a>8.4磁盘情况-工作实用指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 统计/opt 文件夹下文件的个数<br><span class="hljs-built_in">ls</span> -l /opt | grep <span class="hljs-string">&quot;^-&quot;</span> | <span class="hljs-built_in">wc</span> -l<br><br>说明：<br>grep <span class="hljs-string">&quot;^-&quot;</span> ---&gt;筛选出以-开头的，因为以-开头的都是文件<br><span class="hljs-built_in">wc</span> (word count) 统计数量<br><span class="hljs-built_in">wc</span> -l 统计行数 l即lines<br>统计grep筛选后的行数即文件个数<br><br>2. 统计/opt 文件夹下目录的个数<br><span class="hljs-built_in">ls</span> -l /opt | grep <span class="hljs-string">&quot;^d&quot;</span> | <span class="hljs-built_in">wc</span> -l<br><br>3. 统计/opt 文件夹下文件的个数，包括子文件夹里的<br><span class="hljs-built_in">ls</span> -lR /opt | grep <span class="hljs-string">&quot;^-&quot;</span> | <span class="hljs-built_in">wc</span> -l<br>-R 递归列出遇到的子目录<br><br>4. 统计/opt 文件夹下目录的个数，包括子文件夹里的<br><span class="hljs-built_in">ls</span> -lR /opt | grep <span class="hljs-string">&quot;^d&quot;</span> | <span class="hljs-built_in">wc</span> -l<br><br>5. 以树状显示目录结构 <br> 指令：tree 目录 <br> 默认情况下没有tree指令<br> 如果没有 tree ,则使用 yum install tree 指令安装<br><br></code></pre></td></tr></table></figure><h2 id="九、Linux-实操篇-网络配置"><a href="#九、Linux-实操篇-网络配置" class="headerlink" title="九、Linux 实操篇-网络配置"></a>九、Linux 实操篇-网络配置</h2><h3 id="9-1Linux-网络配置原理图"><a href="#9-1Linux-网络配置原理图" class="headerlink" title="9.1Linux 网络配置原理图"></a>9.1Linux 网络配置原理图</h3><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307062104221.png" alt="image-20230706210425070"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>.通过ifconfig指令查看Linux虚拟机的<span class="hljs-built_in">ip</span>地址<br><span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">2</span>.<span class="hljs-number">131</span><br><span class="hljs-number">2</span>.然后在本机DOS命令窗口输入指令ipconfig，查看vmnet8的<span class="hljs-built_in">ip</span>地址<br><span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1</span><br>上两个在同一网段，所以可以通信。<br><br><span class="hljs-number">3</span>.由第二步骤可以得到本机的无线网络适配器(无线网卡)的<span class="hljs-built_in">ip</span>地址<br><span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">101</span>.<span class="hljs-number">8</span><br><br>为什么Linux虚拟机可以连外网(比如打开百度)？<br>Linux虚拟机---&gt;本机vmnet8---&gt;本机无线网卡---&gt;教室局域网网关---&gt;外网<br><br>每次开机linux虚拟机的<span class="hljs-built_in">ip</span>地址不一定相同<br><span class="hljs-symbol">linux</span>虚拟机的<span class="hljs-built_in">ip</span>地址可以设置<br><br>以下：如何编辑虚拟机的网络和修改其<span class="hljs-built_in">ip</span>地址？<br><br></code></pre></td></tr></table></figure><h3 id="9-2查看网络IP和网关"><a href="#9-2查看网络IP和网关" class="headerlink" title="9.2查看网络IP和网关"></a>9.2查看网络IP和网关</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown">vmware---&gt;编辑---&gt;虚拟网络编辑器<br>这样就可以查看和修改虚拟网络vmnet8的ip地址和网关<br><br>通过本机DOS命令窗口，输入指令：ipconfig<br><span class="hljs-code">查看vmnet8的网络配置</span><br><span class="hljs-code"></span><br>在xshell或linux终端输入命令：ifconfig<br><span class="hljs-code">查看 linux 的网络配置</span><br><span class="hljs-code"></span><br><br><br>ping命令 测试主机之间网络连通性<br><span class="hljs-code">基本语法：</span><br><span class="hljs-code">ping 目的主机 （功能描述：测试当前服务器是否可以连接目的主机）</span><br><span class="hljs-code"></span><br>应用实例<br><span class="hljs-code">测试当前服务器是否可以连接百度</span><br><span class="hljs-code">ping www.baidu.com</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h3 id="9-3linux-网络环境配置"><a href="#9-3linux-网络环境配置" class="headerlink" title="9.3linux 网络环境配置"></a>9.3linux 网络环境配置</h3><h4 id="9-3-1第一种方法-自动获取ip-："><a href="#9-3-1第一种方法-自动获取ip-：" class="headerlink" title="9.3.1第一种方法(自动获取ip)："></a>9.3.1第一种方法(自动获取ip)：</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">登陆后，通过界面设置自动获取<span class="hljs-built_in">ip</span><br>应用程序---&gt;系统工---&gt;设置---&gt;网络---&gt;小齿轮---&gt;IPV4<br>特点：linux 启动后会自动获取 <span class="hljs-built_in">IP</span>，可以避免<span class="hljs-built_in">ip</span>冲突<br>缺点：每次自动获取的 <span class="hljs-built_in">ip</span> 地址可能不一样，但是作为服务器<span class="hljs-built_in">ip</span>地址不能变。<br><br>工作时，一般将Linux的<span class="hljs-built_in">ip</span>地址手动设定，不改变。<br><br></code></pre></td></tr></table></figure><h4 id="9-3-2第二种方法-手动设置ip"><a href="#9-3-2第二种方法-手动设置ip" class="headerlink" title="9.3.2第二种方法(手动设置ip)"></a>9.3.2第二种方法(手动设置ip)</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs routeros">手动指定linux的ip地址，使其不变化。<br><br>直接修改配置文件来指定 IP,并可以连接到外网(程序员推荐)<br>关于网络的配置文件在：/etc/sysconfig/network-scripts/ifcfg-ens33<br><br>要求：将ip地址配置为静态的(不变的)，比如:<span class="hljs-built_in"> ip </span>地址为 192.168.200.130<br><br>输入指令：vim /etc/sysconfig/network-scripts/ifcfg-ens33<br>修改文件内容：<br><span class="hljs-attribute">BOOTPROTO</span>=<span class="hljs-string">&quot;static&quot;</span><br>加上：<br><span class="hljs-attribute">IPADDR</span>=192.168.200.130   (IP地址,自己设定的)<br><span class="hljs-attribute">GATEWAY</span>=192.168.200.2 (网关,自己设定的)<br><span class="hljs-attribute">DNS1</span>=192.168.200.2 (域名解析器,自己设定的)<br><br>下一步：vmnet8和Linux在同一网段上，要能够通信，也要修改相应的vmnet8<br>vmware---&gt;编辑---&gt;虚拟网络编辑器<br>打开虚拟编辑器，点击vmnet8，修改下面的子网ip为：192.168.200.0<br>然后点击NAT设置，将网关改为192.168.200.2<br><br>应用确定<br><br>输入指令：service<span class="hljs-built_in"> network </span>restart 或 reboot  使上述修改生效<br><br></code></pre></td></tr></table></figure><h3 id="9-4设置Linux系统的主机名和-hosts-映射"><a href="#9-4设置Linux系统的主机名和-hosts-映射" class="headerlink" title="9.4设置Linux系统的主机名和 hosts 映射"></a>9.4设置Linux系统的主机名和 hosts 映射</h3><h4 id="9-4-1设置主机名"><a href="#9-4-1设置主机名" class="headerlink" title="9.4.1设置主机名"></a>9.4.1设置主机名</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vim">Linux系统的主机名相当于其ip地址，起一个主机名是因为ip地址不好记忆，不方便。<br>也可以修改主机名。<br><br>查看当前主机的主机名指令：<span class="hljs-built_in">hostname</span><br><br>主机名放在/etc/<span class="hljs-built_in">hostname</span>文件中，要修改主机名即修改文件内容：<br>输入指令：<br><span class="hljs-keyword">vim</span> /etc/<span class="hljs-built_in">hostname</span><br>修改内容<br>:<span class="hljs-keyword">wq</span><br>重启系统<br><br></code></pre></td></tr></table></figure><h4 id="9-4-2设置-hosts-映射"><a href="#9-4-2设置-hosts-映射" class="headerlink" title="9.4.2设置 hosts 映射"></a>9.4.2设置 hosts 映射</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs armasm">在Windows中，如何通过 主机名 找到(比如 ping) 某个 linux 系统?<br><br>修改<span class="hljs-built_in">ip</span>地址与主机名的映射关系：<br>在windows C:\Windows\System32\drivers\etc\hosts 文件中<br>指定Linux系统的<span class="hljs-built_in">ip</span>地址与主机名的映射关系<br>格式：linux系统<span class="hljs-built_in">ip</span>地址 linux系统主机名<br>如指定为: <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">200</span>.<span class="hljs-number">130</span> hspedu100 (这行代码添加到文件中就行了)<br><br>ping hspedu100 ----&gt;就会去该文件中找相应的<span class="hljs-built_in">ip</span>地址<br><br><br>那么，如果也想在Linux系统中，使用主机名 来 ping 某个Windows系统，怎么做？<br>在 linux 系统的 /etc/hosts 文件中 指定<br>如指定为: <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">200</span>.<span class="hljs-number">1</span> ThinkPad-<span class="hljs-built_in">PC</span><br>这样就可以 ping ThinkPad-<span class="hljs-built_in">PC</span><br><br></code></pre></td></tr></table></figure><h3 id="9-5-主机名解析过程分析-hosts、DNS"><a href="#9-5-主机名解析过程分析-hosts、DNS" class="headerlink" title="9.5.主机名解析过程分析(hosts、DNS)"></a>9.5.主机名解析过程分析(hosts、DNS)</h3><h4 id="9-5-1hosts"><a href="#9-5-1hosts" class="headerlink" title="9.5.1hosts"></a>9.5.1hosts</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">hosts是一个文本文件，用来记录 IP 和 <span class="hljs-built_in">Hostname</span>(主机名)的映射关系<br></code></pre></td></tr></table></figure><h4 id="9-5-2DNS"><a href="#9-5-2DNS" class="headerlink" title="9.5.2DNS"></a>9.5.2DNS</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">DNS</span>  Domain Name System 域名系统<br>是互联网上作为域名和 <span class="hljs-built_in">IP</span> 地址相互映射的一个分布式数据库<br><br>为什么可以通过主机名访问？<br>通过DNS域名解析系统，将主机名解析为<span class="hljs-built_in">ip</span>地址，实际上还是用的<span class="hljs-built_in">ip</span>地址。<br></code></pre></td></tr></table></figure><h4 id="9-5-3应用实例"><a href="#9-5-3应用实例" class="headerlink" title="9.5.3应用实例"></a>9.5.3应用实例</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs armasm">用户在浏览器输入了www.baidu.com<br><br><span class="hljs-number">1</span>.浏览器先检查浏览器缓存中有没有该域名解析 <span class="hljs-built_in">IP</span> 地址，有就先调用这个 <span class="hljs-built_in">IP</span> 完成解析；<br>如果没有，就检查 DNS 解析器缓存，如果有直接返回 <span class="hljs-built_in">IP</span> 完成解析。<br>这两个缓存，可以理解为 本地解析器缓存<br><br><span class="hljs-symbol">DNS</span> 解析器缓存：<br>一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存他的 <span class="hljs-built_in">IP</span> 地址（DNS 解析记录）<br>如在 cmd 窗口中输入<br>ipconfig /displaydns<span class="hljs-comment">//DNS 域名解析缓存</span><br>ipconfig /flushdns<span class="hljs-comment">//手动清理 dns 缓存</span><br><br><span class="hljs-number">2</span>. 如果本地解析器缓存没有找到对应映射，检查系统中 hosts 文件中有没有配置对应的域名 <span class="hljs-built_in">IP</span> 映射，如果有，则完成解析并返回。<br><br><span class="hljs-number">3</span>. 如果本地 DNS 解析器缓存 和 hosts 文件 中均没有找到对应的 <span class="hljs-built_in">IP</span>，则到域名服务器找<br><span class="hljs-number">4</span>. 还找不到，就没有了。<br><br>示意图:<br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307062113549.png" alt="image-20230706211304454"></p><h2 id="十、Linux-实操篇-进程管理-重点"><a href="#十、Linux-实操篇-进程管理-重点" class="headerlink" title="十、Linux 实操篇-进程管理(重点)"></a>十、Linux 实操篇-进程管理(重点)</h2><h3 id="10-1基本介绍"><a href="#10-1基本介绍" class="headerlink" title="10.1基本介绍"></a>10.1基本介绍</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>)在 LINUX 中，每个执行的程序都称为一个进程。每一个进程都分配一个 ID 号(pid,进程号)。<br>程序执行之后加载到内存中成为进程。程序是静态的，进程是动态的。<br><br>(<span class="hljs-number">2</span>)每个进程都可能以两种方式存在：<br>前台与后台<br>前台进程：是用户目前的屏幕上可以进行操作的。<br>后台进程：是实际在操作的，但屏幕上无法看到，通常使用后台方式执行。<br><br>(<span class="hljs-number">3</span>)一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。<br><br></code></pre></td></tr></table></figure><h3 id="10-2ps命令：显示系统正在执行的进程"><a href="#10-2ps命令：显示系统正在执行的进程" class="headerlink" title="10.2ps命令：显示系统正在执行的进程"></a>10.2ps命令：显示系统正在执行的进程</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1</span>.基本介绍：<br><span class="hljs-built_in">ps</span>命令是用来查看目前系统中，有哪些进程正在执行，以及它们执行的状况。<br>可以不加任何参数。<br><br>语法：<br><span class="hljs-built_in">ps</span> [选项]    <span class="hljs-keyword">Process</span> Status<br>选项：<br><span class="hljs-literal">-a</span>显示当前终端的所有进程信息<br><span class="hljs-literal">-u</span>以用户的格式显示进程信息<br><span class="hljs-literal">-x</span>显示后台程序运行的参数<br><br>一般三个选项一起用：<br><span class="hljs-built_in">ps</span> <span class="hljs-literal">-aux</span><br><br>显示出如下内容：<br>USER  执行进程用户名称  <br>PID      进程号<br>%CPU           进程占用CPU百分比<br>%MEM      进程占用物理内存的百分比<br>VSZ      进程占用的虚拟内存大小（单位：KB）<br>RSS   进程占用的物理内存大小（单位：KB）<br>TTY      终端名称(有时缩写)<br>STAT             进程状态：<br> S-睡眠<br> s-表示该进程是会话的先导进程<br> N-表示进程拥有比普通优先级更低的优先级<br> <span class="hljs-built_in">R</span>-正在运行<br> D-短期等待<br> Z-僵死进程<br> T-被跟踪或者被停止等等<br><span class="hljs-built_in">START</span>            进程执行的开始时间<br>TIME             CPU 时间，即进程使用 CPU 的总时间<br>COMMAND      启动进程所用的命令和参数，如果过长会被截断显示<br><br><br><br>上述命令将所有进程显示出来，若只想查找某一个进程：<br>指令：<span class="hljs-built_in">ps</span> –aux|grep xxx  <br>比如查找 sshd 进程：<span class="hljs-built_in">ps</span> <span class="hljs-literal">-aux</span> | grep sshd<br><br><br><br><br><br><br>应用实例：<br>要求：以全格式显示当前所有的进程，查看进程的父进程。 <br><br>父进程：一个进程可以生成多个子进程，该进程称为父进程。<br><br><br>查看 sshd 的父进程信息：<br>知道一个父进程的pid就可以知道它的信息。<br><br><span class="hljs-built_in">ps</span> <span class="hljs-literal">-ef</span> 是以全格式显示当前所有的进程。<span class="hljs-literal">-e</span> 显示所有进程。<span class="hljs-operator">-f</span> 全格式。<br><br><span class="hljs-built_in">ps</span> <span class="hljs-literal">-ef</span> 指令显示内容如下： <br>UID         用户ID<br>PID   进程ID<br>PPID  父进程ID             <br>C CPU 用于计算执行优先级的因子。<br>数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；<br>数值越小，表明进程是 I/O 密集型运算，执行优先级会提高<br>STIME    进程启动的时间<br>TTY         完整的终端名称<br>TIME        CPU 使用时间<br>CMD    启动进程所用的命令和参数<br><br>输入：<span class="hljs-built_in">ps</span> <span class="hljs-literal">-ef</span> | grep sshd<br>得到第三列为<span class="hljs-number">1</span>，即父进程ID=<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h3 id="10-3kill-和-killall指令：终止进程"><a href="#10-3kill-和-killall指令：终止进程" class="headerlink" title="10.3kill 和 killall指令：终止进程"></a>10.3kill 和 killall指令：终止进程</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1</span>.介绍:<br>若是某个进程执行一半需要停止时，或是已经消耗了很大的系统资源时，此时可以考虑停止该进程。<br>使用 <span class="hljs-built_in">kill</span> 命令来完成此项任务。<br><br><span class="hljs-number">2</span>.基本语法：<br><span class="hljs-built_in">kill</span> [选项] 进程号（功能描述：通过进程号杀死/终止进程）<br>killall 进程名称    （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）<br> 使用killall，会将该进程的所有子进程也都删除/终止。<br><br><br><span class="hljs-number">3</span>.常用选项：<br><span class="hljs-literal">-9</span>   表示强制终止进程<br> (系统觉得某个程序重要，可能会屏蔽你的<span class="hljs-built_in">kill</span>指令，这时使用选项<span class="hljs-literal">-9</span>强制终止进程)<br><br><br><br><br><span class="hljs-number">4</span>.案例：<br>案例 <span class="hljs-number">1</span>：踢掉某个非法登录用户<br><span class="hljs-built_in">kill</span> 进程号 <br>比如 <span class="hljs-built_in">kill</span> <span class="hljs-number">11421</span><br><br>假如使用tom登录，然后在图形界面打开终端写代码<br>假设认为tom是个非法用户，要踢掉它<br>先在图形界面写代码：<span class="hljs-built_in">ps</span> <span class="hljs-literal">-aux</span> | grep sshd<br>sshd 是记载远程连接服务的配置文件<br>上述指令显示出了，远程登录的进程信息，从中看到了tom登录的进程的进程号<span class="hljs-number">11421</span><br>所以 <span class="hljs-built_in">kill</span> <span class="hljs-number">11421</span>  这样tom就下线了！<br><br><br><br>案例 <span class="hljs-number">2</span>：终止远程登录服务 sshd, 在适当时候再次重启 sshd 服务<br>sshd <span class="hljs-literal">---</span>&gt; secure shell<br><br>首先查看 sshd 对应的进程号：<br>使用命令：<span class="hljs-built_in">ps</span> <span class="hljs-literal">-aux</span> | grep sshd<br>有 /user/sbin/sshd 的那个进程就是 sshd 服务进程 进程号<span class="hljs-number">10748</span><br>终止 sshd 之后，就无法在xshell远程登陆了！<br><br>重启 sshd 服务指令：<br>/bin/systemctl <span class="hljs-built_in">start</span> 服务名称<br>/bin/systemctl <span class="hljs-built_in">start</span> sshd.service<br><br><br><br>案例 <span class="hljs-number">3</span>：终止多个 gedit (文本编辑器)<br>在Linux桌面，主文件夹中，打开多个文本，然后使用killall 可以同时关闭所有打开的文本<br>killallgedit<br><br><br><br>案例 <span class="hljs-number">4</span>：强制杀掉一个终端<br>在Linux系统桌面打开两个终端，bash即代表终端进程<br>在一个终端中输入指令强制关闭另一个终端<br>首先：查看终端进程的进程号：<span class="hljs-built_in">ps</span> <span class="hljs-literal">-aux</span> | grep bash<br>得到对应的进程号，输入：<span class="hljs-built_in">kill</span> <span class="hljs-literal">-9</span>  对应的进程号<br><br>也可以终端自己终止自己<br><br></code></pre></td></tr></table></figure><h3 id="10-4查看进程树-pstree"><a href="#10-4查看进程树-pstree" class="headerlink" title="10.4查看进程树 pstree"></a>10.4查看进程树 pstree</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span>.基本语法：pstree <span class="hljs-selector-attr">[选项]</span> <br>功能：可以更加直观的来看进程信息(树的形式)<br><br><span class="hljs-number">2</span>.常用选项：<br>-<span class="hljs-selector-tag">p</span> :显示进程的 PID (父进程ID)<br>-u :显示进程的所属用户<br><br><br><span class="hljs-number">3</span>.应用实例：<br>案例 <span class="hljs-number">1</span>：用树状的形式显示进程的<span class="hljs-built_in">pid</span>(进程号)<br>pstree -<span class="hljs-selector-tag">p</span><br><br>案例 <span class="hljs-number">2</span>：用树状的形式显示进程的用户<br>pstree -u<br><br></code></pre></td></tr></table></figure><h3 id="10-5服务-service-管理"><a href="#10-5服务-service-管理" class="headerlink" title="10.5服务(service)管理"></a>10.5服务(service)管理</h3><h4 id="10-5-1介绍"><a href="#10-5-1介绍" class="headerlink" title="10.5.1介绍"></a>10.5.1介绍</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">服务(service) 本质就是进程，但是是运行在后台的，<br>通常都会监听某个端口，等待其它程序的请求，比如(mysqld , sshd防火墙等)，<br>因此我们又称为守护进程，是 Linux 中非常重要的知识点。<br><br></code></pre></td></tr></table></figure><h4 id="10-5-2service-管理指令"><a href="#10-5-2service-管理指令" class="headerlink" title="10.5.2service 管理指令"></a>10.5.2service 管理指令</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros">(1)<span class="hljs-built_in">service</span>服务名 [start | stop | restart | reload | status]<br>start 开启服务<br>stop 终止服务<br>restart 重启服务<br>reload 重载服务<br>status 查看服务的状态<br><br>(2)在 CentOS7.0 后很多服务不再使用 service指令管理,而是使用 systemctl (后面专门讲)<br><br>(3)还有一些在 /etc/init.d 下的服务仍使用<span class="hljs-built_in"> service </span>指令管理<br><br><br>案例：<br>请使用<span class="hljs-built_in"> service </span>指令，查看，关闭，启动<span class="hljs-built_in"> network</span><br><span class="hljs-built_in"></span>[注意：在虚拟系统打开终端演示，因为网络连接会关闭]<br>指令:<br><span class="hljs-built_in">service network </span>status <br><span class="hljs-built_in">service network </span>stop <br><span class="hljs-built_in">service network </span>start<br><br></code></pre></td></tr></table></figure><h4 id="10-5-3查看服务名方式"><a href="#10-5-3查看服务名方式" class="headerlink" title="10.5.3查看服务名方式"></a>10.5.3查看服务名方式</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">方式 <span class="hljs-number">1</span>：直接输入 setup 即可看到所有服务<br>其中前面带 * 的服务会随着Linux系统的启动而自动启动。<br><br>方式 <span class="hljs-number">2</span>:ls -l <span class="hljs-regexp">/etc/i</span>nit.d<br>只能看到部分服务：还有一些在 <span class="hljs-regexp">/etc/i</span>nit.d 下的服务仍使用 service 指令管理<br><br></code></pre></td></tr></table></figure><h4 id="10-5-4服务的运行级别-runlevel"><a href="#10-5-4服务的运行级别-runlevel" class="headerlink" title="10.5.4服务的运行级别(runlevel)"></a>10.5.4服务的运行级别(runlevel)</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss">Linux 系统有 <span class="hljs-number">7</span> 种运行级别(runlevel)：常用的是级别 <span class="hljs-number">3</span> 和 <span class="hljs-number">5</span><br><br>运行级别 <span class="hljs-number">0</span>：系统停机状态，系统默认运行级别不能设为 <span class="hljs-number">0</span>，否则不能正常启动<br>运行级别 <span class="hljs-number">1</span>：单用户工作状态，root 权限，用于系统维护，禁止远程登陆<br>运行级别 <span class="hljs-number">2</span>：多用户状态(没有 NFS)，不支持网络<br>运行级别 <span class="hljs-number">3</span>：完全的多用户状态(有 NFS)，无界面，登陆后进入控制台命令行模式<br>运行级别 <span class="hljs-number">4</span>：系统未使用，保留<br>运行级别 <span class="hljs-number">5</span>：X11 控制台，登陆后进入图形 GUI 模式<br>运行级别 <span class="hljs-number">6</span>：系统正常关闭并重启，默认运行级别不能设为 <span class="hljs-number">6</span>，否则不能正常启动<br><br>授课时使用<span class="hljs-number">5</span>，工作时大多使用<span class="hljs-number">3</span>。<br><br>开机的流程说明：<br><br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307062116728.png" alt="image-20230706211613640"></p><h4 id="10-5-5CentOS7-后运行级别说明"><a href="#10-5-5CentOS7-后运行级别说明" class="headerlink" title="10.5.5CentOS7 后运行级别说明"></a>10.5.5CentOS7 后运行级别说明</h4><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">在 /<span class="hljs-string">etc</span>/<span class="hljs-string">initab</span> <br>进行了简化，如下:<br><span class="hljs-string">multi-user</span>.<span class="hljs-string">target</span>: <span class="hljs-string">analogous</span> <span class="hljs-string">to</span> <span class="hljs-string">runlevel</span> <span class="hljs-string">3</span> <br><span class="hljs-string">graphical</span>.<span class="hljs-string">target</span>: <span class="hljs-string">analogous</span> <span class="hljs-string">to</span> <span class="hljs-string">runlevel</span> <span class="hljs-string">5</span> <br><br>查看当前运行级别：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">get-default</span><br><span class="hljs-string">ctl</span> ---&gt; <span class="hljs-string">control</span><br><br>更改运行级别：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">set-default</span> <span class="hljs-string">multi-user</span>.<span class="hljs-string">target</span>/<span class="hljs-string">graphical</span>.<span class="hljs-string">target</span><br>    然后重启 <span class="hljs-string">reboot</span><br><br></code></pre></td></tr></table></figure><h4 id="10-5-6chkconfig-指令"><a href="#10-5-6chkconfig-指令" class="headerlink" title="10.5.6chkconfig 指令"></a>10.5.6chkconfig 指令</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs stylus">通过 chkconfig 命令可以给服务在 各个运行级别 设置开启自启动/关闭自启动<br><br>chkconfig 指令管理的服务在 /etc/init<span class="hljs-selector-class">.d</span>  查看<br><br>注意: Centos7.<span class="hljs-number">0</span> 后，很多服务使用 systemctl 管理 (后面马上讲)<br><br><br><br>chkconfig 基本语法：<br>(<span class="hljs-number">1</span>)查看服务和服务在各个级别是开启/关闭自启动  (有限，只能查看chkconfig管理下的服务)<br>chkconfig <span class="hljs-attr">--list</span> <span class="hljs-selector-attr">[| grepxxx]</span>    (若查找某一个服务使用grep过滤)<br> <br>(<span class="hljs-number">2</span>)chkconfig 服务名 <span class="hljs-attr">--list</span><br><br>(<span class="hljs-number">3</span>)chkconfig <span class="hljs-attr">--level</span> <span class="hljs-number">5</span> 服务名 on   给该服务在<span class="hljs-number">5</span>运行级别开启自启动<br>chkconfig <span class="hljs-attr">--level</span> <span class="hljs-number">5</span> 服务名 off     给该服务在<span class="hljs-number">5</span>运行级别关闭自启动<br><br><br><br>案例演示: 对network服务进行各种操作,把 network 在 <span class="hljs-number">3</span> 运行级别 关闭自启动<br>chkconfig <span class="hljs-attr">--level</span> <span class="hljs-number">3</span> network off <br><br>注意：chkconfig 重新设置服务后自启动或关闭，需要重启机器 reboot 生效.<br><br></code></pre></td></tr></table></figure><h4 id="10-5-7systemctl-管理指令"><a href="#10-5-7systemctl-管理指令" class="headerlink" title="10.5.7systemctl 管理指令"></a>10.5.7systemctl 管理指令</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">基本语法：systemctl [start | stop | restart | status] 服务名<br><br>systemctl 指令管理的服务在 <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system 查看<br><br></code></pre></td></tr></table></figure><h4 id="10-5-9systemctl-设置服务的自启动状态"><a href="#10-5-9systemctl-设置服务的自启动状态" class="headerlink" title="10.5.9systemctl 设置服务的自启动状态"></a>10.5.9systemctl 设置服务的自启动状态</h4><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-unit-files</span> [ | <span class="hljs-string">grep</span> 服务名] (查看服务开机启动状态, <span class="hljs-string">grep</span> 可以进行过滤) <br><span class="hljs-string">systemctl</span> <span class="hljs-string">enable</span> 服务名 (设置服务开机自启动)<br><span class="hljs-string">systemctl</span> <span class="hljs-string">disable</span> 服务名 (关闭服务开机自启动)<br><span class="hljs-string">systemctl</span> <span class="hljs-string">is-enabled</span> 服务名  (查询某个服务是否是自启动的)<br><br><span class="hljs-string">centos7</span>之后运行级别只有<span class="hljs-string">3</span>和<span class="hljs-string">5</span>，所以以上指令对<span class="hljs-string">3</span>和<span class="hljs-string">5</span>运行级别同时适用。<br><br>应用案例：<br>查看当前防火墙的状况，关闭防火墙和重启防火墙 <span class="hljs-string">firewalld</span>.<span class="hljs-string">service</span> <br>查看当前防火墙情况：<span class="hljs-string">systemctl</span> <span class="hljs-string">status</span> <span class="hljs-string">firewalld</span><br>关闭防火墙：<span class="hljs-string">systemctl</span> <span class="hljs-string">stop</span> <span class="hljs-string">firewalld</span><br>重启防火墙：<span class="hljs-string">systemctl</span> <span class="hljs-string">start</span> <span class="hljs-string">firewalld</span><br>.<span class="hljs-string">service</span>写不写都行<br><br><br>注意：关闭或者启用防火墙后，立即生效。<br>但是 这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。<br><br>如果希望设置某个服务自启动或关闭永久生效<br>要使用 <span class="hljs-string">systemctl</span>[<span class="hljs-string">enable</span>|<span class="hljs-string">disable</span>] 服务名<br><br></code></pre></td></tr></table></figure><h4 id="10-5-10firewall-指令：打开或者关闭指定端口"><a href="#10-5-10firewall-指令：打开或者关闭指定端口" class="headerlink" title="10.5.10firewall 指令：打开或者关闭指定端口"></a>10.5.10firewall 指令：打开或者关闭指定端口</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">在真正的生产环境，往往需要将防火墙打开。<br>但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。<br>这时，需要打开指定的端口。比如 <span class="hljs-number">80、22、8080</span> 等。<br><br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307062117667.png" alt="image-20230706211737571"></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">(1)打开端口: firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">permanent</span> <span class="hljs-literal">--</span><span class="hljs-comment">add</span><span class="hljs-literal">-</span><span class="hljs-comment">port=端口号/协议</span><br><br><span class="hljs-comment">通过 netstat</span> <span class="hljs-literal">-</span><span class="hljs-comment">anp | more 指令查看端口号的协议 (more 分页显示)</span><br><span class="hljs-comment">该指令输出的信息中：</span><br><span class="hljs-comment">Local Address下是 ip地址:端口号</span><br><span class="hljs-comment">Proto 是协议   (protocol 协议)</span><br><br><span class="hljs-comment">(2)关闭端口: firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">permanent</span> <span class="hljs-literal">--</span><span class="hljs-comment">remove</span><span class="hljs-literal">-</span><span class="hljs-comment">port=端口号/协议</span><br><br><span class="hljs-comment">注意：无论是打开端口还是关闭端口，要重新载入才能生效</span><br><span class="hljs-comment">重新载入：firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">reload</span><br><br><span class="hljs-comment">(3) 查询端口是否开放: firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">query</span><span class="hljs-literal">-</span><span class="hljs-comment">port=端口/协议</span><br><br><br><br><span class="hljs-comment">应用案例：</span><br><span class="hljs-comment">(1)启用防火墙，测试 111 端口是否能 telnet (远程登录) 不行</span><br><span class="hljs-comment">在本地主机DOS命令窗口输入：telnet Linux虚拟机ip地址:端口号</span><br><span class="hljs-comment">测试本地主机能否访问虚拟机的111端口</span><br><span class="hljs-comment">telnet 192</span><span class="hljs-string">.</span><span class="hljs-comment">168</span><span class="hljs-string">.</span><span class="hljs-comment">200</span><span class="hljs-string">.</span><span class="hljs-comment">130 111</span><br><br><span class="hljs-comment">防火墙打开</span><span class="hljs-literal">+</span><span class="hljs-comment">端口关闭</span><span class="hljs-literal">---</span>&gt;<span class="hljs-comment">不可以访问端口</span><br><br><span class="hljs-comment">(2)开放 111 端口</span><br><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">permanent</span> <span class="hljs-literal">--</span><span class="hljs-comment">add</span><span class="hljs-literal">-</span><span class="hljs-comment">port=111/tcp ;</span><br><span class="hljs-comment">需要 firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">reload</span><br><br><span class="hljs-comment">防火墙打开</span><span class="hljs-literal">+</span><span class="hljs-comment">端口打开</span><span class="hljs-literal">---</span>&gt;<span class="hljs-comment">可以访问端口</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(3)再次关闭 111 端口</span><br><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">permanent</span> <span class="hljs-literal">--</span><span class="hljs-comment">remove</span><span class="hljs-literal">-</span><span class="hljs-comment">port=111/tcp</span> <br><span class="hljs-comment">需要 firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">reload</span><br><br></code></pre></td></tr></table></figure><h3 id="10-6top指令：动态监控进程"><a href="#10-6top指令：动态监控进程" class="headerlink" title="10.6top指令：动态监控进程"></a>10.6top指令：动态监控进程</h3><h4 id="10-6-1介绍"><a href="#10-6-1介绍" class="headerlink" title="10.6.1介绍"></a>10.6.1介绍</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">top</span> 与 ps 命令很相似。<br>它们都用来显示正在执行的进程。<br><span class="hljs-built_in">top</span> 与 ps 最大的不同之处在于: <span class="hljs-built_in">top</span> 在执行一段时间可以更新正在运行的的进程。<br><br></code></pre></td></tr></table></figure><h4 id="10-6-2基本语法"><a href="#10-6-2基本语法" class="headerlink" title="10.6.2基本语法"></a>10.6.2基本语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">top</span> <span class="hljs-selector-attr">[选项]</span><br><br>选项说明：<br><br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307062118402.png" alt="image-20230706211840309"></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">输入top指令后：每一条都是一个进程<br>显示：<br>第一行<br>第一个时间      当前时间<br>第二个时间      系统运行时间<br><span class="hljs-number">2</span> users       有几个用户<br>load average   负载值(三个值相加除以<span class="hljs-number">3</span>&gt;<span class="hljs-number">0.7</span> 说明系统负载过大，要提高性能)<br>第二行<br>Tasks 系统任务数<br><span class="hljs-number">1</span> running <span class="hljs-number">1</span>个正在运行进程<br><span class="hljs-number">184</span> sleeping <span class="hljs-number">184</span>个休眠进程<br><span class="hljs-number">0</span> <span class="hljs-literal">stopped</span> <span class="hljs-number">0</span>个终止进程<br><span class="hljs-number">0</span> zombie <span class="hljs-number">0</span>个僵死进程   (要清除僵死进程，因为僵死进程无用且占内存空间)<br>第三行 占用的CPU百分比<br>us 用户占用的CPU<br>sy 系统占用的CPU<br>id 空闲<br>第四行 Mem 内存占用情况<br>total 总共内存<br>free 空闲内存<br><span class="hljs-keyword">user</span> <span class="hljs-title">已使用内存</span><br><span class="hljs-title">第五行 Swap</span> 分区<br>total 总共大小<br>free 未使用大小<br>used 已用大小<br>avail Mem 可获取的内存大小<br><br></code></pre></td></tr></table></figure><h4 id="10-6-3交互操作说明"><a href="#10-6-3交互操作说明" class="headerlink" title="10.6.3交互操作说明"></a>10.6.3交互操作说明</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入命令<span class="hljs-built_in">top</span><br>然后输入以下命令，得以下功能对进程进行排序<br><br></code></pre></td></tr></table></figure><h4 id="14-6-4应用实例"><a href="#14-6-4应用实例" class="headerlink" title="14.6.4应用实例"></a>14.6.4应用实例</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scss">案例 <span class="hljs-number">1</span>：监视特定用户, 比如监控 tom 用户<br>输入<span class="hljs-attribute">top</span><br>回车<br>输入u<br>回车<br>输入要监控用户名 (该用户要登录才能看到他的进程信息)<br><br><br>案例 <span class="hljs-number">2</span>：终止指定的进程, 比如我们要结束 tom 登录<br>输入<span class="hljs-attribute">top</span><br>回车<br>输入k<br>回车<br>输入要结束的进程 ID 号 （bash那个进程的PID）<br>回车<br>输入信号量 <span class="hljs-number">9</span> 强制删除<br>tom掉线<br><br>案例 <span class="hljs-number">3</span>：指定系统状态更新的时间(每隔 <span class="hljs-number">10</span> 秒自动更新),默认是 <span class="hljs-number">3</span> 秒<br><span class="hljs-attribute">top</span> -d <span class="hljs-number">10</span><br><br></code></pre></td></tr></table></figure><h3 id="10-7netstat指令：监控网络状态"><a href="#10-7netstat指令：监控网络状态" class="headerlink" title="10.7netstat指令：监控网络状态"></a>10.7netstat指令：监控网络状态</h3><h4 id="10-7-1查看系统网络情况netstat"><a href="#10-7-1查看系统网络情况netstat" class="headerlink" title="10.7.1查看系统网络情况netstat"></a>10.7.1查看系统网络情况netstat</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">基本语法：<br>netstat [选项]<br><br>选项说明：<br>-an按一定顺序排列输出<br>-p显示哪个进程在调用<br><br>输入netstat -an | more (more 分页展示)<br>显示：<br>Proto 协议<br>Recv-Q接收信息队列<br>Send-Q 发送信息队列<br><span class="hljs-keyword">Local</span> Address      本地地址 Linux地址 <br><span class="hljs-keyword">Foreign</span> Address         外部地址    <br>State <span class="hljs-keyword">LISTEN</span> 监听  ESTABLISHED 已建立连接 TIME_WAIT 超时等待<br><br>TIME_WAIT 超时等待 <br><span class="hljs-comment">---&gt;某个连接断了之后(如用户退出登录)，连接不会立刻消失，而是State变为TIME_WAIT</span><br>系统认为可能是网络状态不好，过一段时间仍无法连接，则连接消失。 <br><br><br>Proto Recv-Q Send-Q <span class="hljs-keyword">Local</span> Address           <span class="hljs-keyword">Foreign</span> Address         State <br>tcp        <span class="hljs-number">0</span>     <span class="hljs-number">36</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.130</span>:<span class="hljs-number">22</span>      <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.1</span>:<span class="hljs-number">14498</span>     ESTABLISHED<br>要建立连接双方都要有一个端口<br><span class="hljs-number">22</span>端口在Linux<br><span class="hljs-number">14498</span>端口在Windows<br>如下图：<br><br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307062119794.png" alt="image-20230706211950703"></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">案例：查看服务名为 sshd 的服务的信息。<br>netstat -anp <span class="hljs-string">| grep sshd</span><br><br></code></pre></td></tr></table></figure><h4 id="10-7-2检测主机连接命令ping"><a href="#10-7-2检测主机连接命令ping" class="headerlink" title="10.7.2检测主机连接命令ping"></a>10.7.2检测主机连接命令ping</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">是一种网络检测工具，它主要是用检测远程主机是否正常，或是两部主机间的网线或网卡故障。<br>如: ping 对方的<span class="hljs-built_in">ip</span>地址<br></code></pre></td></tr></table></figure><h2 id="十一、Linux-实操篇-RPM-与-YUM"><a href="#十一、Linux-实操篇-RPM-与-YUM" class="headerlink" title="十一、Linux 实操篇- RPM 与 YUM"></a>十一、Linux 实操篇- RPM 与 YUM</h2><h3 id="11-1RPM"><a href="#11-1RPM" class="headerlink" title="11.1RPM"></a>11.1RPM</h3><h4 id="11-1-1介绍"><a href="#11-1-1介绍" class="headerlink" title="11.1.1介绍"></a>11.1.1介绍</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">RPM</span> 是 <span class="hljs-built_in">Red</span><span class="hljs-operator">-</span><span class="hljs-variable">Hat</span> <span class="hljs-built_in">Package</span> <span class="hljs-variable">Manager</span>（红帽软件包管理器）的缩写<br>这一文件格式名称虽然打上了<span class="hljs-variable">RedHat</span>的标志，但是其原始设计理念是开放式的，<br>包括<span class="hljs-variable">OpenLinux</span>、<span class="hljs-variable">S</span><span class="hljs-operator">.</span><span class="hljs-variable">u</span><span class="hljs-operator">.</span><span class="hljs-variable">S</span><span class="hljs-operator">.</span><span class="hljs-built_in">E</span><span class="hljs-operator">.</span>以及<span class="hljs-variable">Turbo</span> <span class="hljs-variable">Linux</span>等<span class="hljs-variable">Linux</span>的分发版本都有采用，可以算是公认的行业标准了。<br><br>是一种用于互联网下载包的打包及安装工具，它包含在某些<span class="hljs-variable">Linux</span>分发版中。它生成具有<span class="hljs-operator">.</span><span class="hljs-variable">RPM</span>扩展名的文件。<br><br>类似于 <span class="hljs-variable">windows</span> 的 <span class="hljs-variable">setup</span><span class="hljs-operator">.</span><span class="hljs-variable">exe</span><br></code></pre></td></tr></table></figure><h4 id="11-1-2rpm-的简单查询指令"><a href="#11-1-2rpm-的简单查询指令" class="headerlink" title="11.1.2rpm 的简单查询指令"></a>11.1.2rpm 的简单查询指令</h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs llvm">查询已安装的 rpm软件包 列表：<br>rpm –qa|grep xx <br>查询结果返回一个软件包的包名<br><br>举例：查看当前系统是否安装了 firefox <br>指令: rpm -qa | grep firefox<br>查询结果：firefox<span class="hljs-number">-60.2</span>.<span class="hljs-number">2</span><span class="hljs-number">-1</span>.el<span class="hljs-number">7</span>.centos.<span class="hljs-keyword">x</span><span class="hljs-number">86</span>_<span class="hljs-number">64</span><br>结果说明：<br>软件名：firefox<br>版本号：<span class="hljs-number">60.2</span>.<span class="hljs-number">2</span><span class="hljs-number">-1</span><br>适用操作系统: el<span class="hljs-number">7</span>.centos.<span class="hljs-keyword">x</span><span class="hljs-number">86</span>_<span class="hljs-number">64</span> (表示 centos<span class="hljs-number">7</span>.<span class="hljs-keyword">x</span> 的 <span class="hljs-number">64</span> 位系统)<br>如果是 <span class="hljs-type">i686</span>、<span class="hljs-type">i386</span> 表示 <span class="hljs-number">32</span> 位系统，noarch 表示通用(<span class="hljs-number">32</span>/<span class="hljs-number">64</span>位系统都适用)<br><br></code></pre></td></tr></table></figure><h4 id="11-1-3rpm-的其它查询指令"><a href="#11-1-3rpm-的其它查询指令" class="headerlink" title="11.1.3rpm 的其它查询指令"></a>11.1.3rpm 的其它查询指令</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vim">rpm -<span class="hljs-keyword">qa</span> (查询所安装的所有 rpm 软件包)<br><br>rpm -<span class="hljs-keyword">qa</span> | more  (分页显示more)<br><br>rpm -<span class="hljs-keyword">qa</span> | <span class="hljs-keyword">grep</span> <span class="hljs-keyword">X</span>    (过滤,比如 rpm -<span class="hljs-keyword">qa</span> | <span class="hljs-keyword">grep</span> firefox )<br><br><br>rpm -q  软件包名      (查询某个软件包是否安装)<br>案例：rpm -q firefox<br><br>rpm -qi 软件包名    (查询软件包的详细信息)<br>案例: rpm -qi firefox<br><br>rpm -ql 软件包名  (查询软件包中的文件和该软件包在哪个文件下)<br>案例： rpm -ql firefox<br><br>rpm -qf 文件全路径名  (查询某个文件所属在哪个软件包)<br>案例：rpm -qf /etc/passwd<br>案例：rpm -qf /root/install.<span class="hljs-built_in">log</span><br><br></code></pre></td></tr></table></figure><h4 id="11-1-4删除-rpm-软件包"><a href="#11-1-4删除-rpm-软件包" class="headerlink" title="11.1.4删除 rpm 软件包"></a>11.1.4删除 rpm 软件包</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs subunit">基本语法：rpm -e RPM软件包的名称//-e erase擦去<br>案例：删除 firefox 软件包<br>rpm -e firefox<br><br><br>注意：<br>(1)如果其它软件包依赖于您要删除的软件包，删除时则会产生错误信息。<br>如：<br>rpm -e foo<br>removing these packages would break dependencies:foo is needed by bar<span class="hljs-string">-1</span>.0<span class="hljs-string">-1</span><br>foo软件包被 bar<span class="hljs-string">-1</span>.0<span class="hljs-string">-1</span>需要，删除foo对barr<span class="hljs-string">-1</span>.0<span class="hljs-string">-1</span>有影响<br><br>(2)如果我们就是要删除 foo 这个 rpm 包，可以增加参数 --nodeps ,就可以强制删除<br>   但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行<br>如：rpm -e --nodeps foo            (nodeps 不检查依赖关系 no dependencies)<br><br></code></pre></td></tr></table></figure><h4 id="11-1-5安装-rpm-软件包"><a href="#11-1-5安装-rpm-软件包" class="headerlink" title="11.1.5安装 rpm 软件包"></a>11.1.5安装 rpm 软件包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk">基本语法：rpm -ivh RPM软件包全路径名称<br><br>rpm软件包其实是一个软件的安装包<br>点击Linux系统桌面的光盘，里面有一个Packages文件夹，这个文件夹里有很多rpm软件安装包<br><br>在<span class="hljs-regexp">/run/m</span>edia<span class="hljs-regexp">/root/</span>CentOS\ <span class="hljs-number">7</span>\ x86_64<span class="hljs-regexp">/Packages/</span> 目录下<br><br><br>选项：<br>i=install 安装<br>v=verbose 提示<br>h=hash  进度条<br><br><br>应用实例：<br>演示卸载和安装 firefox 浏览器<br>rpm -e firefox <br>rpm -ivh <span class="hljs-regexp">/run/m</span>edia<span class="hljs-regexp">/root/</span>CentOS\ <span class="hljs-number">7</span>\ x86_64<span class="hljs-regexp">/Packages/</span>firefox-<span class="hljs-number">60.2</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>.el7.centos.x86_64.rpm<br><br>也可以在Packages中找到firefox安装包，复制到某一个目录下，这样写路径简单<br><br></code></pre></td></tr></table></figure><h3 id="11-2yum"><a href="#11-2yum" class="headerlink" title="11.2yum"></a>11.2yum</h3><h4 id="11-2-1介绍"><a href="#11-2-1介绍" class="headerlink" title="11.2.1介绍"></a>11.2.1介绍</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Yum（全称为 Yellow dog Updater, Modified）是一个 Shell 前端软件包管理器。<br>基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，<br>可以自动处理依赖性关系，并且一次安装所有依赖的软件包。<br><br>使用 yum list<span class="hljs-string">|grep 软件名 向yum服务器查询有没有该软件</span><br>有的话，使用 yum install 软件名 下载安装该软件<br><br></code></pre></td></tr></table></figure><h4 id="11-2-2yum-的基本指令"><a href="#11-2-2yum-的基本指令" class="headerlink" title="11.2.2yum 的基本指令"></a>11.2.2yum 的基本指令</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 1c">查询 yum 服务器是否有 需要安装的软件：<br>yum list<span class="hljs-string">|grep 软件名</span><br><br>安装指定的软件：<br>yum install 软件名<br><br>案例：请使用 yum 的方式来安装 firefox <br>rpm -e firefox<br>yum list <span class="hljs-string">| grep firefox </span><br>yum install firefox<br><br></code></pre></td></tr></table></figure><h3 id="11-3总结"><a href="#11-3总结" class="headerlink" title="11.3总结"></a>11.3总结</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">rpm 是从本地安装包下载,本地必须有<span class="hljs-string">.rpm</span>文件才可使用<br>yum 是从yum服务器下载安装软件,可以直接下载<br></code></pre></td></tr></table></figure><h2 id="十二、Shell编程"><a href="#十二、Shell编程" class="headerlink" title="十二、Shell编程"></a>十二、Shell编程</h2><h3 id="12-1为什么要学习Shell-编程"><a href="#12-1为什么要学习Shell-编程" class="headerlink" title="12.1为什么要学习Shell 编程"></a>12.1为什么要学习Shell 编程</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(<span class="hljs-number">1</span>)Linux 运维工程师在进行服务器集群管理时，需要编写 <span class="hljs-keyword">Shell </span>程序来进行服务器管理。<br>(<span class="hljs-number">2</span>)对于 <span class="hljs-keyword">JavaEE </span>和 Python 程序员来说，工作的需要，你的老大会要求你编写一些 <span class="hljs-keyword">Shell </span>脚本进行程序或者是服务器的维护，比如编写一个定时备份数据库的脚本。<br>(<span class="hljs-number">3</span>)对于大数据程序员来说，需要编写 <span class="hljs-keyword">Shell </span>程序来管理集群<br></code></pre></td></tr></table></figure><h3 id="12-2Shell-是什么"><a href="#12-2Shell-是什么" class="headerlink" title="12.2Shell 是什么"></a>12.2Shell 是什么</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序。<br><br>在计算机科学中，Shell俗称壳（用来区别于核）<br>是指“为使用者提供操作界面”的软件（<span class="hljs-keyword">command</span> interpreter，命令解析器）。<br>它类似于DOS下的COMMAND.COM和后来的cmd.<span class="hljs-keyword">exe</span>。<br>它接收用户命令，然后调用相应的应用程序。<br><br>中文名壳<br>外文名<span class="hljs-keyword">shell</span><br>性质命令解析器<br>用途接收用户命令<br><br>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。是用户使用 Linux 的桥梁.<br><br>用户写了一个指令，该指令不能直接发给Linux内核去执行，而是由<span class="hljs-keyword">shell</span>帮我们去执行，执行完之后再通过<span class="hljs-keyword">shell</span>返回给我们结果。<br>在Linux中不止一种<span class="hljs-keyword">shell</span>，我们常用的是bash。<br>可以直接发一个指令给<span class="hljs-keyword">shell</span>，也可以将指令写在一个文件/脚本(.<span class="hljs-keyword">sh</span> <span class="hljs-keyword">shell</span>脚本)里。<br><span class="hljs-keyword">shell</span>编程就是在<span class="hljs-keyword">shell</span>脚本中写指令。<br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307201600658.png" alt="image-20230720160042573"></p><h3 id="12-3Shell-脚本"><a href="#12-3Shell-脚本" class="headerlink" title="12.3Shell 脚本"></a>12.3Shell 脚本</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>.脚本格式要求：<br>脚本以 #!/bin/bash 开头 ---&gt;确定<span class="hljs-keyword">shell</span>的类型<br>    脚本需要有可执行权限<br>    <span class="hljs-keyword">shell</span>脚本文件以.<span class="hljs-keyword">sh</span>结尾，也可以不以.<span class="hljs-keyword">sh</span>结尾<br><br><span class="hljs-number">2</span>.编写第一个Shell 脚本<br>需求说明：创建一个 Shell 脚本，输出 hello world! <br>创建一个目录：<span class="hljs-built_in">mkdir</span> /root/shcode<br><span class="hljs-keyword">cd</span> /root/shcode<br><span class="hljs-keyword">vim</span> hello.<span class="hljs-keyword">sh</span><br>写入：<br>#!/bin/bash<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;hello,world!&quot;</span><br><br><span class="hljs-number">3</span>.<span class="hljs-keyword">shell</span>脚本的常用执行方式<br>方式 <span class="hljs-number">1</span>：<br>首先要给<span class="hljs-keyword">shell</span>脚本加<span class="hljs-keyword">x</span>执行权限：chomod <span class="hljs-keyword">u</span>+<span class="hljs-keyword">x</span> hello.<span class="hljs-keyword">sh</span><br>再输入该脚本的相对路径或绝对路径来执行该脚本<br>    比如：<br> 使用相对路径：./hello.<span class="hljs-keyword">sh</span> <br> 使用绝对路径：/root/shcode/hello.<span class="hljs-keyword">sh</span><br><br>方式 <span class="hljs-number">2</span>：<br>不用赋予脚本+<span class="hljs-keyword">x</span> 权限，直接执行即可。(使用以下指令，即使没有执行权限也可以执行)<br>使用指令： <span class="hljs-keyword">sh</span>  <span class="hljs-keyword">shell</span>脚本/<span class="hljs-keyword">shell</span>脚本的绝对路径<br>比如<span class="hljs-keyword">sh</span> hello.<span class="hljs-keyword">sh</span> <br></code></pre></td></tr></table></figure><h3 id="12-4-Shell-的变量"><a href="#12-4-Shell-的变量" class="headerlink" title="12.4 Shell 的变量"></a>12.4 Shell 的变量</h3><h4 id="12-4-1Shell-变量介绍"><a href="#12-4-1Shell-变量介绍" class="headerlink" title="12.4.1Shell 变量介绍"></a>12.4.1Shell 变量介绍</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">(1)Linux Shell 中的变量分为:系统变量和用户自定义变量。<br>系统变量：系统自带的变量<br><br>(2)系统变量比如：<span class="hljs-variable">$HOME</span>、<span class="hljs-variable">$PWD</span>、<span class="hljs-variable">$SHELL</span>、<span class="hljs-variable">$USER</span> 等等<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span>---&gt;显示当前用户的家目录<br><br>(3)可以通过 <span class="hljs-built_in">set</span> 指令显示出shell中的所有系统变量<br></code></pre></td></tr></table></figure><h4 id="12-4-2Shell-自定义变量"><a href="#12-4-2Shell-自定义变量" class="headerlink" title="12.4.2Shell 自定义变量"></a>12.4.2Shell 自定义变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs bash">基本语法：<br>(1)定义变量：变量名=值  ---&gt;不加空格<br>(2)撤销变量：<span class="hljs-built_in">unset</span> 变量名<br>(3)声明静态变量：<span class="hljs-built_in">readonly</span> 变量 (改变量不能 <span class="hljs-built_in">unset</span>撤销)<br><br><br>案例 1：定义变量 A<br>案例 2：撤销变量 A<br>案例 3：声明静态的变量 B=2，不能 <span class="hljs-built_in">unset</span><br><br><span class="hljs-built_in">cd</span> /root/shcode<br>vim vr.sh<br>输入： <br><span class="hljs-comment">#!/bin/bash</span><br><br><span class="hljs-comment">#案例 1：定义变量 A=100  (#为注释符)</span><br>A=100<br><span class="hljs-comment">#输出变量需要加上$ ($---&gt;引用变量)</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$A</span><br><br><span class="hljs-comment">#上述输出结果是100，想要输出结果为A=100，这样写(A=以普通文本形式输出，$A引用变量的值)</span><br><span class="hljs-built_in">echo</span> A=<span class="hljs-variable">$A</span> 或者 <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;A=<span class="hljs-variable">$A</span>&quot;</span> <br><br><br><span class="hljs-comment">#案例 2：撤销变量 A </span><br><span class="hljs-built_in">unset</span> A<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;A=<span class="hljs-variable">$A</span>&quot;</span>    (---&gt;输出 A= )<br><br><br><span class="hljs-comment">#案例 3：声明静态的变量 B=2，不能 unset </span><br><span class="hljs-built_in">readonly</span> B=2<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;B=<span class="hljs-variable">$B</span>&quot;</span> <br><br>保存：wq<br>最后输入执行命令：sh vr.sh<br><br>--------------------------------------------------------------------<br><br><br>shell 变量名的定义规则：<br>(1)变量名称可以由字母、数字和下划线组成，但是不能以数字开头。5A=200(×)<br>(2)等号两侧不能有空格<br>(3)变量名称一般习惯为大写，这是一个规范，我们遵守即可<br><br>--------------------------------------------------------------------<br>将命令的返回值赋给变量：<br>(1)A=`<span class="hljs-built_in">date</span>`反引号，运行里面的命令，并把结果返回给变量 A <br>(2)A=$(<span class="hljs-built_in">date</span>) 等价于反引号<br>PS:反引号在数字1的左边<br><br>案例：<br><span class="hljs-comment">#将指令返回的结果赋给变量</span><br>C=`<span class="hljs-built_in">date</span>` <br>D=$(<span class="hljs-built_in">date</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;C=<span class="hljs-variable">$C</span>&quot;</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;D=<span class="hljs-variable">$D</span>&quot;</span><br><br><span class="hljs-comment">#使用环境变量 TOMCAT_HOME</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;tomcat_home=<span class="hljs-variable">$TOMCAT_HOME</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="12-5设置环境变量-全局变量"><a href="#12-5设置环境变量-全局变量" class="headerlink" title="12.5设置环境变量(全局变量)"></a>12.5设置环境变量(全局变量)</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vim">可以将变量提升为全局环境变量，供多个<span class="hljs-keyword">shell</span>程序共同使用。<br><br>基本语法：<br>(<span class="hljs-number">1</span>)export 变量名=变量值 <br>（功能描述：将 <span class="hljs-keyword">shell</span> 变量输出为环境变量/全局变量）<br><br>(<span class="hljs-number">2</span>)<span class="hljs-keyword">source</span> 配置文件    <br>（功能描述：在某文件中定义环境变量之后，要对该文件进行刷新才能使其生效，即让修改后的配置信息立即生效）<br><br>(<span class="hljs-number">3</span>)<span class="hljs-keyword">echo</span> $变量名<br>（功能描述：查询环境变量的值）<br><br><br>快速入门：<br>(<span class="hljs-number">1</span>)在/etc/<span class="hljs-keyword">profile</span> 文件中定义 TOMCAT_HOME 环境变量<br>TOMCAT_HOME ---&gt;意思是tomcat的家目录是什么<br>(<span class="hljs-number">2</span>)查看环境变量 TOMCAT_HOME 的值<br><span class="hljs-keyword">vim</span> /etc/<span class="hljs-keyword">profile</span><br>写入：export TOMCAT_HOME=/<span class="hljs-keyword">opt</span>/tomcat<br>保存退出<br><span class="hljs-keyword">source</span> /etc/<span class="hljs-keyword">profile</span><br><span class="hljs-keyword">echo</span> $TOMCAT_HOME ---输出 /<span class="hljs-keyword">opt</span>/tomcat<br><br><br>(<span class="hljs-number">3</span>)在另外一个 <span class="hljs-keyword">shell</span> 程序中使用 TOMCAT_HOME<br>在另一个<span class="hljs-keyword">shell</span>程序中写入：<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;tomcat_home=$TOMCAT_HOME&quot;</span><br><br><br>注意：在输出 TOMCAT_HOME 环境变量前，需要让其生效<span class="hljs-keyword">source</span> /etc/<span class="hljs-keyword">profile</span><br><br><br><span class="hljs-keyword">shell</span> 脚本的<br>单行注释：#<br>多行注释：   :&lt;&lt;!   独占一行<br>内容 <br>    !    独占一行<br></code></pre></td></tr></table></figure><h3 id="12-6位置参数变量"><a href="#12-6位置参数变量" class="headerlink" title="12.6位置参数变量"></a>12.6位置参数变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.介绍<br>当我们执行一个 shell 脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量<br>比如： ./myshell.sh 100 200 这个就是一个执行 shell 的命令行，可以在 myshell 脚本中获取到参数信息<br><br>./myshell.sh ---&gt;执行myshell脚本命令<br>100 200 都是该命令行的参数<br>使用位置参数变量可以在myshell脚本中获得参数<br><br><br>2.基本语法<br><span class="hljs-variable">$n</span> （功能描述：n 为数字，<span class="hljs-variable">$0</span> 代表命令本身(如./myshell.sh)，<span class="hljs-variable">$1</span>-<span class="hljs-variable">$9</span> 代表第一到第九个参数(如：<span class="hljs-variable">$1</span> 就是100 <span class="hljs-variable">$2</span> 就是200)，十以上的参数需要用大括号包含，如<span class="hljs-variable">$&#123;10&#125;</span>）<br>$* （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）<br><span class="hljs-variable">$@</span> （功能描述：这个变量也代表命令行中所有的参数，不过<span class="hljs-variable">$@</span>把每个参数区分对待）<br><span class="hljs-variable">$#</span> （功能描述：这个变量代表命令行中所有参数的个数）<br><br>案例：编写一个 shell 脚本 myshell.sh ，在脚本中获取到命令行的各个参数信息。<br>vim myshell.sh<br>写入:<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;命令本身=<span class="hljs-variable">$0</span> 第一个参数=<span class="hljs-variable">$1</span> 第二个参数=<span class="hljs-variable">$2</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;所有的参数=$*&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;参数个数=<span class="hljs-variable">$#</span>&quot;</span><br>保存退出<br>sh myshell.sh 100 200<br></code></pre></td></tr></table></figure><h3 id="12-7预定义变量"><a href="#12-7预定义变量" class="headerlink" title="12.7预定义变量"></a>12.7预定义变量</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>.基本介绍：<br>预定义变量是 <span class="hljs-keyword">shell</span> 设计者事先已经定义好的变量，可以直接在 <span class="hljs-keyword">shell</span> 脚本中使用<br><br><br><span class="hljs-number">2</span>.基本语法：<br>(<span class="hljs-number">1</span>)$$ （功能描述：当前进程的进程号（PID））<br>(<span class="hljs-number">2</span>)$! （功能描述：后台运行的最后一个进程的进程号（PID））<br>(<span class="hljs-number">3</span>)$？（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为 <span class="hljs-number">0</span>，证明上一个命令正确执行；如果这个变量的值为非 <span class="hljs-number">0</span>（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）<br><br><span class="hljs-number">3</span>.应用实例：<br>在一个 <span class="hljs-keyword">shell</span> 脚本中简单使用一下预定义变量<br><br><span class="hljs-keyword">vim</span> preVar.<span class="hljs-keyword">sh</span><br>写入：<br>#!/bin/bash<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;当前执行的进程 id=$$&quot;</span><br><br>#以后台的方式运行一个脚本(在脚本后加一个$)，并获取他的进程号<br>/root/shcode/myshell.<span class="hljs-keyword">sh</span> &amp;<br><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;最后一个后台方式运行的进程 id=$!&quot;</span> <br><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;执行的结果是=$?&quot;</span><br>保存并退出<br><span class="hljs-keyword">sh</span> preVar.<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><h3 id="12-8运算符"><a href="#12-8运算符" class="headerlink" title="12.8运算符"></a>12.8运算符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.基本介绍：<br>学习如何在 shell 中进行各种运算操作。<br><br><br>2.基本语法：<br>(1)三种写法：<br>$((运算式))<br>$[运算式]<br><span class="hljs-built_in">expr</span> m + n (expression 表达式)<br> <br>(2)注意 <span class="hljs-built_in">expr</span> 运算符间要有空格<br>如果希望将 <span class="hljs-built_in">expr</span> 的结果赋给某个变量，使用 `` 或者 $( )<br><br>(3)<span class="hljs-built_in">expr</span> m - n<br><br>(4)<span class="hljs-built_in">expr</span> \*, /, %乘，除，取余<br><br><br>3.应用实例 oper.sh<br>案例 1：计算（2+3）X4 的值<br>案例 2：请求出命令行的两个参数[整数]的和 20 50<br><br>vim oper.sh<br>写入:<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#案例 1：计算（2+3）X4 的值</span><br><span class="hljs-comment">#使用第一种方式</span><br>RES1=$(((<span class="hljs-number">2</span>+<span class="hljs-number">3</span>)*<span class="hljs-number">4</span>))        ---&gt;用一个变量RES1接收<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;res1=<span class="hljs-variable">$RES1</span>&quot;</span><br>保存并退出<br>sh oper.sh<br><br>vim oper.sh<br>写入:<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#使用第二种方式, 推荐使用</span><br>RES2=$[(2+3)*4]<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;res2=<span class="hljs-variable">$RES2</span>&quot;</span><br>保存并退出<br>sh oper.sh<br><br>vim oper.sh<br>写入:<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#使用第三种方式 expr </span><br>TEMP=`<span class="hljs-built_in">expr</span> 2 + 3`       <br>RES4=`<span class="hljs-built_in">expr</span> <span class="hljs-variable">$TEMP</span> \* 4` <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;temp=<span class="hljs-variable">$TEMP</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;res4=<span class="hljs-variable">$RES4</span>&quot;</span><br>保存并退出<br>sh oper.sh<br><br>vim oper.sh<br>写入:<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#案例 2：请求出命令行的两个参数[整数]的和 20 50 </span><br>SUM=$[<span class="hljs-variable">$1</span>+<span class="hljs-variable">$2</span>]<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;sum=<span class="hljs-variable">$SUM</span>&quot;</span><br>保存并退出<br>sh oper.sh 20 50<br></code></pre></td></tr></table></figure><h3 id="12-9条件判断"><a href="#12-9条件判断" class="headerlink" title="12.9条件判断"></a>12.9条件判断</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.基本语法：<br>[ condition ] （注意 condition 前后要有空格）<br><span class="hljs-comment">#非空返回 true，可使用$?验证（0 为 true，&gt;1 为 false）</span><br><br><br>2.应用实例：<br>[ hspEdu ]返回 <span class="hljs-literal">true</span> <br>[ ]返回 <span class="hljs-literal">false</span><br>[ condition ] &amp;&amp; <span class="hljs-built_in">echo</span> OK || <span class="hljs-built_in">echo</span> notok条件满足，执行后面的语句<br><br><br>3.判断语句：<br>常用判断条件：<br>(1) = 字符串比较<br>(2)两个整数的比较<br>-lt 小于     less than<br>-le 小于等于  less equal<br>-eq 等于      equal<br>-gt 大于      greater<br>-ge 大于等于   greater equal<br>-ne 不等于     not equal<br>(3)按照文件权限进行判断<br>-r 有读的权限<br>-w 有写的权限<br>-x 有执行的权限<br>(4)按照文件类型进行判断<br>-f 文件存在并且是一个常规的文件<br>-e 文件存在<br>-d 文件存在并是一个目录<br><br><br>4.应用实例：<br>案例 1：<span class="hljs-string">&quot;ok&quot;</span>是否等于<span class="hljs-string">&quot;ok&quot;</span><br>判断语句：使用 =<br>案例 2：23 是否大于等于 22<br>判断语句：使用 -ge<br>案例 3：/root/shcode/aaa.txt 目录中的文件是否存在<br>判断语句： 使用 -f<br><br>代码如下:<br>vim ifdemo.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#案例 1：&quot;ok&quot;是否等于&quot;ok&quot;</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;ok&quot;</span> = <span class="hljs-string">&quot;ok&quot;</span>  ]<br><span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;equal&quot;</span><br><span class="hljs-keyword">fi</span>                    -----&gt; <span class="hljs-keyword">if</span>语句 以<span class="hljs-keyword">if</span>开头 以<span class="hljs-keyword">fi</span>结尾<br><br><span class="hljs-comment">#案例 2：23 是否大于等于 22</span><br><span class="hljs-comment">#判断语句：使用 -ge</span><br><span class="hljs-keyword">if</span> [ 23 -ge 22 ]<br><span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;大于&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment">#案例 3：/root/shcode/aaa.txt 目录中的文件是否存在</span><br><span class="hljs-comment">#判断语句： 使用 -f</span><br><span class="hljs-keyword">if</span> [ -f  /root/shcode/aaa.txt ]<br><span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件存在&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment">#看几个案例</span><br><span class="hljs-keyword">if</span> [ ]<br><span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;存在&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ hspEdu01 ]<br><span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello hspEdu01&quot;</span><br><span class="hljs-keyword">fi</span><br>sh ifdemo.sh<br><br>输出结果：<br>equal<br>大于<br>hello hspEdu01<br></code></pre></td></tr></table></figure><h3 id="12-10流程控制"><a href="#12-10流程控制" class="headerlink" title="12.10流程控制"></a>12.10流程控制</h3><h4 id="12-10-1if-语句"><a href="#12-10-1if-语句" class="headerlink" title="12.10.1if 语句"></a>12.10.1if 语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.基本语法：<br><span class="hljs-keyword">if</span> [ 条件判断式 ] <br><span class="hljs-keyword">then</span><br>代码<br><span class="hljs-keyword">fi</span><br><br>或者 多分支<br><br><span class="hljs-keyword">if</span> [ 条件判断式 ] <br><span class="hljs-keyword">then</span><br>代码<br><span class="hljs-keyword">elif</span> [条件判断式] <br><span class="hljs-keyword">then</span><br>代码<br><span class="hljs-keyword">fi</span><br><br>2.注意事项：[ 条件判断式 ]，中括号和条件判断式之间必须有空格<br><br>3.应用实例 ifCase.sh<br>案例：请编写一个 shell 程序，如果输入的参数，大于等于 60，则输出 <span class="hljs-string">&quot;及格了&quot;</span>，如果小于 60,则输出 <span class="hljs-string">&quot;不及格&quot;</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> -ge 60 ]<br><span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;及格了&quot;</span><br><span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;不及格&quot;</span><br><span class="hljs-keyword">fi</span><br><br>或者<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> -ge 60 ]<br><span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;及格了&quot;</span><br><span class="hljs-keyword">elif</span>[ <span class="hljs-variable">$1</span> -lt 60]<br><span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;不及格&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h4 id="12-10-2case-语句"><a href="#12-10-2case-语句" class="headerlink" title="12.10.2case 语句"></a>12.10.2case 语句</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.基本语法：<br><br>case $变量名 in<br><span class="hljs-string">&quot;值 1&quot;</span>)<br>如果变量的值等于值 <span class="hljs-number">1</span>，则执行程序 <span class="hljs-number">1</span><br><span class="hljs-comment">;;</span><br><span class="hljs-string">&quot;值 2&quot;</span>)<br>如果变量的值等于值 <span class="hljs-number">2</span>，则执行程序 <span class="hljs-number">2</span><br><span class="hljs-comment">;;</span><br>…省略其他分支…<br><br>*)<br>如果变量的值都不是以上的值，则执行此程序<br><span class="hljs-comment">;;</span><br>esac<br><br>应用实例 testCase.<span class="hljs-keyword">sh</span><br><span class="hljs-keyword"></span>案例<span class="hljs-number">1</span>：当命令行参数是<span class="hljs-number">1</span>时，输出 <span class="hljs-string">&quot;周一&quot;</span>, 是<span class="hljs-number">2</span>时，就输出<span class="hljs-string">&quot;周二&quot;</span>，其它情况输出<span class="hljs-string">&quot;other&quot;</span><br>vim testCase.<span class="hljs-keyword">sh</span><br><span class="hljs-keyword"></span>写入：<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#案例1：当命令行参数是1时，输出 &quot;周一&quot;, 是2时，就输出&quot;周二&quot;，其它情况输出&quot;other&quot;</span><br>case $<span class="hljs-number">1</span> in<br><span class="hljs-string">&quot;1&quot;</span>)<br>echo <span class="hljs-string">&quot;周一&quot;</span><br><span class="hljs-comment">;;</span><br><span class="hljs-string">&quot;2&quot;</span>)<br>echo <span class="hljs-string">&quot;周二&quot;</span><br><span class="hljs-comment">;;</span><br>*)<br>echo <span class="hljs-string">&quot;other...&quot;</span><br><span class="hljs-comment">;;</span><br>esac<br>保存并退出<br><br><span class="hljs-keyword">sh </span>testCase.<span class="hljs-keyword">sh </span><span class="hljs-number">1</span><br>周一<br></code></pre></td></tr></table></figure><h4 id="12-10-3for-循环"><a href="#12-10-3for-循环" class="headerlink" title="12.10.3for 循环"></a>12.10.3for 循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs bash">基本语法：<br><br>第一种方式：<br><br><span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span>  值 1  值 2  值 3… <br><span class="hljs-keyword">do</span><br>程序/代码<br><span class="hljs-keyword">done</span><br><br>应用实例 testFor1.sh<br>案例：打印命令行输入的参数 [这里可以看出$*  和 <span class="hljs-variable">$@</span> 的区别]<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#案例：打印命令行输入的参数 [这里可以看出$*  和 $@ 的区别]</span><br><span class="hljs-comment">#注意：$* 是把输入的参数当作一个整体，所以只会输出一句话</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;$*&quot;</span><br><span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;num is $*&quot;</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment">#使用 $@ 来获取输入的参数，注意：也是把输入的参数看作一个整体，但这是分别对待；所以有几个参数就输出几句</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;======================================&quot;</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;num is <span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-keyword">done</span><br><br>sh testFor1.sh 100 200 300<br>num is 100 200 300<br>======================================<br>num is 100 200 300<br>num is 100 200 300<br>num is 100 200 300<br><br><br><br><br><br>第二种方式：<br><br><span class="hljs-keyword">for</span> (( 初始值;循环控制条件;变量变化 ))<br><span class="hljs-keyword">do</span><br>程序/代码<br><span class="hljs-keyword">done</span><br><br>应用实例 testFor2.sh<br>案例：从 1 加到 100 的值输出显示<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#案例：从 1 加到 100 的值输出显示</span><br><span class="hljs-comment">#定义一个变量SUM</span><br>SUM=0<br><span class="hljs-keyword">for</span>(( i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">100</span>; i++  ))<br><span class="hljs-keyword">do</span><br>        SUM=$[<span class="hljs-variable">$SUM</span>+<span class="hljs-variable">$i</span>]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;总和SUM=<span class="hljs-variable">$SUM</span>&quot;</span><br><br>sh testFor2.sh <br>总和SUM=5050<br><br>如果1加到x x由自己输入<br>SUM=0<br><span class="hljs-keyword">for</span>(( i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-variable">$1</span>; i++  ))<br><span class="hljs-keyword">do</span><br>        SUM=$[<span class="hljs-variable">$SUM</span>+<span class="hljs-variable">$i</span>]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;总和SUM=<span class="hljs-variable">$SUM</span>&quot;</span><br><br>sh textFor2.sh 1000<br>总和SUM=500500<br></code></pre></td></tr></table></figure><h4 id="12-10-4while-循环"><a href="#12-10-4while-循环" class="headerlink" title="12.10.4while 循环"></a>12.10.4while 循环</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs routeros">基本语法：<br><span class="hljs-keyword">while</span> [ 条件判断式 ]<br><span class="hljs-keyword">do</span><br>程序/代码<br>done<br><br>注意：<span class="hljs-keyword">while</span> 和 [有空格，条件判断式和[  ]也有空格<br> <br>应用实例：testWhile.sh<br>案例：从命令行输入一个数 n，统计从 1+<span class="hljs-built_in">..</span>+ n  的值是多少？<br>#!/bin/bash<br><span class="hljs-attribute">SUM</span>=0<br><span class="hljs-attribute">i</span>=0<br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$i</span> -le <span class="hljs-variable">$1</span> ] <br><span class="hljs-keyword">do</span><br><span class="hljs-attribute">SUM</span>=$[<span class="hljs-variable">$SUM</span>+<span class="hljs-variable">$i</span>]<br>#i 自增<br><span class="hljs-attribute">i</span>=$[<span class="hljs-variable">$i</span>+1]<br>done<br>echo <span class="hljs-string">&quot;执行结果=<span class="hljs-variable">$SUM</span>&quot;</span><br><br>sh testWhile.sh 100<br>执行结果=5050<br></code></pre></td></tr></table></figure><h3 id="12-11read-读取控制台输入"><a href="#12-11read-读取控制台输入" class="headerlink" title="12.11read 读取控制台输入"></a>12.11read 读取控制台输入</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1.</span>基本语法：<br>read<span class="hljs-comment">(选项)</span><span class="hljs-comment">(参数)</span><br>选项：<br>-p：指定读取值时的提示符；<br>-t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了<br>参数：<br>变量：指定读取值的变量名<br><br><span class="hljs-number">2.</span>应用实例 testRead.sh<br>案例 <span class="hljs-number">1</span>：读取控制台输入一个 <span class="hljs-symbol">NUM1</span> 值<br>案例 <span class="hljs-number">2</span>：读取控制台输入一个 <span class="hljs-symbol">NUM2</span> 值，在 <span class="hljs-number">10</span> 秒内输入。代码:<br><br><span class="hljs-attr">#!/bin/bash</span><br><span class="hljs-attr">#案例 1</span>：读取控制台输入一个 <span class="hljs-symbol">NUM1</span> 值<br>read -p <span class="hljs-string">&quot;请输入一个数 NUM1=&quot;</span> <span class="hljs-symbol">NUM1</span> <br>echo <span class="hljs-string">&quot;你输入的 NUM1=$NUM1&quot;</span><br><br><span class="hljs-attr">#案例 2</span>：读取控制台输入一个 <span class="hljs-symbol">NUM2</span> 值，在 <span class="hljs-number">10</span> 秒内输入。<br>read -t <span class="hljs-number">10</span> -p <span class="hljs-string">&quot;请输入一个数 NUM2=&quot;</span> <span class="hljs-symbol">NUM2</span> <br>echo <span class="hljs-string">&quot;你输入的 NUM2=$NUM2&quot;</span><br><br>sh testRead.sh<br>请输入一个数 <span class="hljs-symbol">NUM1</span>=<span class="hljs-number">100</span><br>你输入的 <span class="hljs-symbol">NUM1</span>=<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="12-12函数"><a href="#12-12函数" class="headerlink" title="12.12函数"></a>12.12函数</h3><h4 id="12-12-1函数介绍"><a href="#12-12-1函数介绍" class="headerlink" title="12.12.1函数介绍"></a>12.12.1函数介绍</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><span class="language-bash"> 编程和其它编程语言一样，有系统函数，也可以自定义函数。系统函数中，我们这里就介绍两个。</span><br></code></pre></td></tr></table></figure><h4 id="12-12-2系统函数"><a href="#12-12-2系统函数" class="headerlink" title="12.12.2系统函数"></a>12.12.2系统函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.<span class="hljs-built_in">basename</span> 基本语法<br>功能：返回完整路径最后 / 的部分，常用于获取文件名<br><span class="hljs-built_in">basename</span> [pathname] [suffix]<br><span class="hljs-built_in">basename</span> [string] [suffix]<br><br>功能描述：<span class="hljs-built_in">basename</span> 命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。<br>选项：suffix 为后缀，如果 suffix 被指定了，<span class="hljs-built_in">basename</span> 会将 pathname 或 string 中的 suffix 去掉。<br><br>案例 1：请返回 /home/aaa/test.txt 的 <span class="hljs-string">&quot;test.txt&quot;</span> 部分<br><span class="hljs-built_in">basename</span> /home/aaa/test.txt<br>返回test.txt<br><br>如果输入：<span class="hljs-built_in">basename</span> /home/aaa/test.txt .txt<br>返回<span class="hljs-built_in">test</span><br><br><br>2.<span class="hljs-built_in">dirname</span> 基本语法<br>功能：返回完整路径最后 / 的前面的部分，常用于返回路径部分<br><span class="hljs-built_in">dirname</span> 文件绝对路径 <br><br>功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）<br><br>案例 1：请返回 /home/aaa/test.txt 的 /home/aaa <br><span class="hljs-built_in">dirname</span> /home/aaa/test.txt<br>返回/home/aaa<br></code></pre></td></tr></table></figure><h4 id="12-12-3自定义函数"><a href="#12-12-3自定义函数" class="headerlink" title="12.12.3自定义函数"></a>12.12.3自定义函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">基本语法：<br>[ <span class="hljs-keyword">function</span> ] funname[()]<br>&#123;<br>Action; <br>[<span class="hljs-built_in">return</span> int;]<br>&#125;<br><br>调用直接写函数名：funname[值]<br><br><br>案例 1：计算输入两个参数的和(动态的获取) testFun.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#案例 1：计算输入两个参数的和(动态的获取)</span><br><br><span class="hljs-comment">#定义函数 getSum </span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">getSum</span></span>() &#123;<br>SUM=$[<span class="hljs-variable">$n1</span>+<span class="hljs-variable">$n2</span>] <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;和是=<span class="hljs-variable">$SUM</span>&quot;</span><br>&#125;<br><br><span class="hljs-comment">#输入两个值</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;请输入一个数 n1=&quot;</span> n1 <br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;请输入一个数 n2=&quot;</span> n2<br><br><span class="hljs-comment">#调用自定义函数</span><br>getSum <span class="hljs-variable">$n1</span> <span class="hljs-variable">$n2</span><br><br><br>sh testFun.sh <br>请输入一个数 n1=10<br>请输入一个数 n2=90<br>和是=100<br></code></pre></td></tr></table></figure><h3 id="12-13Shell-编程综合案例"><a href="#12-13Shell-编程综合案例" class="headerlink" title="12.13Shell 编程综合案例"></a>12.13Shell 编程综合案例</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1.</span>需求分析:<br><span class="hljs-comment">(1)</span>每天凌晨 <span class="hljs-number">2</span>:<span class="hljs-number">30</span> 备份 数据库 hspedu 到 /data/backup/db<br><span class="hljs-comment">(2)</span>备份开始和备份结束能够给出相应的提示信息<br><span class="hljs-comment">(3)</span>备份后的文件要求以备份时间为文件名，并打包成 .tar.gz 的形式，比如：<span class="hljs-number">2021</span><span class="hljs-number">-03</span><span class="hljs-number">-12</span>_<span class="hljs-number">230201.</span>tar.gz<br><span class="hljs-comment">(4)</span>在备份的同时，检查是否有 <span class="hljs-number">10</span> 天前备份的数据库文件，如果有就将其删除。<br><span class="hljs-comment">(5)</span>画一个思路分析图<br></code></pre></td></tr></table></figure><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307201602816.png" alt="image-20230720160235708"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs bash">2.代码 <br>切换到/usr/sbin/目录下(该目录为root用户执行权限，使用root执行)<br>vim mysql_db.backup.sh<br>写入：<br><span class="hljs-comment">#备份目录</span><br>BACKUP=/data/backup/db<br><br><span class="hljs-comment">#当前时间</span><br>DATETIME=$(<span class="hljs-built_in">date</span> +%Y-%m-%d_%H%M%S)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$DATETIME</span><br><br><span class="hljs-comment">#数据库的地址</span><br>HOST=localhost<br><br><span class="hljs-comment">#数据库用户名</span><br>DB_USER=root<br><br><span class="hljs-comment">#数据库密码</span><br>DB_PW=hspedu100<br><br><span class="hljs-comment">#备份的数据库名</span><br>DATABASE=hspedu<br><br><span class="hljs-comment">#创建备份目录, 如果不存在，就创建（这个应该可以用if语句写）</span><br>[ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span>&quot;</span><br><br><span class="hljs-comment">#备份数据库</span><br>mysqldump-u<span class="hljs-variable">$&#123;DB_USER&#125;</span>-p<span class="hljs-variable">$&#123;DB_PW&#125;</span>--host=<span class="hljs-variable">$&#123;HOST&#125;</span>-q-R--databases<span class="hljs-variable">$&#123;DATABASE&#125;</span>| gzip &gt; <span class="hljs-variable">$&#123;BACKUP&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span>/<span class="hljs-variable">$DATETIME</span>.sql.gz<br><br><br><span class="hljs-comment">#将文件处理成 tar.gz </span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$&#123;BACKUP&#125;</span><br>tar -zcvf <span class="hljs-variable">$DATETIME</span>.tar.gz <span class="hljs-variable">$&#123;DATETIME&#125;</span><br><br><span class="hljs-comment">#删除对应的备份目录</span><br><span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$&#123;BACKUP&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span><br><br><span class="hljs-comment">#删除 10 天前的备份文件</span><br><span class="hljs-comment">#查找BACKUP目录下10天前的备份文件 备份文件名字为 *.tar.gz 如果有删除</span><br>find <span class="hljs-variable">$&#123;BACKUP&#125;</span> -atime +10 -name <span class="hljs-string">&quot;*.tar.gz&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> -rf &#123;&#125; \;<br>该命令中的<span class="hljs-string">&quot;&#123;&#125;&quot;</span>是返回find命令找到的文件目录<br><span class="hljs-string">&quot;\;&quot;</span> 是用于标记 -<span class="hljs-built_in">exec</span> 选项的结束符。它告诉 find 命令在处理完每个文件后结束 -<span class="hljs-built_in">exec</span> 后面的命令。需要注意的是，\; 前面的反斜杠 \ 是用于转义分号 ;，以防止 Shell 错误地解析为命令分隔符。<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;备份数据库<span class="hljs-variable">$&#123;DATABASE&#125;</span> 成功~&quot;</span><br><br>保存并退出<br><br>sh /user/sbin/mysql_db.backup.sh<br><br>&#123;&#125; ---&gt;应该可以不用写<br><br>定时：<br>crontab -e<br>30 2 * * * /user/sbin/mysql_db.backup.sh<br>保存并退出<br></code></pre></td></tr></table></figure><h2 id="十三、Ubuntu操作实例"><a href="#十三、Ubuntu操作实例" class="headerlink" title="十三、Ubuntu操作实例"></a>十三、Ubuntu操作实例</h2><h3 id="13-1apt相关命令"><a href="#13-1apt相关命令" class="headerlink" title="13.1apt相关命令"></a>13.1apt相关命令</h3><ul><li><p>apt：Advanced Packaging Tool，是一款安装包管理工具。在Ubuntu下，我们可以使用apt命令进行软件包的安装、删除、清理等。</p></li><li><p>常用命令：</p><p>sudo apt-get update更新源</p><p>sudo apt-get install package 安装包</p><p>sudo apt-get remove package 删除包</p><p>sudo apt-cache search package 搜索软件包</p><p>sudo apt-cache show package获取包的相关信息,如说明、大小、版本等</p><p>sudo apt-get install package –reinstall  重新安装包</p><p>sudo apt-get -f install  修复安装</p><p>sudo apt-get remove package –purge 删除包包括配置文件</p><p>sudo apt-get build-dep package安装相关编译环境</p><p>sudo apt-get upgrade 更新已安装的包</p><p>sudo apt-get dist-upgrade升级系统</p><p>sudo apt-cache depends package了解使用该包依赖哪些包</p><p>sudo apt-cache rdepends package 查看该包被哪些包依赖</p><p>sudo apt-get source package 下载该包的源代码</p><p>修改镜像源文件&#x2F;etc&#x2F;apt&#x2F;source.list</p><p>查看Ubuntu版本cat&#x2F;proc&#x2F;version</p></li></ul><h3 id="13-2SSH远程登录"><a href="#13-2SSH远程登录" class="headerlink" title="13.2SSH远程登录"></a>13.2SSH远程登录</h3><h4 id="13-2-1Windows远程登录Ubuntu"><a href="#13-2-1Windows远程登录Ubuntu" class="headerlink" title="13.2.1Windows远程登录Ubuntu"></a>13.2.1Windows远程登录Ubuntu</h4><ul><li><p>​安装SSHsudo apt-get install openssh-server</p></li><li><p>​启用SSHsystemctl start sshd</p></li></ul><h4 id="13-2-2Linux远程登录Ubuntu"><a href="#13-2-2Linux远程登录Ubuntu" class="headerlink" title="13.2.2Linux远程登录Ubuntu"></a>13.2.2Linux远程登录Ubuntu</h4><ul><li>​安装和启用同上</li><li>​基本语法：ssh 用户名@IP</li><li>​例如：ssh <a href="mailto:&#107;&#108;&#97;&#121;&#64;&#x31;&#x39;&#50;&#46;&#x31;&#54;&#56;&#46;&#49;&#56;&#x38;&#x2e;&#49;&#51;&#48;">&#107;&#108;&#97;&#121;&#64;&#x31;&#x39;&#50;&#46;&#x31;&#54;&#56;&#46;&#49;&#56;&#x38;&#x2e;&#49;&#51;&#48;</a></li><li>​使用ssh访问，如出现访问错误。可查看是否有改文件 ~&#x2F;.ssh&#x2F;known_ssh,尝试删除该文件解决问题</li><li>​退出：exit或logout</li></ul><h3 id="13-3给root用户设置密码并使用"><a href="#13-3给root用户设置密码并使用" class="headerlink" title="13.3给root用户设置密码并使用"></a>13.3给root用户设置密码并使用</h3><ul><li>​输入sudo passwd命令，设定root用户密码</li><li>​设定root密码成功后，输入 su root，并输入刚才设定的root密码，就可以切换成root了。提示符$代表一般用户，提示符#代表root用户</li><li>​之后就可以使用root用户了</li><li>​输入exit命令，退出root并返回一般用户</li></ul><h2 id="十四、Linux日志管理"><a href="#十四、Linux日志管理" class="headerlink" title="十四、Linux日志管理"></a>十四、Linux日志管理</h2><h3 id="14-1基本介绍"><a href="#14-1基本介绍" class="headerlink" title="14.1基本介绍"></a>14.1基本介绍</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。<br><span class="hljs-comment">(2)</span>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。<br><span class="hljs-comment">(3)</span>可以这样理解 日志是用来记录重大事件的工具<br></code></pre></td></tr></table></figure><h3 id="14-2系统常用的日志"><a href="#14-2系统常用的日志" class="headerlink" title="14.2系统常用的日志"></a>14.2系统常用的日志</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">系统日志文件的保存位置：/<span class="hljs-keyword">var</span>/<span class="hljs-built_in">log</span>/ 目录下<br><br>应用案例：<br>使用 root 用户通过 xshell6 登陆，第一次使用错误的密码，第二次使用正确的密码登录成功看看在日志文件/<span class="hljs-keyword">var</span>/<span class="hljs-built_in">log</span>/secure 里有没有记录相关信息<br><br>系统常用日志：<br></code></pre></td></tr></table></figure><h3 id="14-3日志管理服务-rsyslogd"><a href="#14-3日志管理服务-rsyslogd" class="headerlink" title="14.3日志管理服务 rsyslogd"></a><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230725100909441.png" alt="image-20230725100909441">14.3日志管理服务 rsyslogd</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">CentOS7.<span class="hljs-number">6</span> 日志服务是 rsyslogd   (rocket-fast system <span class="hljs-keyword">for</span> log)<br>CentOS6.x 日志服务是 syslogd <br>rsyslogd 功能更强大<br>rsyslogd 的使用、日志文件的格式，和 syslogd 服务是兼容的<br><br>rsyslogd是一个后台程序(服务)，来管理<span class="hljs-regexp">/记录/</span>操作相关日志。<br>将日志记录到对应的文件中。<br><br><span class="hljs-regexp">/etc/</span>rsyslog.conf配置文件中记录了要管理哪些日志和将这些日志记录到哪个文件中。<br><br>原理示意图：<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230725100936162.png" alt="image-20230725100936162"></h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-number">1.</span>在进行日志管理时，要保证rsyslogd服务是启动的！<br><br>(<span class="hljs-number">1</span>)查询 Linux 中的 rsyslogd 服务是否启动<br>ps aux | grep <span class="hljs-string">&quot;rsyslog&quot;</span> <br><br>ps aux | grep <span class="hljs-string">&quot;rsyslog&quot;</span> | grep -v <span class="hljs-string">&quot;grep&quot;</span><br>| grep -v <span class="hljs-string">&quot;grep&quot;</span> ---&gt; 筛选出ps aux | grep <span class="hljs-string">&quot;rsyslog&quot;</span> 结果中不是grep的<br><br>(<span class="hljs-number">2</span>)查询 rsyslogd 服务的自启动状态(是否是自启动状态enable)<br>systemctl list-unit-files | grep rsyslog<br><br><br><span class="hljs-number">2.</span>配置文件：/etc/rsyslog.conf<br>该配置文件中记录了：日志和日志存放在哪个文件<br><br>关于日志：*.*<br>其中第一个*代表日志类型，第二个*代表日志级别<br><br>(<span class="hljs-number">1</span>)日志类型分为：<br>auth##pam 产生的日志<br>authpriv##ssh、ftp 等登录信息的验证信息<br>cron##时间任务相关<br>kern##内核<br>lpr##打印<br>mail##邮件<br>mark(syslog)-rsyslog##服务内部的信息，时间标识<br>news##新闻组<br>user##用户程序产生的相关信息<br>uucp##unix to nuix copy主机之间相关的通信<br>local <span class="hljs-number">1</span><span class="hljs-number">-7</span>##自定义的日志设备<br><br>(<span class="hljs-number">2</span>)日志级别分为：<br>debug##有调试信息的，日志通信最多<br>info##一般信息日志，最常用<br>notice##最具有重要性的普通条件的信息<br>warning##警告级别<br>err##错误级别，阻止某个功能或者模块不能正常工作的信息<br>crit##严重级别，阻止整个系统或者整个软件不能正常工作的信息<br>alert##需要立刻修改的信息<br>emerg##内核崩溃等重要信息<br>none##什么都不记录<br>注意：从上到下，级别从低到高，记录信息越来越少<br><br><br><span class="hljs-number">3.</span>由日志服务 rsyslogd 记录的日志文件，<br>日志文件的内容：每一行都代表一个事件，每一行有以下四个内容：<br><span class="hljs-number">1</span>)事件产生的时间<br><span class="hljs-number">2</span>)产生事件的服务器的主机名<br><span class="hljs-number">3</span>)产生事件的服务名或程序名<br><span class="hljs-number">4</span>)事件的具体信息<br><br><br><span class="hljs-number">4.</span>日志如何查看实例<br>查看一下 /var/log/secure 日志，这个日志中记录的是用户验证和授权方面的信息 来分析如何查看<br><br><span class="hljs-number">5.</span>日志管理服务应用实例（增加自定义的日志）<br>在/etc/rsyslog.conf 中添加一个日志文件/var/log/hsp.log,当有事件发送时(比如 sshd 服务相关事件)，该文件会接收到信息并保存. <br>给小伙伴演示 重启，登录 的情况，看看是否有日志保存<br><br>vim /etc/rsyslog.conf <br>写入：<br>*.*  /var/log/hsp.log<br>保存退出<br>&gt; /var/log/hsp.log  (创建日志文件)<br>然后重启，重启事件会被记录到/var/log/hsp.log中<br>cat hsp.log | grep sshd 就可以查到信息(sshd远程连接)<br></code></pre></td></tr></table></figure><h3 id="14-4日志轮替"><a href="#14-4日志轮替" class="headerlink" title="14.4日志轮替"></a>14.4日志轮替</h3><h4 id="14-4-1基本介绍"><a href="#14-4-1基本介绍" class="headerlink" title="14.4.1基本介绍"></a>14.4.1基本介绍</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">日志轮替<span class="hljs-comment">(logrotate)</span>就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除<br>清除日志中旧的信息<br></code></pre></td></tr></table></figure><h4 id="14-4-2日志轮替文件命名"><a href="#14-4-2日志轮替文件命名" class="headerlink" title="14.4.2日志轮替文件命名"></a>14.4.2日志轮替文件命名</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">(<span class="hljs-number">1</span>)centos7 使用 logrotate 进行日志轮替管理<br>要想改变日志轮替文件名字，通过 <span class="hljs-regexp">/etc/</span>logrotate.conf 配置文件中“dateext” 参数<br><br>(<span class="hljs-number">2</span>)如果配置文件中有“dateext”参数，那么日志会用日期来作为日志文件的后缀，例如 “secure-<span class="hljs-number">20201010</span>”。<br>这样日志文件名不会重叠，也就不需要日志文件的改名，只需要指定保存日志个数，删除多余的日志文件即可。<br><br>(<span class="hljs-number">3</span>)如果配置文件中没有“dateext”参数，日志文件就需要进行改名了。<br>当第一次进行日志轮替时，当前的“secure”日志会自动改名为“secure.<span class="hljs-number">1</span>”，然后新建“secure”日志， 用来保存新的日志。<br>当第二次进行日志轮替时，“secure.<span class="hljs-number">1</span>” 会自动改名为“secure.<span class="hljs-number">2</span>”， 当前的“secure”日志会自动改名为“secure.<span class="hljs-number">1</span>”，然后也会新建“secure”日志，用来保存新的日志，以此类推。<br></code></pre></td></tr></table></figure><h4 id="14-4-3logrotate配置文件"><a href="#14-4-3logrotate配置文件" class="headerlink" title="14.4.3logrotate配置文件"></a>14.4.3logrotate配置文件</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>logrotate.conf 为 logrotate 的全局配置文件(写了日志文件轮替规则)<br><br><span class="hljs-regexp">/etc/</span>logrotate.conf中的轮替规则适用于所有日志文件(除了单独指定轮替规则的日志文件)<br>可以在<span class="hljs-regexp">/etc/</span>logrotate.conf对某些日志文件单独指定轮替规则<br>也可以把对某些日志文件单独指定的轮替规则写在<span class="hljs-regexp">/etc/</span>logrotate.d目录下，然后在<span class="hljs-regexp">/etc/</span>logrotate.conf 中include调用<br><br><span class="hljs-regexp">/etc/</span>logrotate.conf文件内容：<br><span class="hljs-comment"># rotate log files weekly---&gt;每周对日志文件进行一次轮替</span><br>weekly<br><br><span class="hljs-comment"># keep 4 weeks worth of backlogs---&gt;共保存 4 份日志文件，当建立新的日志文件时，旧的将会被删除</span><br>rotate <span class="hljs-number">4</span><br><br><span class="hljs-comment"># create new (empty) log files after rotating old ones---&gt;创建新的空的日志文件，在日志轮替后</span><br>create<br><br><span class="hljs-comment"># use date as a suffix of the rotated file---&gt;使用日期作为日志轮替文件的后缀</span><br>dateext<br><br><span class="hljs-comment"># uncomment this if you want your log files compressed---&gt;日志文件是否压缩。如果取消注释，则日志会在转储的同时进行压缩</span><br><span class="hljs-comment">#compress</span><br><br><span class="hljs-comment">#RPM packages drop log rotation information into this directory </span><br>include <span class="hljs-regexp">/etc/</span>logrotate.d---&gt;可以把一些单独的轮替规则写在<span class="hljs-regexp">/etc/</span>logrotate.d下(在本文件中include调用一下就行)，也可以写在本文件中(如下面写的)<br><br><span class="hljs-comment">#下面是单独设置，优先级更高。</span><br><span class="hljs-comment"># no packages own wtmp and btmp -- we&#x27;ll rotate them here</span><br><span class="hljs-regexp">/var/</span>log/wtmp &#123;<br>monthly <span class="hljs-comment"># 每月对日志文件进行一次轮替</span><br>create <span class="hljs-number">0664</span> root utmp  <span class="hljs-comment"># 建立的新日志文件，权限是 0664  ，所有者是 root ，所属组是 utmp 组</span><br>minsize <span class="hljs-number">1</span>M <span class="hljs-comment"># 日志文件最小轮替大小是 1MB 。也就是日志一定要超过 1MB 才会轮替，否则就算时间达到一个月，也不进行日志转储</span><br>rotate <span class="hljs-number">1</span>  <span class="hljs-comment"># 仅保留一个日志备份。也就是只有 wtmp  和 wtmp.1  日志保留而已</span><br>&#125;<br><br><span class="hljs-regexp">/var/</span>log/btmp &#123;<br>missingok  <span class="hljs-comment"># 如果日志不存在，则忽略该日志的警告信息</span><br>monthly<br>create <span class="hljs-number">0600</span> root utmp rotate <span class="hljs-number">1</span><br>&#125;<br><br><br><br><br>单独指定某个日志文件的轮替规则的参数说明：<br>daily日志的轮替周期是每天<br>weekly日志的轮替周期是每周<br>monthly日志的轮替周期是每月<br>rotate 数字保留的日志文件的个数。<span class="hljs-number">0</span> 指没有备份<br>compress日志轮替时，旧的日志进行压缩<br>create mode owner group建立新日志，同时指定新日志的权限与所有者和所属组。<br>mail address当日志轮替时，输出内容通过邮件发送到指定的邮件地址。<br>missingok如果日志不存在，则忽略该日志的警告信息<br>notifempty如果日志为空文件，则不进行日志轮替<br>minsize 大小日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替<br>size 大小日志只有大于指定大小才进行日志轮替，而不是按照时间轮替。<br>dateext使用日期作为日志轮替文件的后缀。<br>sharedscripts在此关键字之后的脚本只执行一次。<br>prerotate/endscript在日志轮替之前执行脚本命令。<br>postrotate/endscript在日志轮替之后执行脚本命令。<br></code></pre></td></tr></table></figure><h4 id="14-4-4把自己的日志加入日志轮替"><a href="#14-4-4把自己的日志加入日志轮替" class="headerlink" title="14.4.4把自己的日志加入日志轮替"></a>14.4.4把自己的日志加入日志轮替</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">1</span>)第一种方法：<br>直接在<span class="hljs-regexp">/etc/</span>logrotate.conf 配置文件中写入该日志的轮替策略<br><span class="hljs-number">2</span>)第二种方法：<br>在<span class="hljs-regexp">/etc/</span>logrotate.d/目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被“<span class="hljs-keyword">include</span>”到主配置文件中，所以也可以把日志加入轮替。<br><br><span class="hljs-number">3</span>)推荐使用第二种方法，因为系统中需要轮替的日志非常多，如果全都直接写 入<span class="hljs-regexp">/etc/</span>logrotate.conf 配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。<br></code></pre></td></tr></table></figure><h4 id="14-4-5应用实例"><a href="#14-4-5应用实例" class="headerlink" title="14.4.5应用实例"></a>14.4.5应用实例</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">案例：在<span class="hljs-regexp">/etc/</span>logrotate.conf 进行配置, 或者直接在 <span class="hljs-regexp">/etc/</span>logrotate.d/ 下创建文件 hsplog  <br>编写如下内容,具体轮替的效果 可以参考 <span class="hljs-regexp">/var/</span>log  下的 boot.log 情况.<br></code></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230725100555724.png" alt="image-20230725100555724"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">在 <span class="hljs-regexp">/etc/</span>logrotate.d/ 下创建文件 hsplog  <br>vim  hsplog  <br>写入：<br><span class="hljs-regexp">/var/</span>log/hsp.log<br>&#123;<br>missingok<br>daily<br>copytruncate<br>rotate <span class="hljs-number">1</span><br>notifempty<br>&#125;<br>保存退出<br><br>这样就好了，因为<span class="hljs-regexp">/etc/</span>logrotate.conf 中有：<span class="hljs-keyword">include</span> <span class="hljs-regexp">/etc/</span>logrotate.d<br></code></pre></td></tr></table></figure><h3 id="14-5日志轮替机制原理"><a href="#14-5日志轮替机制原理" class="headerlink" title="14.5日志轮替机制原理"></a>14.5日志轮替机制原理</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。<br>在 <span class="hljs-regexp">/etc/</span>cron.daily/目录，就会发现这个目录中是有 logrotate 文件(可执行)，<br>logrotate 通过这个文件依赖定时任务执行的。<br><br>crond定时后台程序会定时执行cron.daily内的文件<br>logrotate 文件在cron.daily下<br>所以也会定时执行文件中的轮替规则<br><br><br>写日志是rsyslogd<br>日志轮替是logrotate<br></code></pre></td></tr></table></figure><h3 id="14-6查看内存日志"><a href="#14-6查看内存日志" class="headerlink" title="14.6查看内存日志"></a>14.6查看内存日志</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">有一些日志是写到内存里的，还没有写到文件里，因为这些日志是实时变化的<br>重启之后内存日志会被清空<br><br>查看内存日志指令：journalctl<br>journalctl查看全部<br>journalctl -n 3查看最新 3 条<br>journalctl --since 19:00--until 19:10:10查看起始时间到结束时间的日志可加日期<br>journalctl -p err报错日志<br>journalctl -o verbose日志详细内容<br>journalctl <span class="hljs-attribute">_PID</span>=1245 <span class="hljs-attribute">_COMM</span>=sshd查看包含这些参数的日志（在详细日志查看） 或者 journalctl |grep sshd<br> <br><br>注意: journalctl查看的是内存日志, 重启清空<br><br>演示案例:<br>使用 journalctl | grep sshd来看看用户登录清空, 重启系统，再次查询，看看日志有什么变化没有<br></code></pre></td></tr></table></figure><h2 id="十五、Linux系统-备份与恢复"><a href="#十五、Linux系统-备份与恢复" class="headerlink" title="十五、Linux系统-备份与恢复"></a>十五、Linux系统-备份与恢复</h2><h3 id="15-1基本介绍"><a href="#15-1基本介绍" class="headerlink" title="15.1基本介绍"></a>15.1基本介绍</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">虚拟机可以做快照。<br>实体机无法做快照，如果系统出现异常或者数据损坏，后果严重，要重做系统，还会造成数据丢失。<br>所以我们可以使用备份和恢复技术<br><br>linux 的备份和恢复很简单，有两种方式：<br>(<span class="hljs-number">1</span>)把需要的文件(或者分区)用 TAR 打包就行，下次需要恢复的时候，再解压开覆盖即可<br>(<span class="hljs-number">2</span>)使用 dump 和 restore 命令<br></code></pre></td></tr></table></figure><h3 id="15-2安装dump和restore"><a href="#15-2安装dump和restore" class="headerlink" title="15.2安装dump和restore"></a>15.2安装dump和restore</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">如果 linux 上没有 dump  和 restore 指令，要先安装<br>yum -y <span class="hljs-keyword">install</span> dump <br>yum -y <span class="hljs-keyword">install</span> restore<br></code></pre></td></tr></table></figure><h3 id="15-3使用dump完成备份"><a href="#15-3使用dump完成备份" class="headerlink" title="15.3使用dump完成备份"></a>15.3使用dump完成备份</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">1</span>.基本介绍：<br><span class="hljs-keyword">dump</span> 支持分卷和增量备份（所谓增量备份是指备份上次备份后，修改/增加过的文件，也称差异备份）<br><br><span class="hljs-number">2</span>.语法说明：<br><span class="hljs-keyword">dump</span> [-cu] [-<span class="hljs-number">123456789</span>][-f &lt;备份后文件名&gt;] [-T &lt;日期&gt;] [要备份的目录或文件系统] <br><span class="hljs-keyword">dump</span> [] -wW<br><br>选项说明：<br>-c 创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头。<br>-<span class="hljs-number">0123456789</span> 备份的层级。<span class="hljs-number">0</span> 为最完整备份，会备份所有文件。若指定 <span class="hljs-number">0</span> 以上的层级，则备份至上一次备份以来修改或新增的文件，到 <span class="hljs-number">9</span> 后，可以再次轮替.<br>-f &lt;备份后文件名&gt; 指定备份后文件名<br>-j调用 bzlib 库压缩备份文件，也就是将备份后的文件压缩成 bz2 格式，让文件更小<br>-T &lt;日期&gt; 指定开始备份的时间与日期<br>-u 备份完毕后，在<span class="hljs-regexp">/etc/</span>dumpdares 中记录备份的文件系统，层级，日期与时间等。<br>-t  指定文件名，若该文件已存在备份文件中，则列出名称<br>-W 显示需要备份的文件及其最后一次备份的层级，时间，日期。<br>-w 与-W 类似，但仅显示需要备份的文件。<br><br>进行增量备份/备份层级要加-u，因为-u可以记录层级<br><br><span class="hljs-number">3</span>.案例<br>案例 <span class="hljs-number">1</span>：将<span class="hljs-regexp">/boot 分区所有内容备份到/</span>opt/boot.bak0.bz2 文件中，备份层级为“<span class="hljs-number">0</span>”<br><span class="hljs-keyword">dump</span> -<span class="hljs-number">0</span>uj -f <span class="hljs-regexp">/opt/</span>boot.bak0.bz2/boot<br>/boot 要备份的分区<br><br>案例 <span class="hljs-number">2</span>：在/boot 目录下增加新文件，备份层级为“<span class="hljs-number">1</span>”(只备份上次使用层次“<span class="hljs-number">0</span>”备份后发生过改变的数据), 注意比较看看这次生成的备份文件 boot1.bak  有多大<br><span class="hljs-keyword">dump</span> -<span class="hljs-number">1</span>uj -f <span class="hljs-regexp">/opt/</span>boot.bak1.bz2 /boot<br><br><br>注意：通过 <span class="hljs-keyword">dump</span> 命令在配合 crontab 可以实现无人值守备份<br>写一个脚本<br><br><br><span class="hljs-number">4</span>. 显示需要备份的文件及其最后一次备份的层级，时间，日期<br><span class="hljs-keyword">dump</span> -W<br><br><br><span class="hljs-number">5</span>.查看备份时间文件<br>cat <span class="hljs-regexp">/etc/</span>dumpdates<br><br><br><span class="hljs-number">6</span>.<span class="hljs-keyword">dump</span> 备份文件或者目录<br>前面我们在备份分区时，是可以支持增量备份的，<br>如果备份文件或者目录，不再支持增量备份, 即只能使用 <span class="hljs-number">0</span> 级别备份(-u不能写)<br><br>案例：使用 <span class="hljs-keyword">dump</span> 备份 /etc 整个目录<br><span class="hljs-keyword">dump</span> -<span class="hljs-number">0</span>j -f <span class="hljs-regexp">/opt/</span>etc.bak.bz2 <span class="hljs-regexp">/etc/</span> <br><br>#下面这条语句会报错，提示 <span class="hljs-keyword">DUMP</span>: Only level <span class="hljs-number">0</span> dumps are allowed on a subdirectory <br><span class="hljs-keyword">dump</span> -<span class="hljs-number">1</span>j -f <span class="hljs-regexp">/opt/</span>etc.bak.bz2 <span class="hljs-regexp">/etc/</span><br><br><br>注意：如果要备份重要的文件，比如数据区，建议将文件上传到其它服务器保存，不要将鸡蛋放在同一个篮子。<br></code></pre></td></tr></table></figure><h3 id="15-4使用restore完成恢复"><a href="#15-4使用restore完成恢复" class="headerlink" title="15.4使用restore完成恢复"></a>15.4使用restore完成恢复</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>.基本介绍：<br>restore 命令用来恢复已备份的文件，可以从 dump 生成的备份文件中恢复原文件<br><br><span class="hljs-number">2</span>.基本语法：<br>restore[模式选项] [选项]<br><br>模式选项说明：不能混用，在一次命令中，只能指定一种。<br>-C使用对比模式，将备份的文件与已存在的文件相互对比，看看是否存在差异<br>-i使用交互模式，在进行还原操作时，restore 指令将依序询问用户<br>-r进行还原模式 （一般用这个）<br>-t 查看模式，看备份文件有哪些文件<br><br>选项<br>-f &lt;备份设备&gt; 从指定的文件中读取备份数据，进行还原操作<br><br><span class="hljs-number">3</span>.案例：<br>案例 <span class="hljs-number">1</span>：restore 命令比较模式，比较备份文件和原文件的区别测试<br>mv <span class="hljs-regexp">/boot/</span>hello.java <span class="hljs-regexp">/boot/</span>hello100.java<br>restore -C -f boot.bak1.bz2<span class="hljs-regexp">//</span>注意和 最新的文件比较<br><br>mv <span class="hljs-regexp">/boot/</span>hello100.java <span class="hljs-regexp">/boot/</span>hello.java <br>restore -C -f boot.bak1.bz2<br> <br>案例 <span class="hljs-number">2</span>：restore 命令查看模式，看备份文件有哪些数据/文件<br>restore -t -f boot.bak0.bz2<br><br><br>案例 <span class="hljs-number">3</span>：restore 命令还原模式<br>注意细节：如果你有增量备份，需要把增量备份文件也进行恢复，有几个增量备份文件，就要恢复几个，按顺序来恢复即可。<br>mkdir <span class="hljs-regexp">/opt/</span>boottmp <br>cd <span class="hljs-regexp">/opt/</span>boottmp<br>restore -r -f <span class="hljs-regexp">/opt/</span>boot.bak0.bz2 <span class="hljs-regexp">//</span>恢复到第 <span class="hljs-number">1</span> 次完全备份状态<br>restore -r -f <span class="hljs-regexp">/opt/</span>boot.bak1.bz2 <span class="hljs-regexp">//</span>恢复到第 <span class="hljs-number">2</span> 次增量备份状态<br><br><br>案例 <span class="hljs-number">4</span>：restore 命令恢复备份的文件，或者整个目录的文件<br>基本语法： restore -r -f 备份好的文件<br><br>[root@hspedu100 opt]<span class="hljs-comment"># mkdir etctmp </span><br>[root@hspedu100 opt]<span class="hljs-comment"># cd etctmp/</span><br>[root@hspedu100 etctmp]<span class="hljs-comment"># restore -r -f /opt/etc.bak0.bz2</span><br></code></pre></td></tr></table></figure><h2 id="困扰我很久的ssh"><a href="#困扰我很久的ssh" class="headerlink" title="困扰我很久的ssh"></a>困扰我很久的ssh</h2><h3 id="SSH连接的工作原理"><a href="#SSH连接的工作原理" class="headerlink" title="SSH连接的工作原理"></a>SSH连接的工作原理</h3><p>当你建立SSH连接时，以下是发生的事情：</p><ol><li><strong>生成密钥对</strong>：你的计算机会生成一对公钥和私钥。</li><li><strong>将公钥添加到远程服务器</strong>：你将你的公钥（<code>id_rsa.pub</code>文件的内容）添加到远程服务器的<code>~/.ssh/authorized_keys</code>文件中。这样，服务器就知道了你的公钥，可以用它加密发送给你的数据。</li><li><strong>连接时的加密</strong>：当你尝试连接到服务器时，服务器会使用你的公钥加密一个随机生成的会话密钥，并将它发送给你。</li><li><strong>使用私钥解密会话密钥</strong>：你的计算机使用你的私钥解密收到的会话密钥。</li><li><strong>使用会话密钥进行加密通信</strong>：现在，你的计算机和服务器都有了相同的会话密钥，它们使用这个密钥进行加密和解密通信。</li></ol><p>这个过程保证了通信的保密性，因为只有你持有私钥，能够解密服务器发送的会话密钥，从而确保了只有你和服务器知道通信内容。</p><p>通过使用非对称加密，SSH提供了一种非常安全的远程连接方式，保护了通信的隐私和数据的完整性。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP</title>
    <link href="/2023/06/16/TCPIP/"/>
    <url>/2023/06/16/TCPIP/</url>
    
    <content type="html"><![CDATA[<p>​TCP&#x2F;IP协议族是一组不同的协 议组合在一起构成的协议族。尽管通常称该协议族为 TCP&#x2F;IP，但TCP和IP只是其中的两种协议而已（该协议族的另一个名字是 Internet协议族(Internet Protocol Suite)）。</p><p>​TCP（Transmission Control Protocol）传输控制协议</p><p>​UDP（User Datagram Protocol）用户数据报协议</p><span id="more"></span><p>​路由器的好处是为不同类型的物理网络提供连接：以太网、令牌环网、 点对点的链接和FDDI（光纤分布式数据接口）等等。 这些盒子也称作IP路由器（IP Router），但我们这里使用路由器( Router )这个术语。 从历史上说，这些盒子称作<strong>网关（gateway）</strong>，在很多TCP&#x2F;IP文献中都使用这个术语。</p><p> 现在网关这个术语只用来表示应用层<strong>网关</strong>：<strong>一个连接两种不同协议族的进程（例如， TCP&#x2F;IP和IBM的SNA），它为某个特定的应用程序服务（常常是电子邮件或文件传输）</strong>。</p><p>我们可以划分出端系统（End system）（两边的两台主机）和中间系统 （Intermediate system）（中间的路由器）。应用层和运输层使用端到端（End-to-end）协议。在 图中，只有端系统需要这两层协议。但是，网络层提供的却是逐跳（Hop-by-hop）协议，两 个端系统和每个中间系统都要使用它。</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306192054741.png" alt="image-20230619205416597"></p><p>TCP和UDP都是用IP作为网络层协议。</p><p>TCP使用<strong>不可靠的IP</strong>*<em><strong>服务</strong>，但却提供</em><em>可靠的运输层服务</em>*</p><p>一些TCP<strong>应用</strong>：<strong>Telnet、Rlogin、FTP、SMTP</strong></p><p><strong>数据报</strong>：是指发送发传输到接收方的一个信息单元。</p><h2 id="互联网地址"><a href="#互联网地址" class="headerlink" title="互联网地址"></a>互联网地址</h2><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306192055226.png" alt="image-20230619205502187"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306192055726.png" alt="image-20230619205548688"></p><p>多接口主机具有多个 IP地址，其中每个接口都对应一个 IP地址。</p><p>Internet注册服务( IP地址和DNS域名)过去由NIC来负责，其网络地址是nic.ddn.mil。</p><p>有三类IP地址：<strong>单播地址</strong>（目的为单个主机）、<strong>广播地址</strong>（目的端为给定网络上的所有主 机）以及<strong>多播地址</strong>（目的端为同一组内的所有主机）</p><p>尽管通过IP地址可以识别主机上的网络接口，进而访问主机，但是人们最喜欢使用的还 是主机名。在 TCP&#x2F;IP领域中，域名系统（DNS）是一个分布的数据库，由它来提供 IP地址和 主机名之间的映射信息。</p><p>由于TCP、UDP、ICMP和IGMP都要向IP传送数据，因此IP必须在生成的IP首部中加入某种标识，以表明数据属于哪一层。为此， IP在首部中存入一个长度为 <strong>8bit</strong>的数值，称作协议域。 1表示为<strong>ICMP</strong>协议，2表示为<strong>IGMP</strong>协议，6表示为<strong>TCP</strong>协议，17表 示为<strong>UDP</strong>协议。</p><p><strong>ICMP和IGMP</strong>属于<strong>网络层</strong>，<strong>TCP和UDP</strong>属于<strong>运输层</strong></p><p>TCP和UDP都用一个<strong>16bit</strong>的<strong>端口号</strong>来表示不同的应用程序。<strong>TCP</strong>和<strong>UDP</strong>把<strong>源端口号</strong>和<strong>目的端口号</strong>分别存入<strong>报文首部</strong>中。</p><p>网络接口分别要发送和接收<strong>IP、ARP和RARP</strong>数据，因此也必须在以太网的帧首部中加入某种形式的标识，以<strong>指明生成数据的网络层协议</strong>。为此，以太网的帧首部也有一个 <strong>16bit</strong>的帧类型域。</p><p><strong>ICMP和IGMP</strong>是<strong>IP</strong>的<strong>附属协议</strong>，又把它们放在IP层的上面，这是因为ICMP和IGMP报文都<strong>被封装在IP数据报</strong>中。</p><p>服务器为客户提供一些特定服务，可分为两种类型：<strong>重复型</strong>和<strong>并发型</strong></p><p>任何TCP&#x2F;IP实现所提供的服务都用知名的<strong>1～1023</strong>之间的端口号。</p><p>到1992年为止，知名端口号介于<strong>1～255</strong>之间。<strong>256～1023</strong>之间的端口号通常都是由<strong>Unix系统</strong>占用，以提供一些特定的Unix服务。也就是说，<strong>提供一些只有Unix系统才有的、而其他操作系统可能不提供的服务</strong>。</p><p>大多数TCP&#x2F;IP实现给临时端口分配1024～5000之间的端口号。大于5000的端口号是为其他服务器预留的（Internet上并不常用的服务)。</p><p>在一个互联网上，每个接口都用IP地址来标识，尽管用户习惯使用主机名而不是IP地址。 域名系统为主机名和IP地址之间提供动态的映射。端口号用来标识互相通信的应用程序。服务器使用知名端口号，而客户使用临时设定的端口号。</p><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>链路层有三个目的：</p><ul><li>为IP模块发送和接收IP数据报</li><li>为ARP模块发送ARP请求和接收ARP应答</li><li>为RARP发送RARP请求和接收RARP应答</li></ul><p>TCP&#x2F;IP支持多种不同的链路层协议，取决于网络所使用的硬件，如以太网、令牌环网、FDDI等</p><h2 id="以太网和IEEE-802封装"><a href="#以太网和IEEE-802封装" class="headerlink" title="以太网和IEEE 802封装"></a>以太网和IEEE 802封装</h2><p>以太网是当今TCP&#x2F;IP采用的主要的局域网技术，采用CSMA&#x2F;CD的媒体接入方法</p><p>802定义的帧格式</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306201111866.png" alt="image-20230620110612492"></p><p>以太网封装的帧格式</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306201111874.png" alt="image-20230620110639091"></p><p>在<strong>以太网</strong>的帧格式中，类型字段之后就是<strong>数据</strong>；而在802帧格式中，跟随在后面的是3字节的<strong>802.2LLC</strong>和5字节的<strong>802.2 SNAP</strong>（Sub-network Access Protocol)<strong>子网接入协议</strong></p><p><strong>目的服务访问点</strong>（Destination Service Access Point, DSAP和<strong>源服务访问点</strong>（Source Service Access Point, SSAP）的值都设为0 x a a。Ctrl字段的值设为3。随后的3个字节org code都置为0。</p><p><strong>CRC</strong>字段用于帧内后续字节差错的<strong>循环冗余码检验</strong>（检验和）（它也被称为<strong>FCS</strong>或<strong>帧检验序列</strong>）。</p><p><strong>802.3</strong>规定数据部分必须至少为<strong>38字节</strong>，而对于<strong>以太网</strong>，则要求最少要有<strong>46字节</strong>。</p><h2 id="SLIP：串行线路IP"><a href="#SLIP：串行线路IP" class="headerlink" title="SLIP：串行线路IP"></a>SLIP：串行线路IP</h2><p><strong>SLIP的帧格式：</strong></p><ol><li>IP数据报以一个称作END（0xc0）的特殊字符结束。同时，为了防止数据报到来之前 的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个 END字符</li><li>如果I P报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLIP的ESC字符，但是它的值与ASCII码的ESC字符（0x1b）不同</li><li>如果I P报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。</li></ol><h2 id="PPP协议（看不太明白，了解）"><a href="#PPP协议（看不太明白，了解）" class="headerlink" title="PPP协议（看不太明白，了解）"></a>PPP协议（看不太明白，了解）</h2><p><strong>PPP比SLIP的优点：</strong></p><p>(1) PPP支持在单根串行线路上运行多种协议， 不只是I P协议；</p><p>(2) 每一帧都有循环冗余检验； </p><p>(3) 通信双方可以进行 I P地址的动态协商(使用 I P网络控制协议)；</p><p> (4) 与C S L I P类似，对T C P和I P报文首部进行压缩；</p><p> (5) 链路控制协议可以 对多个数据链路选项进行设置。</p><h2 id="环回接口"><a href="#环回接口" class="headerlink" title="环回接口"></a>环回接口</h2><p>允许运行在同一台主机上的客户程序和服务器程序通过<strong>TCP&#x2F;IP</strong>进行通信</p><p>根据惯例， 大多数系统把I P地址<strong>127.0.0.1</strong>分配给这个接口，并命名为<strong>localhost</strong></p><p>一个传给环回接口的 I P数据报不能在任何网络上出现。</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306201506770.png" alt="image-20230620150622530"></p><h2 id="最大传输单元MTU"><a href="#最大传输单元MTU" class="headerlink" title="最大传输单元MTU"></a>最大传输单元MTU</h2><p>以太网和802.3对数据帧的长度都有一个限制，其最大值分别是<strong>1500</strong>和<strong>1492</strong>字节。链路层的这个特性称作<strong>MTU</strong>，最大传输单元。</p><p>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行<strong>分片</strong>（fragmentation），把数据报分成若干片，这样每一片都小于MTU。</p><h2 id="路径MTU"><a href="#路径MTU" class="headerlink" title="路径MTU"></a>路径MTU</h2><p>两台通信主机路径中的<strong>最小MTU</strong>,被称作<strong>路径MTU</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>计网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络学习笔记"><a href="#计算机网络学习笔记" class="headerlink" title="计算机网络学习笔记"></a>计算机网络学习笔记</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h4 id="路由信息协议RIP的基本工作原理"><a href="#路由信息协议RIP的基本工作原理" class="headerlink" title="路由信息协议RIP的基本工作原理"></a>路由信息协议RIP的基本工作原理</h4><span id="more"></span><p>​●路由信息协议RIP(Routing Information Protocol)是内部网关协议IGP中最先得到广泛使用的协议之一，其相关标准文档为RFC 1058。</p><p>​●RIP要求自治系统AS内的每一个路由器都要维护<strong>从它自己到AS内其他每一个网络</strong>的距离记录。这是一组距离，称为“<strong>距离向量</strong>D-V(Distance-Vector)” </p><p>​●RIP使用**跳数(Hop Count)**作为度量(Metric)来衡量到达目的网络的距离。</p><p>​●●路由器到直连网络的距离定义为1。</p><p>​  ●路由器到非直连网络的距离定义为所经过的路由器数加1。</p><p>​  ●允许一条路径最多只能包含15个路由器。“距离”等于16时相当于不可达。因此，RIP只适用于小型互联网。</p><p>​●RIP认为好的路由就是“距离短”的路由，也就是所通过路由器数量最少的路由。当到达同一目的网络有多条“距离相等”的路由时，可以进行等价负载均衡。  RIP包含以下三个要点：</p><ol><li><p>​和谁交换信息：仅和相邻路由器交换信息</p></li><li><p>​    交换什么信息：自己的路由表</p></li><li><p>​    何时交换信息：周期性交换（例如每30秒)</p><h4 id="RIP的基本工作过程："><a href="#RIP的基本工作过程：" class="headerlink" title="RIP的基本工作过程："></a><strong>RIP的基本工作过程</strong>：</h4><p>①路由器刚开始工作时，只知道自己到<strong>直连网络</strong>的距离为1。</p><p>②每个路由器仅和<strong>相邻</strong>路由器<strong>周期性</strong>地交换并更新路由信息。</p><p>③若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为收敛。</p><h4 id="RIP的路由条目的更新规则："><a href="#RIP的路由条目的更新规则：" class="headerlink" title="RIP的路由条目的更新规则："></a><strong>RIP的路由条目的更新规则</strong>：</h4><ol><li>​发现了新的网络，添加</li><li>​        到达目的网络,不同下一跳，新路由优势，更新</li><li>​        到达目的网络,不同下一跳, 等价负载均衡</li><li>​        到达目的网络，相同下一跳，最新消息，更新</li><li>​        到达目的网络，相同下一跳，最新消息，更新</li></ol><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151641367.png" alt="image-20230322221719248"></p><h4 id="RIP存在“坏消息传播得慢”的问题"><a href="#RIP存在“坏消息传播得慢”的问题" class="headerlink" title="RIP存在“坏消息传播得慢”的问题"></a>RIP存在“坏消息传播得慢”的问题</h4><ul><li><p>“坏消息传播得慢”又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。可以采取多种措施减少出现该问题的概率或减小该问题带来的危害。</p><p>采取一下措施来减少该问题出现的概率或减小该问题带来的危害：</p></li></ul></li></ol><h4 id="RIPv1和RIPv2的区别："><a href="#RIPv1和RIPv2的区别：" class="headerlink" title="RIPv1和RIPv2的区别："></a>RIPv1和RIPv2的区别：</h4><p>​1.RIPV1是有类路由协议，RIPV2是无类路由协议。</p><p>​2.RIPV1不能支持VLSM，RIPV2可以支持VLSM。</p><p>​3.RIPV1没有认证的功能，RIPV2可以支持认证，并且有明文和MD5两种认证。</p><p>​4.RIPV1没有手工汇总的功能，RIPV2可以在关闭自动汇总的前提下，进行手工汇总</p><p>​5.RIPV1是广播更新，RIPV2,是组播更新。</p><p>​6.RIPV1对路由没有标记的功能，RIPV2可以对路由打标记(Tag)，用于过滤和做策略。</p><p>​7.RIPV1发送的up data包中最多可以携带25条路由条目，RIPV2在有认证的情况下最多只能携带24条路由。</p><p>​8.RIPV1发送的up data包中没有next-hop属性，RIPv2有next-hop属性，可以用于路由更新的重定</p><h2 id="CIDR与VLSM的区别"><a href="#CIDR与VLSM的区别" class="headerlink" title="CIDR与VLSM的区别"></a>CIDR与VLSM的区别</h2><p>​CIDR是把几个标准网络合成一个大的网络</p><p>​VLSM是把一个标准网络分成几个小型网络(子网)</p><p>​CIDR是子网掩码往左边移了，VLSM是子网掩码往右边移了</p>]]></content>
    
    
    <categories>
      
      <category>计网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2023/06/15/Git/"/>
    <url>/2023/06/15/Git/</url>
    
    <content type="html"><![CDATA[<p>Git（读音为&#x2F;gɪt&#x2F;）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p><span id="more"></span><h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><p>免费、开源分布式版本控制系统</p></li><li><p>快速高效处理从小型到大型的各种项目</p></li><li><p>易于学习，占地面积小，性能极快</p></li></ul><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><p><strong>深究其分布式版本</strong></p><ul><li><p>其集中式版本控制工具有缺点也有优点，可看到项目中内容管理，管理员也可管理单一系统也比较容易</p></li><li><p>缺点就是中央服务器的单点故障</p></li></ul><p><strong>分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷</strong></p><ul><li><p>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</p></li><li><p>每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）</p></li></ul><p><strong>工作机制</strong></p><ul><li>工作区：通过写好的代码，放在了磁盘区，不是特指编译器中的代码</li><li>临时存储：通过工作区git add放到此处</li><li>本地库：通过临时存储的git commit放到此处</li><li>远程库：通过本地库上传到远程库，代码托管中心是基于网络服务器的远程代码仓库</li></ul><h2 id="1-Git概述"><a href="#1-Git概述" class="headerlink" title="1.Git概述"></a>1.Git概述</h2><p> Git 是一个免费的、开源的<strong>分布式版本控制系统</strong>，可以快速高效地处理从小型到大型的各种 项目。</p><p> Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作 流分支等特性。其性能优于 Subversion、CVS、Perforce 和 ClearCase 等版本控制工具。</p><h3 id="1-1何为版本控制"><a href="#1-1何为版本控制" class="headerlink" title="1.1何为版本控制"></a>1.1何为版本控制</h3><p> 版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p> 版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本， 方便版本切换。</p><h3 id="1-2为什么需要版本控制"><a href="#1-2为什么需要版本控制" class="headerlink" title="1.2为什么需要版本控制"></a>1.2为什么需要版本控制</h3><p>个人开发过渡到团队协作</p><p><img src="https://img-blog.csdnimg.cn/ca8eedf9c9c045378306e95926a24021.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtb27om64=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="img"></p><h3 id="1-3版本控制工具"><a href="#1-3版本控制工具" class="headerlink" title="1.3版本控制工具"></a>1.3版本控制工具</h3><p> 集中化的版本控制系统诸如 CVS、SVN 等，都有一个单一的集中管理的服务器，保存 所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或 者提交更新。多年以来，这已成为版本控制系统的标准做法。</p><p> 这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什 么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要 远比在各个客户端上维护本地数据库来得轻松容易。</p><p> 事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕 机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637549.png" alt="img"></p><ul><li>分布式版本控制工具</li></ul><p> Git、Mercurial、Bazaar、Darcs……</p><p> 像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码 仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用 其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次 对整个文件仓库的完整备份。</p><p>分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:</p><ol><li>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</li><li>每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）</li></ol><h3 id="1-4Git工作机制"><a href="#1-4Git工作机制" class="headerlink" title="1.4Git工作机制"></a>1.4Git工作机制</h3><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637923.png" alt="在这里插入图片描述"></p><ul><li>工作区：代码存放的磁盘目录的位置</li><li>暂存区：在工作区完成后把代码<strong>添加</strong>到暂存区（临时存储，还没有生成历史版本）</li><li>本地库：将暂存区代码commit（提交）到本地库，此时会生成历史版本</li></ul><h3 id="1-5Git和代码托管中心"><a href="#1-5Git和代码托管中心" class="headerlink" title="1.5Git和代码托管中心"></a>1.5Git和代码托管中心</h3><p>代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为<strong>远程库</strong>。</p><ul><li>➢ 局域网</li><li>✓ GitLab</li><li>➢ 互联网<ul><li>✓ GitHub（外网）</li><li>✓ Gitee 码云（国内网站）</li></ul></li></ul><h2 id="2-Git安装"><a href="#2-Git安装" class="headerlink" title="2.Git安装"></a>2.Git安装</h2><p>无脑next下载即可</p><h2 id="3-Git常用命令"><a href="#3-Git常用命令" class="headerlink" title="3.Git常用命令"></a>3.Git常用命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git config –global user.name 用户名</td><td align="center">设置用户签名</td></tr><tr><td align="center">git config –global user.email 邮箱</td><td align="center">设置用户签名</td></tr><tr><td align="center"><strong>git init</strong></td><td align="center"><strong>初始化本地库</strong></td></tr><tr><td align="center"><strong>git status</strong></td><td align="center"><strong>查看本地库状态</strong></td></tr><tr><td align="center"><strong>git add 文件名</strong></td><td align="center"><strong>添加到暂存区</strong></td></tr><tr><td align="center"><strong>git commit -m “日志信息” 文件名</strong></td><td align="center"><strong>提交到本地库</strong></td></tr><tr><td align="center"><strong>git reflog</strong></td><td align="center">** 查看历史记录**</td></tr><tr><td align="center"><strong>git reset –hard 版本号</strong></td><td align="center"><strong>版本穿梭</strong></td></tr></tbody></table><h3 id="3-1设置用户签名"><a href="#3-1设置用户签名" class="headerlink" title="3.1设置用户签名"></a>3.1设置用户签名</h3><p>1）基本语法</p><p>git config –global user.name 用户名</p><p>git config –global user.email 邮箱</p><p> 签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看 到，以此确认本次提交是谁做的。</p><p> Git 首次安装必须设置一下用户签名，否则无法提交代码。</p><p> ※<strong>注意</strong>：这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</p><p>3.2初始化本地库<br>1）基本语法</p><p><strong>git init</strong></p><p>2）案例实操</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637067.png" alt="img"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637307.png" alt="img"></p><p>初始化成功</p><h3 id="3-3查看本地库状态"><a href="#3-3查看本地库状态" class="headerlink" title="3.3查看本地库状态"></a>3.3查看本地库状态</h3><p>1）基本语法</p><p><strong>git status</strong></p><p>2）案例实操</p><h4 id="3-3-1-首次查看（工作区没有任何文件）"><a href="#3-3-1-首次查看（工作区没有任何文件）" class="headerlink" title="3.3.1 首次查看（工作区没有任何文件）"></a>3.3.1 首次查看（工作区没有任何文件）</h4><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637220.png" alt="首次查看"></p><ul><li>on branch master ：目前在master分支</li><li>No commits yet：目前没有任何提交</li><li>nothing to commit：没有任何文件</li></ul><h4 id="3-3-2新增文件（hello-txt）"><a href="#3-3-2新增文件（hello-txt）" class="headerlink" title="3.3.2新增文件（hello.txt）"></a>3.3.2新增文件（hello.txt）</h4><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637931.png" alt="新增文件"></p><ul><li>在vim hello.txt后，出现界面后点击insert可以开始编写内容，点击esc退出编辑模式，shift + ：并输入wq保存文件；</li><li>cat hello.txt：查看文件内容；</li><li>tail -n 1 hello.txt：查看文件最后一行的内容</li></ul><h4 id="3-3-3再次查看（检查为追踪的文件）"><a href="#3-3-3再次查看（检查为追踪的文件）" class="headerlink" title="3.3.3再次查看（检查为追踪的文件）"></a>3.3.3再次查看（检查为追踪的文件）</h4><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637153.png" alt="再次查看"></p><p>文件名是红色代表还被未追踪</p><h3 id="3-4添加暂存区"><a href="#3-4添加暂存区" class="headerlink" title="3.4添加暂存区"></a>3.4添加暂存区</h3><h4 id="3-4-1将工作区的文件添加到暂存区"><a href="#3-4-1将工作区的文件添加到暂存区" class="headerlink" title="3.4.1将工作区的文件添加到暂存区"></a>3.4.1将工作区的文件添加到暂存区</h4><p>1）基本语法</p><p><strong>git add 文件名</strong></p><p>2）案例实操</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637867.png" alt="案例实操"></p><h4 id="3-4-2查看状态（检测到暂存区有新文件）"><a href="#3-4-2查看状态（检测到暂存区有新文件）" class="headerlink" title="3.4.2查看状态（检测到暂存区有新文件）"></a>3.4.2查看状态（检测到暂存区有新文件）</h4><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637404.png" alt="查看状态"></p><p>文件名是绿色代表git已追踪到该文件，但只是在暂存区</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637002.png" alt="查看状态"></p><p>将文件从暂存区删除，工作区还是存在</p><h3 id="3-5提交本地库"><a href="#3-5提交本地库" class="headerlink" title="3.5提交本地库"></a>3.5提交本地库</h3><h4 id="3-5-1-将暂存区的文件提交到本地库"><a href="#3-5-1-将暂存区的文件提交到本地库" class="headerlink" title="3.5.1 将暂存区的文件提交到本地库"></a>3.5.1 将暂存区的文件提交到本地库</h4><p>1）基本语法</p><p><strong>git commit -m “日志信息” 文件名</strong></p><p>2）案例实操</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637157.png" alt="案例实操"></p><p>835d3ec：版本号</p><p>“fitst commit”：必须填，内容每次不同</p><h4 id="3-5-2查看状态（没有文件需要提交）"><a href="#3-5-2查看状态（没有文件需要提交）" class="headerlink" title="3.5.2查看状态（没有文件需要提交）"></a>3.5.2查看状态（没有文件需要提交）</h4><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637183.png" alt="查看状态"></p><p><strong>git reflog</strong>：查看版本信息</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637022.png" alt="查看版本信息"></p><p><strong>git log</strong>：查看日志详细信息</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637153.jpeg" alt="查看日志详细信息"></p><h3 id="3-6修改文件（hello-txt）"><a href="#3-6修改文件（hello-txt）" class="headerlink" title="3.6修改文件（hello.txt）"></a>3.6修改文件（hello.txt）</h3><h4 id="3-6-1查看状态（检测到工作区有文件被修改）"><a href="#3-6-1查看状态（检测到工作区有文件被修改）" class="headerlink" title="3.6.1查看状态（检测到工作区有文件被修改）"></a>3.6.1查看状态（检测到工作区有文件被修改）</h4><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637306.png" alt="查看状态"></p><p>modified 红色：告诉我们该文件被修改了</p><h4 id="3-6-2-将修改的文件再次添加暂存区"><a href="#3-6-2-将修改的文件再次添加暂存区" class="headerlink" title="3.6.2 将修改的文件再次添加暂存区"></a>3.6.2 将修改的文件再次添加暂存区</h4><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637298.png" alt="将修改的文件再次添加暂存区"></p><h4 id="3-6-3-查看状态（工作区的修改添加到了暂存区）"><a href="#3-6-3-查看状态（工作区的修改添加到了暂存区）" class="headerlink" title="3.6.3 查看状态（工作区的修改添加到了暂存区）"></a>3.6.3 查看状态（工作区的修改添加到了暂存区）</h4><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151637186.png" alt="查看状态"></p><h3 id="3-7历史版本"><a href="#3-7历史版本" class="headerlink" title="3.7历史版本"></a>3.7历史版本</h3><h4 id="3-7-1-查看历史版本"><a href="#3-7-1-查看历史版本" class="headerlink" title="3.7.1 查看历史版本"></a>3.7.1 查看历史版本</h4><p>1）基本语法</p><p><strong>git reflog</strong> 查看版本信息</p><p><strong>git log</strong> 查看版本详细信息</p><p>2）案例实操</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638245.jpeg" alt="案例实操"></p><p>当指针HEAD指向该版本号时，cat hello.txt可以获取该版本号的文件内容</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638344.png" alt="案例实操"></p><h4 id="3-7-2版本穿梭"><a href="#3-7-2版本穿梭" class="headerlink" title="3.7.2版本穿梭"></a>3.7.2版本穿梭</h4><p>1）基本语法</p><p><strong>git reset –hard</strong> 版本号</p><p>2）案例实操</p><p>Step1：查看想要回退的版本号</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638728.png" alt="案例实操"></p><p>Step2：切换版本号</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638458.png" alt="案例实操"></p><p>Step3：切换成功后查看历史记录，可以看到成功切换到a9cbb5a版本</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638840.png" alt="案例实操"></p><p>此后在cat hello.txt可以看到a9cbb5a版本号的hello.txt</p><p>查看.git里的文件，HEAD是当前所在分支，refs-&gt;heads-&gt;master显示的是当前指向的版本号</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638564.png" alt="查看分支、版本号"></p><h2 id="4-Git分支操作"><a href="#4-Git分支操作" class="headerlink" title="4.Git分支操作"></a>4.Git分支操作</h2><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638549.png" alt="Git分支操作"></p><h3 id="4-1-什么是分支"><a href="#4-1-什么是分支" class="headerlink" title="4.1 什么是分支"></a>4.1 什么是分支</h3><p> 在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独 分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时 候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是 一个单独的副本。（分支底层其实也是指针的引用）</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638869.png" alt="什么是分支"></p><h3 id="4-2-分支的好处"><a href="#4-2-分支的好处" class="headerlink" title="4.2 分支的好处"></a>4.2 分支的好处</h3><p> 同时并行推进多个功能开发，提高开发效率。 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p><h3 id="4-3-分支的操作"><a href="#4-3-分支的操作" class="headerlink" title="4.3 分支的操作"></a>4.3 分支的操作</h3><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git branch 分支名</td><td align="center">git branch 分支名</td></tr><tr><td align="center">git branch -v</td><td align="center">查看分支</td></tr><tr><td align="center">git checkout 分支名</td><td align="center">切换分支</td></tr><tr><td align="center">git merge 分支名</td><td align="center">把指定的分支合并到当前分支</td></tr></tbody></table><h4 id="4-3-1-查看分支"><a href="#4-3-1-查看分支" class="headerlink" title="4.3.1 查看分支"></a>4.3.1 查看分支</h4><p>1）基本语法</p><p><strong>git branch -v</strong></p><p>2）案例实操</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638227.png" alt="案例实操"></p><h4 id="4-3-2创建分支"><a href="#4-3-2创建分支" class="headerlink" title="4.3.2创建分支"></a>4.3.2创建分支</h4><p>1）基本语法</p><p><strong>git branch 分支名</strong></p><p>2）案例实操</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638919.png" alt="案例实操"></p><h4 id="4-3-3-修改分支"><a href="#4-3-3-修改分支" class="headerlink" title="4.3.3 修改分支"></a>4.3.3 修改分支</h4><p>1）基本语法</p><p><strong>git checkout 分支名</strong></p><p>2）案例实操</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638930.png" alt="案例实操"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638335.png" alt="案例实操"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638994.png" alt="案例实操"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638786.png" alt="案例实操"></p><h4 id="4-3-5-合并分支"><a href="#4-3-5-合并分支" class="headerlink" title="4.3.5 合并分支"></a>4.3.5 合并分支</h4><p>1）基本语法</p><p><strong>git merge 分支名</strong></p><p>2）案例实操</p><p>在 master 分支上合并 hot-fix 分支</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638051.png" alt="案例实操"></p><h4 id="4-3-6-产生冲突"><a href="#4-3-6-产生冲突" class="headerlink" title="4.3.6 产生冲突"></a>4.3.6 产生冲突</h4><ul><li>冲突产生的表现：后面状态为 MERGING</li><li>冲突产生的原因：</li></ul><p>合并分支时，两个分支在<strong>同一个文件的同一个位置</strong>有两套完全不同的修改。Git 无法替 我们决定使用哪一个。必须<strong>人为决定</strong>新代码内容。</p><p>1）示例</p><p>Step1：在master分支上修改hello.txt并commit</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638108.png" alt="示例"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638646.png" alt="示例"></p><p>Step2：切换到hot-fix分支上修改hello.txt并commit</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638967.png" alt="示例"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638350.png" alt="示例"></p><p>Step3：切换分支回到master，在master分支上合并hot-fix分支</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638792.png" alt="示例"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638490.png" alt="示例"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638932.png" alt="示例"></p><h4 id="4-3-7-解决冲突"><a href="#4-3-7-解决冲突" class="headerlink" title="4.3.7 解决冲突"></a>4.3.7 解决冲突</h4><p>1）编辑有冲突的文件，删除特殊符号，决定要使用的内容 <strong>特殊符号：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 合并过来的代码 &gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</strong></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638978.png" alt="解决冲突"></p><p>2）添加到暂存区</p><p><strong>git add hello.txt</strong></p><p>3）执行提交（注意：此时使用 git commit 命令时<strong>不能带文件名</strong>）</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638106.png" alt="执行提交"></p><h3 id="4-4相关说明"><a href="#4-4相关说明" class="headerlink" title="4.4相关说明"></a>4.4相关说明</h3><p> master、hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD 决定的。所以创建分支的本质就是多创建一个指针。</p><p> HEAD 如果指向 master，那么我们现在就在 master 分支上。</p><p> HEAD 如果执行 hotfix，那么我们现在就在 hotfix 分支上。</p><p> 所以切换分支的本质就是移动 HEAD 指针。</p><h2 id="5-Git团队协作机制"><a href="#5-Git团队协作机制" class="headerlink" title="5.Git团队协作机制"></a>5.Git团队协作机制</h2><h3 id="5-1-团队内协作"><a href="#5-1-团队内协作" class="headerlink" title="5.1 团队内协作"></a>5.1 团队内协作</h3><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638017.png" alt="团队内协作"></p><h3 id="5-2-跨团队协作"><a href="#5-2-跨团队协作" class="headerlink" title="5.2 跨团队协作"></a>5.2 跨团队协作</h3><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638857.png" alt="跨团队合作"></p><h2 id="6-GitHub-操作"><a href="#6-GitHub-操作" class="headerlink" title="6.GitHub 操作"></a>6.GitHub 操作</h2><h3 id="6-1-创建远程仓库"><a href="#6-1-创建远程仓库" class="headerlink" title="6.1 创建远程仓库"></a>6.1 创建远程仓库</h3><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638786.png" alt="创建远程仓库"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151638812.png" alt="创建远程仓库"></p><h3 id="6-2-远程仓库操作"><a href="#6-2-远程仓库操作" class="headerlink" title="6.2 远程仓库操作"></a>6.2 远程仓库操作</h3><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git remote -v</td><td align="center">查看当前所有远程地址别名</td></tr><tr><td align="center">git remote add 别名 远程地址</td><td align="center">起别名</td></tr><tr><td align="center"><strong>git push 别名 分支</strong></td><td align="center"><strong>推送本地分支上的内容到远程仓库</strong></td></tr><tr><td align="center"><strong>git clone 远程地址</strong></td><td align="center"><strong>将远程仓库的内容克隆到本地</strong></td></tr><tr><td align="center"><strong>git pull 远程库地址别名 远程分支名</strong></td><td align="center"><strong>将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并</strong></td></tr></tbody></table><h4 id="6-2-1-创建远程仓库别名"><a href="#6-2-1-创建远程仓库别名" class="headerlink" title="6.2.1 创建远程仓库别名"></a>6.2.1 创建远程仓库别名</h4><p>1）基本语法</p><p><strong>git remote -v</strong> 查看当前所有远程地址别名</p><p><strong>git remote add</strong> <strong>别名 远程地址</strong></p><p>2）案例实操</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151639615.png" alt="在这里插入图片描述"></p><h4 id="6-2-2-推送本地分支到远程仓库"><a href="#6-2-2-推送本地分支到远程仓库" class="headerlink" title="6.2.2 推送本地分支到远程仓库"></a>6.2.2 推送本地分支到远程仓库</h4><p>1）基本语法</p><p><strong>git push 别名 分支</strong></p><p>2）案例实操</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151639334.png" alt="案例实操"></p><p>此时发现已将我们 master 分支上的内容推送到 GitHub 创建的远程仓库。</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151639552.png" alt="案例实操"></p><h4 id="6-2-3-克隆拉取远程仓库到本地"><a href="#6-2-3-克隆拉取远程仓库到本地" class="headerlink" title="6.2.3 克隆拉取远程仓库到本地"></a>6.2.3 克隆拉取远程仓库到本地</h4><p>1）基本语法</p><p><strong>git pull 别名 分支名</strong></p><p>2）案例实操</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151639525.png" alt="案例实操"></p><p><strong>拉取动作会自动提交到本地库</strong>，远程库代码会同步到本地库代码</p><h4 id="6-2-4-克隆远程仓库到本地"><a href="#6-2-4-克隆远程仓库到本地" class="headerlink" title="6.2.4 克隆远程仓库到本地"></a>6.2.4 克隆远程仓库到本地</h4><p>1）基本语法</p><p><strong>git clone 远程地址</strong></p><p>2）案例实操</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151639295.png" alt="案例实操"></p><p>clone 会做如下操作：</p><ul><li>拉取代码。</li><li>初始化本地仓库。</li><li>创建别名</li></ul><h4 id="6-2-4-邀请加入团队"><a href="#6-2-4-邀请加入团队" class="headerlink" title="6.2.4 邀请加入团队"></a>6.2.4 邀请加入团队</h4><h3 id="6-4-SSH-免密登录"><a href="#6-4-SSH-免密登录" class="headerlink" title="6.4 SSH 免密登录"></a>6.4 SSH 免密登录</h3><p>具体操作</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151639052.png" alt="具体操作"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306151639541.png" alt="具体操作"></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++</title>
    <link href="/2023/06/10/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/06/10/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1.类和对象"></a>1.类和对象</h2><h3 id="1-1封装"><a href="#1-1封装" class="headerlink" title="1.1封装"></a>1.1封装</h3><h3 id="1-2对象的初始化和清理"><a href="#1-2对象的初始化和清理" class="headerlink" title="1.2对象的初始化和清理"></a>1.2对象的初始化和清理</h3><h4 id="1-2-1构造函数和析构函数"><a href="#1-2-1构造函数和析构函数" class="headerlink" title="1.2.1构造函数和析构函数"></a>1.2.1构造函数和析构函数</h4><span id="more"></span><p>​对象的初始化和清理也是两个非常重要的安全问题。</p><p>​C++运用构造函数和析构函数解决了上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>​对象的初始化和清理工作是编译器强制我们要做的事，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数。</p><p>●构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</p><p>●析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。</p><p>构造函数语法：类名（）{ } </p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序调用对象时候回自动调用构造，无须手动调用，而且只会调用一次</li></ol><p>析构函数语法：~类名（）{ }</p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同，在名称前加上符号~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li></ol><h4 id="1-2-2构造函数的分类及调用"><a href="#1-2-2构造函数的分类及调用" class="headerlink" title="1.2.2构造函数的分类及调用"></a>1.2.2构造函数的分类及调用</h4><p>​两种分类方式：</p><p>​按参数分：有参构造和无参构造</p><p>​按类型分：普通构造和拷贝构造</p><p>​三种调用方式：</p><p>​括号法</p><p>​显示法</p><p>​隐式转换法</p><h4 id="1-2-3拷贝构造函数的调用时机"><a href="#1-2-3拷贝构造函数的调用时机" class="headerlink" title="1.2.3拷贝构造函数的调用时机"></a>1.2.3拷贝构造函数的调用时机</h4><p>​C++中拷贝构造函数调用时机通常有三种情况</p><p>​●使用一个已经创建完毕的对象来初始化一个新对象</p><p>​●值传递的方式给函数参数传值</p><p>​●以值方式返回局部对象</p><h4 id="1-2-4构造函数调用规则"><a href="#1-2-4构造函数调用规则" class="headerlink" title="1.2.4构造函数调用规则"></a>1.2.4构造函数调用规则</h4><p>​默认情况下，C++编译器至少给一个类添加3个函数</p><p>​1.默认构造函数（无参，函数体为空）</p><p>​2.默认析构函数（无参，函数体为空）</p><p>​3.默认拷贝构造函数，对属性值进行拷贝</p><p>构造函数调用规则如下：</p><p>​●如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造</p><p>​●如果用户定义拷贝构造函数，C++不会提供其他构造函数</p><h4 id="1-2-5深拷贝和浅拷贝"><a href="#1-2-5深拷贝和浅拷贝" class="headerlink" title="1.2.5深拷贝和浅拷贝"></a>1.2.5深拷贝和浅拷贝</h4><p>​浅拷贝：简单的赋值拷贝操作</p><p>​浅拷贝是编译器提供的简单的赋值操作，如果是地址，也只是简单的赋值（即指向相同的地址），那么在析构函数释放空间的时候便会带来错误。</p><p>​深拷贝：在堆区重新申请空间，进行拷贝操作。</p><p>​深拷贝是自己写拷贝构造函数，对于指针指向的地址，再开辟一个新的同类型数据的地址。</p><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span>* b;<br>    <span class="hljs-built_in">person</span>()<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;默认构造函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> _a,<span class="hljs-type">int</span> _b)<br>    &#123;<br>        a = _a;<br>        b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(_b);<br>    &#125;<br>    <span class="hljs-comment">// 再写一个深拷贝构造</span><br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person &amp;p)<br>    &#123;<br>        a= p.a;<br>        b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.b);<br>    &#125;<br>    ~<span class="hljs-built_in">person</span>()<br>    &#123;<br>        <span class="hljs-comment">//析构代码，将堆区开辟数据做释放操作</span><br>        <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> b;<br>            b = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;析构函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>,<span class="hljs-number">140</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="1-2-6初始化列表"><a href="#1-2-6初始化列表" class="headerlink" title="1.2.6初始化列表"></a>1.2.6初始化列表</h4><p>​作用：</p><p>​C++提供了初始化列表语法，用来初始化属性。</p><p>​语法：构造函数（）：属性1（值1），属性2（值2）····{ }</p><p>​</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a1,<span class="hljs-type">int</span> b1,<span class="hljs-type">int</span> c1) :<span class="hljs-built_in">a</span>(a1),<span class="hljs-built_in">b</span>(b1),<span class="hljs-built_in">c</span>(c1)<br>    &#123;<br>        <br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;a=&quot;</span>&lt;&lt;p.a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;b=&quot;</span>&lt;&lt;p.b&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;c=&quot;</span>&lt;&lt;p.c&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-7类对象作为类成员"><a href="#1-2-7类对象作为类成员" class="headerlink" title="1.2.7类对象作为类成员"></a>1.2.7类对象作为类成员</h4><p>​C++类中的成员可以是另一个类的对象，我们称该成员为对象成员</p><p>​</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">phone</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    string brand;<br>    <span class="hljs-built_in">phone</span>(string brand)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;brand = brand;<br>        cout&lt;&lt;<span class="hljs-string">&quot;phone构造函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">phone</span>()<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;phone析构函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    string name;<br>    phone phone_name;<br>    <span class="hljs-built_in">person</span>(string name ,string p_name):<span class="hljs-built_in">name</span>(name),<span class="hljs-built_in">phone_name</span>(p_name)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;person构造函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">person</span>()<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;person析构函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;name&lt;&lt;<span class="hljs-string">&quot;拿着&quot;</span>&lt;&lt;phone_name.brand&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;fengweiyi&quot;</span>,<span class="hljs-string">&quot;iphone&quot;</span>)</span></span>;<br>    p.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>​当类中成员是其他类对象是，我们称该成员为对象成员</p><p>​构造顺序是：先调用对象成员的构造，再调用本类构造</p><p>​析构顺序与构造顺序相反</p><h4 id="1-2-8静态成员"><a href="#1-2-8静态成员" class="headerlink" title="1.2.8静态成员"></a>1.2.8静态成员</h4><p>​静态成员就是成员变量和成员函数前加关键字“static”,称为静态成员</p><p>​静态成员分为：</p><p>​●静态成员变量</p><p>​○所有对象共享一份数据</p><p>​○在编译阶段分配内存</p><p>​○类内声明，类外初始化</p><p>故：静态成员变量不属于某“一个”对象，所有对象共享同一份数据</p><p>​因此静态成员变量有两种访问方式</p><ol><li>通过对象进行访问</li><li>通过类名进行访问</li></ol><p></p><p>静态成员变量访问权限有限：私有权限访问不到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> test0; <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> test1;<br>&#125;;<br><span class="hljs-type">int</span> person::test0 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> person::test1 = <span class="hljs-number">100</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//通过对象访问</span><br>    person p;<br>    p.test0 = <span class="hljs-number">100</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p.test0=&quot;</span>&lt;&lt;p.test0&lt;&lt;endl;<br><br>    person p1;<br>    p1.test0 = <span class="hljs-number">200</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p.test0=&quot;</span>&lt;&lt;p.test0&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p1.test0=&quot;</span>&lt;&lt;p1.test0&lt;&lt;endl;<br>    <span class="hljs-comment">//通过类名访问</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;test0 = &quot;</span>&lt;&lt;person::test0&lt;&lt;endl;<br>    <span class="hljs-comment">//cout&lt;&lt;&quot;test1 = &quot;&lt;&lt;person::test1&lt;&lt;endl;    私有权限访问不到</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>​●静态成员函数</p><p>​○所有对象共享同一个函数</p><p>​○静态成员函数只能访问静态成员变量</p><p>​○类外访问不到静态成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;static void func 调用&quot;</span>&lt;&lt;endl;<br>        test0 = <span class="hljs-number">100</span>;<br>    &#125;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> test0;<br>    <span class="hljs-type">int</span> test1;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;static void func1 调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> person::test0 = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    person p1;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p1.test0=&quot;</span>&lt;&lt;p1.test0&lt;&lt;endl;<br>    p1.<span class="hljs-built_in">func</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;p1.test0=&quot;</span>&lt;&lt;p1.test0&lt;&lt;endl;<br>    <span class="hljs-comment">// person::func1();类外访问不到</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3C-对象模型和this指针"><a href="#1-3C-对象模型和this指针" class="headerlink" title="1.3C++对象模型和this指针"></a>1.3C++对象模型和this指针</h3><h4 id="1-3-1成员变量和成员函数分开存储"><a href="#1-3-1成员变量和成员函数分开存储" class="headerlink" title="1.3.1成员变量和成员函数分开存储"></a>1.3.1成员变量和成员函数分开存储</h4><p>​在C++中，类内的成员变量和成员函数分开存储</p><p>​只有非静态成员变量才属于类的对象上（静态成员变量和静态成员函数和非静态成员函数都不属于类的对象）</p><p>​空对象占内存大小为：1</p><h4 id="1-3-2this指针的用途"><a href="#1-3-2this指针的用途" class="headerlink" title="1.3.2this指针的用途"></a>1.3.2this指针的用途</h4><p>​C++中成员变量和成员函数是分开存储的</p><p>​每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>​Q：这一块代码是如何区分哪个对象调用自己的呢？</p><p>​C++通过提供特殊的指针对象，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属对象。</strong></p><p>​this指针是隐含每一个非静态成员函数内的一种指针</p><p>​this指针不需要定义，直接使用即可</p><p>​this指针的用途：</p><p>​●当形参和成员变量同名时，可用this指针来区分</p><p>​●在类的非静态成员函数中返回对象本身，可使用return *this</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> age)<br>    &#123;   <span class="hljs-comment">//1、当形参和成员变量同名时，可用this指针来区分</span><br><br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br><br>    &#125;<br>    <span class="hljs-function">person&amp; <span class="hljs-title">personAddperson</span><span class="hljs-params">(person p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;age += p.age;<br>        <span class="hljs-comment">//返回对象本身</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    p2.<span class="hljs-built_in">personAddperson</span>(p1).<span class="hljs-built_in">personAddperson</span>(p1).<span class="hljs-built_in">personAddperson</span>(p1);<br>    cout&lt;&lt;<span class="hljs-string">&quot;p2的年龄:&quot;</span>&lt;&lt;p2.age;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-3空指针访问成员函数"><a href="#1-3-3空指针访问成员函数" class="headerlink" title="1.3.3空指针访问成员函数"></a>1.3.3空指针访问成员函数</h4><p>​C++中空指针也是可以调用成员函数的，但是要注意有没有用到this指针</p><p>​如果用到this指针，需要加以判断保证代码的健壮性(加上if语句做判断)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot;age=&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;age&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    person *p = <span class="hljs-literal">NULL</span>;<br>    p-&gt;<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-4const修饰成员函数"><a href="#1-3-4const修饰成员函数" class="headerlink" title="1.3.4const修饰成员函数"></a>1.3.4const修饰成员函数</h4><p>​const英文释义   不变的；</p><p>​mutable英文释义可变的；</p><p>​常函数：</p><p>​●成员函数后加<strong>const</strong>我们称这个函数为常函数</p><p>​●常函数内不可修改成员属性</p><p>​●成员属性声明时加关键字mutable后，在常函数中依然可以修改</p><p>​常对象：</p><p>​●声明对象前加<strong>const</strong>称该对象为常对象</p><p>​●常对象只能调用常函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> b;<br>    <span class="hljs-comment">// this 指针的本质是  指针常量   指针的指向是不可以修改的</span><br>    <span class="hljs-comment">//  </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// a = 100;    //  语句a=100会报错</span><br>        b = <span class="hljs-number">101</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot;b = &quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    person p1;<br>    p1.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-comment">//常对象</span><br>    <span class="hljs-type">const</span> person p;<br>    <span class="hljs-comment">// p.a = 100;  不可以改</span><br>    p.b = <span class="hljs-number">100</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对const关键字的补充："><a href="#对const关键字的补充：" class="headerlink" title="对const关键字的补充："></a>对const关键字的补充：</h4><p>​基本概念：const名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。</p><ol><li><h5 id="const修饰一般常量及数组："><a href="#const修饰一般常量及数组：" class="headerlink" title="const修饰一般常量及数组："></a><strong>const修饰一般常量及数组：</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> <span class="hljs-type">const</span> a = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">100</span>; <span class="hljs-comment">//与上面等价</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> arr [<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> arr [<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//与上面等价</span><br><br></code></pre></td></tr></table></figure><p>对于这些基本的数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。</p></li><li><h5 id="const修饰指针（-）"><a href="#const修饰指针（-）" class="headerlink" title="const修饰指针（*）"></a>const修饰指针（*）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;hello&quot;</span>;     <span class="hljs-comment">// 非const指针,</span><br>                       <span class="hljs-comment">// 非const数据</span><br><span class="hljs-comment">//既可以修改指针指向，也可以修改所指向的数据</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 非const指针,</span><br>                          <span class="hljs-comment">// const数据</span><br><span class="hljs-comment">//所指向的数据不可被修改，</span><br><span class="hljs-type">char</span> * <span class="hljs-type">const</span> p = <span class="hljs-string">&quot;hello&quot;</span>;   <span class="hljs-comment">// const指针,</span><br>                            <span class="hljs-comment">// 非const数据</span><br><span class="hljs-comment">//指针的指向不能被修改，为指针常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> p = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// const指针,</span><br>                                 <span class="hljs-comment">// const数据</span><br><span class="hljs-comment">//既不能修改指针指向，</span><br></code></pre></td></tr></table></figure><p>总结：</p><p>​如果const位于*的左侧，则就是修饰指针所指向的变量，即为常量指针</p><p>​如果const位于*的右侧，则就是修饰指针本身，即为指针常量</p><p>​通俗理解：<strong>左定值，又定向</strong></p></li><li><h5 id="const修饰函数参数："><a href="#const修饰函数参数：" class="headerlink" title="const修饰函数参数："></a><strong>const修饰函数参数：</strong></h5><p>修饰函数形参，函数体内不能修改形参的值。</p><p>const只能修饰输入作用的参数、</p></li><li><h5 id="const修饰函数返回值："><a href="#const修饰函数返回值：" class="headerlink" title="const修饰函数返回值："></a>const修饰函数返回值：</h5><p>对于值传递没必要将返回值用const修饰</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>当返回值为指针时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">char</span>* str = <span class="hljs-built_in">func</span>();<span class="hljs-comment">// error </span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-built_in">func</span>(); <span class="hljs-comment">//right</span><br><br></code></pre></td></tr></table></figure></li><li><h5 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a><strong>const修饰成员函数</strong></h5></li></ol><p>​const 修饰的成员函数为了保护成员变量，要求const 函数不能修改成员变量，否则编译会报错。</p><p>​函数体内不能修改成员变量的值，增加程序的健壮性或鲁棒性。<strong>只有成员函数才可以在后面加const，普通函数后加const无意义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="1-4友元"><a href="#1-4友元" class="headerlink" title="1.4友元"></a>1.4友元</h3><p>​在程序里，有些私有属性想让类外特殊的一些函数或者类进行访问，就需要用到<strong>友元</strong>技术</p><p>​友元的目的就是让一个函数或者类访问另一个类中私有成员</p><p>​友元的关键字为 <strong>friend</strong></p><p>​友元的三种实现：</p><p>​●全局函数做友元</p><p>​●类做友元</p><p>​●成员函数做友元</p><h4 id="1-4-1全局函数做友元"><a href="#1-4-1全局函数做友元" class="headerlink" title="1.4.1全局函数做友元"></a>1.4.1全局函数做友元</h4><p>​</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">building</span><br>&#123;   <span class="hljs-comment">// 声明全局友元函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">good_friend</span><span class="hljs-params">(building &amp;b)</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">building</span>()<br>    &#123;<br>        sitting_room = <span class="hljs-string">&quot;客厅&quot;</span>;<br>        bed_room = <span class="hljs-string">&quot;卧室&quot;</span>;<br>    &#125;<br>    <br>    string sitting_room;<br>    <span class="hljs-keyword">private</span>:<br>    string bed_room;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">good_friend</span><span class="hljs-params">(building &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;访问&quot;</span>&lt;&lt;b.bed_room&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    building b;<br>    <span class="hljs-built_in">good_friend</span>(b);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-2友元类"><a href="#1-4-2友元类" class="headerlink" title="1.4.2友元类"></a>1.4.2友元类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;   <span class="hljs-comment">//声明good_friend作为Building的友元类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">good_friend</span>;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>();<br>    string sitting_room;<br>    <span class="hljs-keyword">private</span>:<br>    string bed_room;<br>&#125;;<br><span class="hljs-comment">//类外创建构造函数必须在类内声明</span><br>Building::<span class="hljs-built_in">Building</span>()<br>&#123;<br>    sitting_room = <span class="hljs-string">&quot;客厅&quot;</span>;<br>    bed_room = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">good_friend</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    Building *building;<br>    <span class="hljs-built_in">good_friend</span>()<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;building = <span class="hljs-keyword">new</span> Building; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;访问&quot;</span>&lt;&lt;building-&gt;bed_room&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    good_friend ff;<br>    ff.<span class="hljs-built_in">visit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-2成员函数做友元"><a href="#1-4-2成员函数做友元" class="headerlink" title="1.4.2成员函数做友元"></a>1.4.2成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">good_friend</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    Building *building;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-built_in">good_friend</span>();<br>    <br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;   <span class="hljs-comment">// 声明good_friend中的visit成员函数作为作友元函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">good_friend::visit</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>();<br>    string sitting_room;<br>    <span class="hljs-keyword">private</span>:<br>    string bed_room;<br>&#125;;<br><span class="hljs-comment">//类外创建构造函数必须在类内声明</span><br>Building::<span class="hljs-built_in">Building</span>()<br>&#123;<br>    sitting_room = <span class="hljs-string">&quot;客厅&quot;</span>;<br>    bed_room = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br>good_friend::<span class="hljs-built_in">good_friend</span>()<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">good_friend::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;visit正在访问:&quot;</span>&lt;&lt;building-&gt;bed_room&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    good_friend ff;<br>    ff.<span class="hljs-built_in">visit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5运算符重载"><a href="#1-5运算符重载" class="headerlink" title="1.5运算符重载"></a>1.5运算符重载</h3><p>​运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。</p><h4 id="1-5-1加号运算符重载"><a href="#1-5-1加号运算符重载" class="headerlink" title="1.5.1加号运算符重载"></a>1.5.1加号运算符重载</h4><p>​作用：实现两个自定义数据类型的相加运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//运算符重载也可以发生函数重载  下面p3和p4就是eg</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//成员函数做“加号”运算符重载</span><br>    <span class="hljs-comment">//成员函数重载本质调用: person p3 = p1.operator+(p2);</span><br>    <span class="hljs-comment">// person operator+(person &amp;p)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     person temp;</span><br>    <span class="hljs-comment">//     temp.m_a = this-&gt;m_a + p.m_a;</span><br>    <span class="hljs-comment">//     temp.m_b = this-&gt;m_b + p.m_b;</span><br>    <span class="hljs-comment">//     return temp;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-type">int</span> m_b;<br>&#125;;<br><span class="hljs-comment">//全局函数做“加号”运算符重载</span><br><span class="hljs-comment">//全局函数运算符重载调用:person p3 = operator+(p1,p2);</span><br>person <span class="hljs-keyword">operator</span>+(person &amp;p1,person &amp;p2)<br>&#123;<br>    person temp;<br>    temp.m_a = p1.m_a + p2.m_a;<br>    temp.m_b = p1.m_b + p2.m_b;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br>person <span class="hljs-keyword">operator</span>+(person &amp;p,<span class="hljs-type">int</span> num)<br>&#123;<br>    person temp;<br>    temp.m_a = p.m_a + num;<br>    temp.m_b = p.m_b + num;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    person p1;<br>    p1.m_a = <span class="hljs-number">10</span>;<br>    p1.m_b = <span class="hljs-number">5</span>;<br>    person p2;<br>    p2.m_a = <span class="hljs-number">1</span>;<br>    p2.m_b = <span class="hljs-number">9</span>;<br>    person p3 = p1 + p2;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p3.m_a:&quot;</span>&lt;&lt;p3.m_a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p3.m_b:&quot;</span>&lt;&lt;p3.m_b&lt;&lt;endl;<br>    person p4 = p1 + <span class="hljs-number">10</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p4.m_a:&quot;</span>&lt;&lt;p4.m_a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p4.m_b:&quot;</span>&lt;&lt;p4.m_b&lt;&lt;endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-2左移运算符重载"><a href="#1-5-2左移运算符重载" class="headerlink" title="1.5.2左移运算符重载"></a>1.5.2左移运算符重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//通常不会利用成员函数重载&lt;&lt;，这样无法实现cout在&lt;&lt;的左侧 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;   <span class="hljs-keyword">friend</span> ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;cout,person &amp;p);<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_a = a;<br>        <span class="hljs-keyword">this</span>-&gt;m_b = b;<br>    &#125;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-type">int</span> m_b;<br>&#125;;<br><span class="hljs-comment">//全局函数实现左移重载</span><br><span class="hljs-comment">//ostream对象只能有一个</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;cout,person &amp;p)<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;m_a=&quot;</span>&lt;&lt;p.m_a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;m_b=&quot;</span>&lt;&lt;p.m_b&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> cout;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)</span></span>;<br>    cout&lt;&lt;p1&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//链式编程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型。</p><h4 id="1-5-3递增运算符重载"><a href="#1-5-3递增运算符重载" class="headerlink" title="1.5.3递增运算符重载"></a>1.5.3递增运算符重载</h4><p>​</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myInteger</span><br>&#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout,myInteger myint);<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">myInteger</span>()<br>    &#123;<br>        m_num = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//前置++重载</span><br>    myInteger&amp; <span class="hljs-keyword">operator</span>++()<br>    &#123;   <span class="hljs-comment">//先++</span><br>        m_num++;<br>        <span class="hljs-comment">//再返回</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>    &#125;<br>    <span class="hljs-comment">//后置++重载</span><br>    myInteger <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<br>    &#123;   <br>        myInteger temp = *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++</span><br>        m_num++;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_num;<br><br>&#125;;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout,myInteger myint)<br>&#123;<br>    cout&lt;&lt;myint.m_num&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> cout;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    myInteger myInt;<br>    cout&lt;&lt;++myInt&lt;&lt;endl;<br>    cout&lt;&lt;myInt&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    myInteger myInt;<br>    cout&lt;&lt;myInt++&lt;&lt;endl;<br>    cout&lt;&lt;myInt&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 总结：前置递增返回引用，后置递增返回值。</p><p>函数的值传递和引用传递</p><p>值传递：形参有自己的空间，对自己的空间中的参数的值进行修改，并不改变实参的值</p><p>引用传递：将作为实参变量的别名与其共用内存。</p><h4 id="1-5-4赋值运算符重载"><a href="#1-5-4赋值运算符重载" class="headerlink" title="1.5.4赋值运算符重载"></a>1.5.4赋值运算符重载</h4><p>​C++编译器至少给一个类添加四个函数</p><ol><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数，对属性值进行值拷贝</li><li>赋值运算符operator&#x3D;，对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题。</p><h4 id="1-5-5关系运算符重载"><a href="#1-5-5关系运算符重载" class="headerlink" title="1.5.5关系运算符重载"></a>1.5.5关系运算符重载</h4><p>​重载关系运算符，可以让两个自定义类型对象进行对比操作。</p><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//重载关系运算符</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span> <br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    string m_name;<br>    <span class="hljs-type">int</span> m_age;<br>    <span class="hljs-built_in">person</span>(string name,<span class="hljs-type">int</span> age)<br>    &#123;<br>        m_name = name;<br>        m_age = age;<br>    &#125;<br>    <span class="hljs-comment">//重载关系运算符</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(person&amp; p2)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;m_age == p2.m_age &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_name == p2.m_name)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-keyword">if</span>(p1 == p2)<br>    &#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p1和p2相等!&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p1和p2不相等!&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-6函数调用运算符重载"><a href="#1-5-6函数调用运算符重载" class="headerlink" title="1.5.6函数调用运算符重载"></a>1.5.6函数调用运算符重载</h4><ul><li><p>​函数调用符()也可以重载</p></li><li><p>​由于重载后使用的方式非常像函数调用，因此成为仿函数</p></li><li><p>​仿函数没有固定写法，非常灵活</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//函数调用符重载</span><br><span class="hljs-comment">//打印输出类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myprint</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string test)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;test&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdd</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> num1,<span class="hljs-type">int</span> num2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> num1 + num2;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    myprint mp;<br>    <span class="hljs-built_in">mp</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>); <span class="hljs-comment">//像函数调用</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyAdd myadd;<br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">myadd</span>(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;result=&quot;</span>&lt;&lt;result&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6继承"><a href="#1-6继承" class="headerlink" title="1.6继承"></a>1.6继承</h3><h4 id="1-6-1继承的基本语法"><a href="#1-6-1继承的基本语法" class="headerlink" title="1.6.1继承的基本语法"></a>1.6.1继承的基本语法</h4><pre><code class="hljs">     class 子类（派生类）：public  父类(基类)</code></pre><p>​public可以替换为private或者protect</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">human</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    string name = <span class="hljs-string">&quot;xiaoming&quot;</span>;<br>    <span class="hljs-type">int</span> age = <span class="hljs-number">18</span>;<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>:<span class="hljs-keyword">public</span> human<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> schoolnum = <span class="hljs-number">66666</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;name:&quot;</span>&lt;&lt;name&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;age:&quot;</span>&lt;&lt;age&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;schoolnum:&quot;</span>&lt;&lt;schoolnum&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    student st1;<br>    st1.<span class="hljs-built_in">print</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-6-2继承方式"><a href="#1-6-2继承方式" class="headerlink" title="1.6.2继承方式"></a>1.6.2继承方式</h4><p>​继承方式一共有三种：</p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306092145321.png" alt="image-20230409155625056"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base1</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_b;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_c;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base2</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_b;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_c;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base3</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_b;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_c;<br>&#125;;<br><span class="hljs-comment">//公有继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son1</span>:<span class="hljs-keyword">public</span> base1<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_a = <span class="hljs-number">10</span>;<span class="hljs-comment">//父类中的公共权限成员到子类中依然是公共权限</span><br>        m_b = <span class="hljs-number">10</span>;<span class="hljs-comment">//父类中的保护权限成员到子类中依然是保护权限</span><br>        <span class="hljs-comment">//m_c = 10;//父类中的私有权限成员，子类访问不到</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">//保护继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son2</span>:<span class="hljs-keyword">protected</span> base2<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_a = <span class="hljs-number">100</span>;<span class="hljs-comment">//父类中的公有成员到子类中变为了保护权限</span><br>        m_b = <span class="hljs-number">100</span>;<span class="hljs-comment">//父类中的保护成员到子类中依然是保护权限</span><br>        <span class="hljs-comment">//m_c为私有权限变量，不可访问</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">//私有继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son3</span>:<span class="hljs-keyword">private</span> base3<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_a = <span class="hljs-number">100</span>;<span class="hljs-comment">//父类中的公有成员   到子类中   变为私有成员</span><br>        m_b = <span class="hljs-number">100</span>;<span class="hljs-comment">//父类中的保护成员   到子类中   变为私有成员</span><br>        <span class="hljs-comment">// m_c不可访问 </span><br>    &#125;<br><br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">grandson3</span>:<span class="hljs-keyword">public</span> son3<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// m_a = 1000;m_a为父类（son3类）中的私有成员，故不能访问</span><br><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    son1 s1;<br>    s1.m_a = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// s1.m_b = 100; 到了son1中 m_b是保护权限，类外访问不到</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    son2 s2;<br>    <span class="hljs-comment">//s2.m_a = 1000; m_a,m_b均为保护权限，类外不能访问</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    son3 s3;<br>    <span class="hljs-comment">// s3.m_a = 1000;m_a,m_b,m_c均为私有成员，类外不能访问</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-6-3继承中的对象模型"><a href="#1-6-3继承中的对象模型" class="headerlink" title="1.6.3继承中的对象模型"></a>1.6.3继承中的对象模型</h4><p>​从父类继承过来的成员，均属于子类对象，只不过是父类中的私有成员继承到子类中被编译器隐藏了，所以访问不到。</p><p>​示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_b;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_c;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>:<span class="hljs-keyword">public</span> base<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_d;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//16</span><br>    <span class="hljs-comment">//父类中所有    非静态成员属性    都会被子类继承下去</span><br>    <span class="hljs-comment">//父类 中的私有成员属性是被编译器隐藏了，因此是访问不到，但是确实是被继承下去了</span><br>    cout&lt;&lt; <span class="hljs-string">&quot;size of son = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(son)&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><h4 id="1-6-4继承中的构造和析构的顺序"><a href="#1-6-4继承中的构造和析构的顺序" class="headerlink" title="1.6.4继承中的构造和析构的顺序"></a>1.6.4继承中的构造和析构的顺序</h4><p>​先构造父类，再构造子类，析构的顺序与构造的顺序相反</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">base</span>()<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;base的构造函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">base</span>()<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;base的析构函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>:<span class="hljs-keyword">public</span> base<br>&#123;<br>     <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">son</span>()<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;son的构造函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">son</span>()<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;son的析构函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    son s1;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>1.6.5继承同名成员处理方式</p><p>​当子类与父类出现同名的成员时，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员直接访问计科</li><li>访问父类同名成员    需要加作用域</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//继承中同名的成员变量和成员函数处理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">base</span>()<br>    &#123;<br>        a = <span class="hljs-number">100</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;base-func()的调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;base-func(int a)的调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span> : <span class="hljs-keyword">public</span> base<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">son</span>()<br>    &#123;<br>        a = <span class="hljs-number">200</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;son-func()的调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    son s1;<br>    cout&lt;&lt;<span class="hljs-string">&quot;son中的a= &quot;</span>&lt;&lt;s1.a&lt;&lt;endl;<span class="hljs-comment">//调用子类中的重名的变量直接调用即可</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;base中的a=&quot;</span>&lt;&lt;s1.base::a&lt;&lt;endl;<span class="hljs-comment">//调用父类中的重名的变量需要指明作用域    ::</span><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    son s1;<br>    s1.<span class="hljs-built_in">func</span>();<br>    s1.base::<span class="hljs-built_in">func</span>();<br>    <span class="hljs-comment">//s1.func(100);  当子类中出现和父类重名的成员函数，编译器会把所有父类中的重名函数进行隐藏，不考虑函数是否重载的情况</span><br>    <span class="hljs-comment">//如果要访问父类中的成员函数，就必须加作用域</span><br>    s1.base::<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名的成员函数，加作用域可以访问到父类中同名成员函数</li></ul><h4 id="1-6-6继承同名静态成员处理方式"><a href="#1-6-6继承同名静态成员处理方式" class="headerlink" title="1.6.6继承同名静态成员处理方式"></a>1.6.6继承同名静态成员处理方式</h4><p>​静态成员和非静态成员出现同名，处理方式一致</p><ul><li><p>访问子类同名成员直接访问即可</p></li><li><p>访问父类同名成员    需要加作用域</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//继承中同名的静态成员变量和成员函数处理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;   <br>        cout&lt;&lt;<span class="hljs-string">&quot;base-static void func()调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span> : <span class="hljs-keyword">public</span> base<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;   <br>        cout&lt;&lt;<span class="hljs-string">&quot;son-static void func()调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-type">int</span> base::a = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> son::a = <span class="hljs-number">200</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//通过对象名进行访问</span><br>    son s;<br>    cout&lt;&lt;<span class="hljs-string">&quot;son 下的a = &quot;</span>&lt;&lt;s.a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;base下的a = &quot;</span>&lt;&lt;s.base::a&lt;&lt;endl;<br>    <span class="hljs-comment">//通过类名进行访问</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;son 下的a = &quot;</span>&lt;&lt;son::a&lt;&lt;endl;<br>    <span class="hljs-comment">//第一个::代表通过类名方式访问   第二个::代表访问父类作用域</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;base下的a = &quot;</span>&lt;&lt;son::base::a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;base下的a = &quot;</span>&lt;&lt;base::a&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//通过对象名访问</span><br>    son s;<br>    s.<span class="hljs-built_in">func</span>();<br>    s.base::<span class="hljs-built_in">func</span>();<br>    <span class="hljs-comment">//通过类名的方式访问</span><br>    son::<span class="hljs-built_in">func</span>();<br>    son::base::<span class="hljs-built_in">func</span>();<br>    base::<span class="hljs-built_in">func</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>总结：同名的静态成员处理方式和非静态处理方式一样，但是有两种访问方式（可以通过类名或者对象名访问）</p><h4 id="1-6-7多继承语法"><a href="#1-6-7多继承语法" class="headerlink" title="1.6.7多继承语法"></a>1.6.7多继承语法</h4><p>​C++允许一个类继承多个类</p><p>​语法:class子类 ： 继承方式父类1，继承方式父类2···</p><p>​多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p>​C++实际开发中不建议用多继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//多继承语法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base1</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">base1</span>()<br>    &#123;<br>        a = <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base2</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">base2</span>()<br>    &#123;<br>        a = <span class="hljs-number">200</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span> : <span class="hljs-keyword">public</span> base1,<span class="hljs-keyword">public</span> base2<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-type">int</span> d;<br>    <span class="hljs-built_in">son</span>()<br>    &#123;<br>        c = <span class="hljs-number">300</span>;<br>        d = <span class="hljs-number">400</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    son s;<br>    cout&lt;&lt;<span class="hljs-string">&quot;sizeof son = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(s)&lt;&lt;endl;<br>    <span class="hljs-comment">// 当父类中出现同名成员，需要加作用域区分</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;s.base1::a = &quot;</span>&lt;&lt;s.base1::a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;s.base2::a = &quot;</span>&lt;&lt;s.base2::a&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​总结：多继承中如果父类中出现了同名情况，子类使用时要加作用域</p><h4 id="1-6-7菱形继承"><a href="#1-6-7菱形继承" class="headerlink" title="1.6.7菱形继承"></a>1.6.7菱形继承</h4><p>​菱形继承概念：</p><p>​两个子类继承同一个父类</p><p>​又有某个类同时继承了两个派生类</p><p>​这种继承方式被称为菱形继承，或者钻石继承。</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306092146749.png" alt="image-20230409211118080"></p><p>菱形继承问题：</p><ol><li>​羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性。</li><li>​    羊驼继承了动物的数据继承了两分，其实我们应该清楚，这份数据我们只需要一份就可以。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//动物类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-comment">//利用虚继承解决菱形继承的问题</span><br><span class="hljs-comment">//在继承之前加上关键字virtual变为虚继承</span><br><span class="hljs-comment">//animal类成为虚基类 </span><br><span class="hljs-comment">//羊类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sheep</span>:<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> animal&#123;&#125;;<br><br><span class="hljs-comment">//驼类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">camel</span>:<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> animal&#123;&#125;;<br><br><span class="hljs-comment">//羊驼类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">alpaca</span> : <span class="hljs-keyword">public</span> sheep,<span class="hljs-keyword">public</span> camel&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    alpaca a1;<br>    a1.sheep::age = <span class="hljs-number">18</span>;<br>    a1.camel::age = <span class="hljs-number">28</span>;<br>    <span class="hljs-comment">//当菱形继承时，两个父类拥有相同的数据，需要加以作用域区分</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a1.sheep::age = &quot;</span>&lt;&lt;a1.sheep::age&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;a1.camel::age = &quot;</span>&lt;&lt;a1.camel::age&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;a1.age = &quot;</span>&lt;&lt;a1.age&lt;&lt;endl;<br>    <span class="hljs-comment">//这份数据我们知道只要有一份就可以了，菱形继承导致有两份，造成资源浪费</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>菱形继承带来的主要问题是子类继承两分相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><p><strong>大小端存储</strong></p><p>​<strong>大端存储，是将数据的低位字节放到高地址处，高位字节放到低地址处。</strong></p><p>​    <strong>小端存储，是将数据的低位字节放到低地址处，高位字节放到高地址处。</strong></p><p>假设一个数据为0x12345678，地址空间为1-4</p><p>1中存放122中存放343中存放564中存放78，则为<strong>大端存储</strong></p><p>1中存放782中存放563中存放344中存放12，则为<strong>小端存储</strong></p><p>简单来说，<strong>大端存储</strong>是将数据按<strong>顺序存储</strong>，小端存储则为反序存储</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306092146798.png" alt="image-20230409215452274"></p><h3 id="1-7多态"><a href="#1-7多态" class="headerlink" title="1.7多态"></a>1.7多态</h3><h4 id="1-7-1多态的基本概念"><a href="#1-7-1多态的基本概念" class="headerlink" title="1.7.1多态的基本概念"></a>1.7.1多态的基本概念</h4><p>​多态是C++面向对象的三大特性之一。</p><p>​多态分为两类</p><ul><li>​静态多态：<strong>函数重载</strong> 和 <strong>运算符重载</strong>属于静态多态，复用函数名</li><li>​    动态多态：派生类和虚函数实现运行时多态</li></ul><p>​静态多态和动态多态的区别：</p><ul><li>静态多态的函数地址<strong>早</strong>绑定-<strong>编译阶段</strong>确定函数地址</li><li>动态多台的函数地址晚绑定-<strong>运行阶段</strong>确定函数地址</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;动物在说话&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span>:<span class="hljs-keyword">public</span> animal<br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;小猫在说话&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//地址早绑定   在编译阶段确定函数地址</span><br><span class="hljs-comment">//如果想执行让猫说话，这个函数地址就不能提前绑定，需要在运行阶段绑定</span><br><span class="hljs-comment">//动态多态的满足条件:</span><br><span class="hljs-comment">//1. 必须有继承关系</span><br><span class="hljs-comment">//2.子类要重写父类中的虚函数(对于子类的函数virtual关键字可写可不写)</span><br><span class="hljs-comment">//动态多态使用</span><br><span class="hljs-comment">//父类的指针或者引用执行子类对象</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dospeak</span><span class="hljs-params">(animal&amp; a)</span></span><br><span class="hljs-function"></span>&#123;<br>    a.<span class="hljs-built_in">speak</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cat c;<br>    <span class="hljs-built_in">dospeak</span>(c);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-7-2多态案例—计算器类"><a href="#1-7-2多态案例—计算器类" class="headerlink" title="1.7.2多态案例—计算器类"></a>1.7.2多态案例—计算器类</h4><p><strong>一个对象的空间&#x3D;所有成员变量的大小</strong><br><strong>如果这个对象的类有虚函数的话，还可能多一个指向虚表的指针</strong></p><p><strong>所有函数存放在独立于对象的存储空间内</strong><br>对象调用函数时，对静态成员函数直接调用不存在问题，<strong>对成员函数需要把自己以this指针传给函数以指明以哪个对象调用</strong></p><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//传统计算器的写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">caculator</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num1;<br>    <span class="hljs-type">int</span> num2;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">(string oper)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> num1 + num2;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> num1-num2;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper ==<span class="hljs-string">&quot;*&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> num1 * num2;           <br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    caculator c;<br>    c.num1 = <span class="hljs-number">10</span>;<br>    c.num2 = <span class="hljs-number">20</span>;<br>    cout&lt;&lt;c.num1&lt;&lt;<span class="hljs-string">&quot;+&quot;</span>&lt;&lt;c.num2 &lt;&lt;<span class="hljs-string">&quot; = &quot;</span>&lt;&lt;c.<span class="hljs-built_in">getresult</span>(<span class="hljs-string">&quot;+&quot;</span>)&lt;&lt;endl;<br>    cout&lt;&lt;c.num1&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;c.num2 &lt;&lt;<span class="hljs-string">&quot; = &quot;</span>&lt;&lt;c.<span class="hljs-built_in">getresult</span>(<span class="hljs-string">&quot;-&quot;</span>)&lt;&lt;endl;<br>    cout&lt;&lt;c.num1&lt;&lt;<span class="hljs-string">&quot;*&quot;</span>&lt;&lt;c.num2 &lt;&lt;<span class="hljs-string">&quot; = &quot;</span>&lt;&lt;c.<span class="hljs-built_in">getresult</span>(<span class="hljs-string">&quot;*&quot;</span>)&lt;&lt;endl;<br><br>&#125;<br><span class="hljs-comment">//利用多态实现计算器</span><br><span class="hljs-comment">//多态的优点</span><br><span class="hljs-comment">//1、组织结构清晰</span><br><span class="hljs-comment">//2、可读性强</span><br><span class="hljs-comment">//3、对于后期扩展性强，也便于维护</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">abstract_caculator</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num1;<br>    <span class="hljs-type">int</span> num2;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//加法计算器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Add_caculator</span>:<span class="hljs-keyword">public</span> abstract_caculator<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> num1 + num2;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//减法计算器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub_caculator</span>:<span class="hljs-keyword">public</span> abstract_caculator<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> num1 - num2;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//乘法计算器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mul_caculator</span>:<span class="hljs-keyword">public</span> abstract_caculator<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> num1 * num2;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//多态使用条件</span><br>    <span class="hljs-comment">//父类指针或者引用指向子类对象</span><br>    <span class="hljs-comment">//加法运算</span><br>    abstract_caculator * abc = <span class="hljs-keyword">new</span> Add_caculator;<br>    abc-&gt;num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;num2 = <span class="hljs-number">20</span>;<br>    cout&lt;&lt;abc-&gt;num1&lt;&lt;<span class="hljs-string">&quot;+&quot;</span>&lt;&lt;abc-&gt;num2 &lt;&lt;<span class="hljs-string">&quot; = &quot;</span>&lt;&lt;abc-&gt;<span class="hljs-built_in">getresult</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//用完后记得销毁</span><br>    <span class="hljs-keyword">delete</span> abc;<br>    <span class="hljs-comment">//减法运作算</span><br>    abc = <span class="hljs-keyword">new</span> Sub_caculator;<br>    abc-&gt;num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;num2 = <span class="hljs-number">20</span>;<br>    cout&lt;&lt;abc-&gt;num1&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;abc-&gt;num2 &lt;&lt;<span class="hljs-string">&quot; = &quot;</span>&lt;&lt;abc-&gt;<span class="hljs-built_in">getresult</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//用完后记得销毁</span><br>    <span class="hljs-keyword">delete</span> abc;<br>    abc = <span class="hljs-keyword">new</span> Mul_caculator;<br>    abc-&gt;num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;num2 = <span class="hljs-number">20</span>;<br>    cout&lt;&lt;abc-&gt;num1&lt;&lt;<span class="hljs-string">&quot;*&quot;</span>&lt;&lt;abc-&gt;num2 &lt;&lt;<span class="hljs-string">&quot; = &quot;</span>&lt;&lt;abc-&gt;<span class="hljs-built_in">getresult</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//用完后记得销毁</span><br>    <span class="hljs-keyword">delete</span> abc;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// test01();</span><br>    <span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-7-3纯虚函数和抽象类"><a href="#1-7-3纯虚函数和抽象类" class="headerlink" title="1.7.3纯虚函数和抽象类"></a>1.7.3纯虚函数和抽象类</h4><p>​在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>​因此可以将虚函数改为<strong>纯虚函数</strong></p><p>​纯虚函数语法：virtual 返回值类型 函数名(参数列表) &#x3D; 0;</p><p>​当类中有了纯虚函数，这个类也成为<strong>抽象类</strong></p><p>​<strong>抽象类特点：</strong></p><ul><li>​无法实例化对象</li><li>​    子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//纯虚函数</span><br>    <span class="hljs-comment">//只要有一个纯虚函数,这个类成为抽象类</span><br>    <span class="hljs-comment">//1、无法实例化对象</span><br>    <span class="hljs-comment">//2、抽象类的子类，必须重写父类中的纯虚函数，否则也属于抽象类</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;func调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Base b;      抽象类无法实例化对象</span><br>    <span class="hljs-comment">// new Base;    抽象类无法实例化对象</span><br>    Base *base = <span class="hljs-keyword">new</span> son;<br>    base-&gt;<span class="hljs-built_in">func</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-7-4多态案例二-制作饮品"><a href="#1-7-4多态案例二-制作饮品" class="headerlink" title="1.7.4多态案例二-制作饮品"></a>1.7.4多态案例二-制作饮品</h4><p>案例描述：</p><p>制作饮品的大致流程为：煮水-冲泡-倒入杯中-加入佐料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p>代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//多态案例2 制作饮品</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">abstract_drink</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//煮水</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">boil</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//冲泡</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">brew</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//倒入杯中</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">pour_in_cup</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//加入辅料</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">putsomething</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//制作饮品</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makedrink</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">boil</span>();<br>        <span class="hljs-built_in">brew</span>();<br>        <span class="hljs-built_in">pour_in_cup</span>();<br>        <span class="hljs-built_in">putsomething</span>();<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">coffee</span>:<span class="hljs-keyword">public</span> abstract_drink<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//煮水</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">boil</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;煮农夫山泉&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//冲泡</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">brew</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;冲雀巢咖啡&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//倒入杯中</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">pour_in_cup</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;倒入农夫山泉桶&quot;</span>&lt;&lt;endl;<br><br>    &#125;<br>    <span class="hljs-comment">//加入辅料</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">putsomething</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;加糖&quot;</span>&lt;&lt;endl;<br>        <br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tea</span>:<span class="hljs-keyword">public</span> abstract_drink<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//煮水</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">boil</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;煮百岁山&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//冲泡</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">brew</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;冲龙井&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//倒入杯中</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">pour_in_cup</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;倒入吨吨桶&quot;</span>&lt;&lt;endl;<br><br>    &#125;<br>    <span class="hljs-comment">//加入辅料</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">putsomething</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;加枸杞&quot;</span>&lt;&lt;endl;<br>        <br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dowork</span><span class="hljs-params">(abstract_drink *abs)</span></span><br><span class="hljs-function"></span>&#123;<br>    abs-&gt;<span class="hljs-built_in">makedrink</span>();<br>    <span class="hljs-keyword">delete</span> abs;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">dowork</span>(<span class="hljs-keyword">new</span> coffee);<br>    <span class="hljs-built_in">dowork</span>(<span class="hljs-keyword">new</span> tea);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br><span class="hljs-comment">//此代码有warning：没有在基类进行虚析构</span><br></code></pre></td></tr></table></figure><h4 id="1-7-5虚析构和纯虚析构"><a href="#1-7-5虚析构和纯虚析构" class="headerlink" title="1.7.5虚析构和纯虚析构"></a>1.7.5虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区（定义指针的成员变量），那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p>virtual ~类名( ){ }</p><p>纯虚析构语法：</p><p>virtual ~l类名( ）&#x3D; 0;</p><p>类名：：~类名（ ）{ }</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">animal</span>()<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;animal的构造函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//利用虚析构可以解决  父类指针释放子类对象时不干净的问题</span><br>    <span class="hljs-comment">// virtual ~animal()</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;&quot;animal的虚析构函数&quot;&lt;&lt;endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">//纯虚析构</span><br>    <span class="hljs-comment">//纯虚析构需要声明   也需要实现</span><br>    <span class="hljs-comment">//有了纯虚析构之后，这个类也属于抽象类，无法实例化对象</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">animal</span>() = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br>animal::~<span class="hljs-built_in">animal</span>()<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;animal的纯虚析构函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span> : <span class="hljs-keyword">public</span> animal<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    string *name;<br>    <span class="hljs-built_in">cat</span>(string name)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;cat的构造函数&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;* <span class="hljs-keyword">this</span>-&gt;name&lt;&lt;<span class="hljs-string">&quot;小猫在说话&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">cat</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (name != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;cat的析构函数&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">delete</span> name;<br>            name = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    animal *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">cat</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>    a-&gt;<span class="hljs-built_in">speak</span>();<br>    <span class="hljs-keyword">delete</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ol><li>虚析构或者纯虚析构是用来解决弗雷指针释放子类对象</li><li>如果子类中没有堆区数据，可以不写为虚析构或者纯虚析构</li><li>拥有纯虚析构函数的类也属于抽象类</li></ol><h4 id="1-7-6多态案例三-电脑组装"><a href="#1-7-6多态案例三-电脑组装" class="headerlink" title="1.7.6多态案例三-电脑组装"></a>1.7.6多态案例三-电脑组装</h4><p>案件描述：</p><p>电脑主要组成部件为CPU，显卡，内存条</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//抽象不同零件类</span><br><span class="hljs-comment">//抽象cpu类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cpu</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//抽象计算函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">caculate</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">cpu</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br>cpu::~<span class="hljs-built_in">cpu</span>()<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;cpu的纯虚析构函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-comment">//抽象显卡类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">video_card</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//抽象显示函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">video_card</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br>video_card::~<span class="hljs-built_in">video_card</span>()<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;video_card的纯虚析构函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//抽象内存类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">memory</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//抽象存储函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">memory</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br>memory::~<span class="hljs-built_in">memory</span>()<br>&#123;<br>     cout&lt;&lt;<span class="hljs-string">&quot;memory的纯虚析构函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//抽象电脑类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">computer</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">computer</span>(cpu *c,video_card *vc,memory *mmr)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;c = c;<br>        <span class="hljs-keyword">this</span>-&gt;v = vc;<br>        <span class="hljs-keyword">this</span>-&gt;m = mmr;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        c-&gt;<span class="hljs-built_in">caculate</span>();<br>        v-&gt;<span class="hljs-built_in">display</span>();<br>        m-&gt;<span class="hljs-built_in">storage</span>();<br>    &#125;<br>    <span class="hljs-comment">//提供析构函数，释放三个电脑零件</span><br>    ~<span class="hljs-built_in">computer</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(c !=  <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> c;<br>            c = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(v !=  <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> v;<br>            v = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(m !=  <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m;<br>            m = <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">private</span>:<br>    cpu *c;             <span class="hljs-comment">//cpu零件指针</span><br>    video_card *v;      <span class="hljs-comment">//显卡指针</span><br>    memory *m;          <span class="hljs-comment">//内存条指针</span><br>&#125;;<br><span class="hljs-comment">//具体厂商</span><br><span class="hljs-comment">//Intel厂商cpu</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Intelcpu</span> : <span class="hljs-keyword">public</span> cpu<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">caculate</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Intel的CPU开始计算了&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Intel厂商显卡</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelVideoCard</span> : <span class="hljs-keyword">public</span> video_card<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Intel的显卡开始显示了&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Intel厂商内存</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelMemory</span> : <span class="hljs-keyword">public</span> memory<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Intel的内存开始存储了&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Lenovo厂商cpu</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lenovocpu</span> : <span class="hljs-keyword">public</span> cpu<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">caculate</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Lenovo的CPU开始计算了&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Lenovo厂商显卡</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoVideoCard</span> : <span class="hljs-keyword">public</span> video_card<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Lenovo的显卡开始显示了&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Lenovo厂商内存</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoMemory</span> : <span class="hljs-keyword">public</span> memory<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Lenovo的内存开始存储了&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//第一台电脑零件</span><br>    cpu *intelcpu = <span class="hljs-keyword">new</span> Intelcpu;<br>    video_card *intelvideocard = <span class="hljs-keyword">new</span> IntelVideoCard;<br>    memory *intelMemory = <span class="hljs-keyword">new</span> IntelMemory;<br>    <span class="hljs-comment">//创建第一台电脑</span><br>    computer *c1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">computer</span>(intelcpu,intelvideocard,intelMemory);<br>    c1-&gt;<span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">delete</span> c1;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2.文件操作"></a>2.文件操作</h2><p>​程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>​通过<strong>文件可以将数据持久化</strong></p><p>​C++中对文件操作需要包含头文件<fstream></p><p>​</p><p>​文件类型分为两种：</p><ol><li>​文本文件-文件以文本的ASCII码形式存储在计算机中</li><li>​    二进制文件-文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>​操作文件的三大类：</p><ol><li>​ofstream：写操作</li><li>​    ifstream： 读操作</li><li>​    fstream： 读写操作</li></ol><h3 id="2-1文本文件"><a href="#2-1文本文件" class="headerlink" title="2.1文本文件"></a>2.1文本文件</h3><h4 id="2-1-1写文件"><a href="#2-1-1写文件" class="headerlink" title="2.1.1写文件"></a>2.1.1写文件</h4><p>​写文件步骤如下：</p><p>​1.包含头文件</p><p>​#include<fstream></p><p>​2.创建流对象</p><p>​ofstream ofs;</p><p>​3.打开文件</p><p>​ofs.open(“文件路径”,打开方式);</p><p>​4.写数据</p><p>​ofs&lt;&lt;”写入的数据”;</p><p>​5.关闭文件</p><p>​ofs.close();</p><p>​文件打开方式：</p><p>​</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，在创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意</strong>：文件打开方式可以配合使用，利用   |    操作符</p><p><strong>例如：</strong>用二进制方式写文件ios ::binary | ios::in</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//文本文件    写文件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建流对象</span><br>    ofstream ofs;<br>    <span class="hljs-comment">//指定打开方式</span><br>    ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,ios::out);<br>    <span class="hljs-comment">//写内容</span><br>    ofs&lt;&lt;<span class="hljs-string">&quot;姓名:jia&quot;</span>&lt;&lt;endl;<br>    ofs&lt;&lt;<span class="hljs-string">&quot;性别:女&quot;</span>&lt;&lt;endl;<br>    ofs&lt;&lt;<span class="hljs-string">&quot;年龄:70&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-comment">//关闭文件</span><br>    ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><p>文件操作必须包含头文件fstream</p></li><li><p>读文件可以利用ofstream,或者fstream类</p></li><li><p>打开文件时候需要指定操作文件的路径以及打开方式</p></li><li><p>利用&lt;&lt;可以向文件中写入数据</p></li><li><p>操作完毕，要关闭文件</p></li></ul><h4 id="2-1-2读文件"><a href="#2-1-2读文件" class="headerlink" title="2.1.2读文件"></a>2.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对来说比较多</p><p>读文件步骤如下：</p><p>1.包含头文件</p><p>​#include<fstream></p><p>2.创建流对象</p><p>​ifstream ifs;</p><p>3.打开文件并判断文件是否打开成功</p><p>​ifs.open(“文件路径”,打开方式);</p><p>4.读数据</p><p>​四种方式读取</p><ul><li>​ifs&gt;&gt;buf                                 buf是字符数组   char[ ] </li><li>​    ifs.getline(buf,sizeof(buf))     buf是字符数组    char[ ] </li><li>​    getline(ifs,buf)                       buf是字符串  string</li><li>​    (c &#x3D; ifs.get()) !&#x3D; EOF             c是字符  char</li></ul><p>5.关闭文件</p><p>​ifs.close();</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//文本文件  读文件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建流对象</span><br>    ifstream ifs;<br>    <span class="hljs-comment">//打开文件   并且判断是否打开成功</span><br>    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,ios::in);<br>    <span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>())<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;文件打开失败&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//读数据 四种</span><br>    <br>    <span class="hljs-comment">//第一种</span><br>    <span class="hljs-comment">// char buf[1024] = &#123;0&#125;;</span><br>    <span class="hljs-comment">// while (ifs&gt;&gt;buf) </span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;buf&lt;&lt;endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">//第二种</span><br>    <span class="hljs-comment">// char buf[1024] = &#123;0&#125;;</span><br>    <span class="hljs-comment">// while(ifs.getline(buf,sizeof(buf)))</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;buf&lt;&lt;endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">//第三种</span><br>    <span class="hljs-comment">// string buf;</span><br>    <span class="hljs-comment">// while(getline(ifs,buf))</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;buf&lt;&lt;endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">//第四种</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">while</span> ((c = ifs.<span class="hljs-built_in">get</span>()) != EOF)<br>    &#123;<br>        cout&lt;&lt;c;<br>    &#125;<br>    <span class="hljs-comment">//关闭文件</span><br>    ifs.<span class="hljs-built_in">close</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2二进制文件"><a href="#2-2二进制文件" class="headerlink" title="2.2二进制文件"></a>2.2二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ios::binary</p><h4 id="2-2-1写文件"><a href="#2-2-1写文件" class="headerlink" title="2.2.1写文件"></a>2.2.1写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型：ostream&amp; write(const char *buffer,int len);</p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//二进制文件   写文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span> m_name[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-comment">//创建流对象</span><br>    ofstream ofs;<br>    ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;person.txt&quot;</span>,ios::out | ios::binary);<br>    <span class="hljs-comment">//写文件</span><br>    person p = &#123;<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>&#125;;<br>    ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)&amp;p,<span class="hljs-built_in">sizeof</span>(person));<br>    ofs.<span class="hljs-built_in">close</span>();<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2写文件"><a href="#2-2-2写文件" class="headerlink" title="2.2.2写文件"></a>2.2.2写文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：istream&amp; read(char *buffer,int len);</p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//二进制文件   读文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span> m_name[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建流对象</span><br>    ifstream ifs;<br>    <span class="hljs-comment">//打开文件  判断文件是否打开成功</span><br>    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;person.txt&quot;</span>,ios::in|ios::binary);<br>    <span class="hljs-keyword">if</span>(!ifs.<span class="hljs-built_in">is_open</span>())<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;文件打开失败&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//读文件</span><br>    person p;<br>    ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(person));<br>    cout&lt;&lt;<span class="hljs-string">&quot;姓名:&quot;</span>&lt;&lt;p.m_name&lt;&lt;<span class="hljs-string">&quot;年龄:&quot;</span>&lt;&lt;p.m_age&lt;&lt;endl;<br>    <span class="hljs-comment">//关闭文件</span><br>    ifs.<span class="hljs-built_in">close</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-进阶编程"><a href="#C-进阶编程" class="headerlink" title="C++进阶编程"></a>C++进阶编程</h1><ul><li>本阶段主要针对C++<u>泛型编程</u>和<u>STL</u>技术做详解，探讨C++更深层的使用</li></ul><h2 id="1模板"><a href="#1模板" class="headerlink" title="1模板"></a>1模板</h2><h3 id="1-1模板的概念"><a href="#1-1模板的概念" class="headerlink" title="1.1模板的概念"></a>1.1模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p><p>例如生活中的模板</p><ul><li>一寸照片的模板</li><li>PPT模板</li></ul><p>模板的特点：</p><ul><li>模板不可以直接使用，他只是一个框架</li><li>模板的通用并不是万能的</li></ul><h3 id="1-2函数模板"><a href="#1-2函数模板" class="headerlink" title="1.2函数模板"></a>1.2函数模板</h3><ul><li>C++另一种编程思想称为泛型编程，主要利用的技术就是模板</li><li>C++提供两种模板机制：<strong>函数模板</strong>和<strong>类模板</strong></li></ul><h4 id="1-2-1函数模板语法"><a href="#1-2-1函数模板语法" class="headerlink" title="1.2.1函数模板语法"></a>1.2.1函数模板语法</h4><p>函数模板作用：</p><p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>代表</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-comment">//函数声明或定义</span><br></code></pre></td></tr></table></figure><p>解释：</p><p>template — 声明创建模板</p><p>typename —表明其后面的符号是一种数据类型，可以用class代替</p><p>T   —通用的数据类型，名称可以替换，通常为大写字母</p><p> 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//两个整型交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapInt</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><span class="hljs-comment">//两个浮点型交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapFloat</span><span class="hljs-params">(<span class="hljs-type">float</span> &amp;a,<span class="hljs-type">float</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><span class="hljs-comment">//两个double交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapDouble</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;a,<span class="hljs-type">double</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    <span class="hljs-comment">//声明一个模板，告诉编译器后面的T不要报错，T是一个通用数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T &amp;a,T &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    T temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-comment">// swapInt(a, b);</span><br>    <span class="hljs-comment">//利用函数模板来交换</span><br>    <span class="hljs-comment">//两种方式使用函数模板</span><br>    <span class="hljs-comment">//1.自动类型推导</span><br>    <span class="hljs-built_in">mySwap</span>(a, b);<br>    <span class="hljs-comment">//2、显示指定类型</span><br>    <span class="hljs-built_in">mySwap</span>&lt;<span class="hljs-type">int</span>&gt;(a, b);<br>    cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;b = &quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    <span class="hljs-comment">// float c = 10.1;</span><br>    <span class="hljs-comment">// float d = 20.3;</span><br>    <span class="hljs-comment">// swapFloat(c,d);</span><br>    <span class="hljs-comment">// cout&lt;&lt;&quot;c = &quot;&lt;&lt;c&lt;&lt;endl;</span><br>    <span class="hljs-comment">// cout&lt;&lt;&quot;d = &quot;&lt;&lt;d&lt;&lt;endl;</span><br><br>&#125;<br><span class="hljs-comment">//函数模板  </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>函数模板利用关键字template</li><li>使用函数模板有两种方式：自动类型推导、显示指定类型</li><li>模板的目的是为了提高复用性，将类型参数化</li></ul><h4 id="1-2-1函数模板注意事项"><a href="#1-2-1函数模板注意事项" class="headerlink" title="1.2.1函数模板注意事项"></a>1.2.1函数模板注意事项</h4><p>注意事项：</p><ul><li>自动类型推导，必须推导出一致的数据类型T，才可以使用</li><li>模板必须要确定出T的数据类型，才可以使用</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//函数模板注意事项</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-comment">//typename可以替换成class </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T &amp;a,T&amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    T temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><span class="hljs-comment">//1、自动类型推导，必须推导出一致的数据类型T才可以使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<br>    <span class="hljs-built_in">mySwap</span>(a, b);<span class="hljs-comment">//正确</span><br>    <span class="hljs-comment">// mySwap(a, c);//错误!推导不出一致的数据类型</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;b = &quot;</span>&lt;&lt;b&lt;&lt;endl;<br><br>&#125;<br><br><span class="hljs-comment">//2、模板必须要确定出T的数据类型，才可以使用</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;func调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li></ul><h4 id="1-2-3函数模板案例"><a href="#1-2-3函数模板案例" class="headerlink" title="1.2.3函数模板案例"></a>1.2.3函数模板案例</h4><p>案例描述：</p><ul><li>利用函数模板封装一个排序函数，可以对<strong>不同数据类型数组</strong>进行排序</li><li>排序规则从大到小，排序算法为<strong>选择排序</strong></li><li>分别利用char数组和<strong>int数组</strong>进行测试</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//实现通用 对数组进行排序的函数</span><br><span class="hljs-comment">//规则从大到小   选择排序</span><br><span class="hljs-comment">//排序算法</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T &amp;a,T &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    T temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T arr[],<span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;len;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> max = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt; len;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (arr[max]&lt;arr[j])<br>            &#123;<br>                max = j;<span class="hljs-comment">//更新最大值下标</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(max != i)<br>        &#123;<br>        <span class="hljs-comment">//交换max和i元素</span><br>        <span class="hljs-built_in">mySwap</span>(arr[max], arr[i]);<br>        &#125;<br><br>    &#125;<br>    <br>&#125;<br><span class="hljs-comment">//提供打印数组的模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(T arr[],<span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;len;i++)<br>    &#123;<br>        cout&lt;&lt;arr[i]&lt;&lt;<span class="hljs-string">&quot;   &quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//测试char数组</span><br>    <span class="hljs-type">char</span> charArr[] = <span class="hljs-string">&quot;ghjfdew&quot;</span>;<br>    <span class="hljs-type">int</span> num = <span class="hljs-built_in">sizeof</span>(charArr)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>);<br>    <span class="hljs-built_in">sort</span>(charArr, num);<br>    <span class="hljs-built_in">printArray</span>(charArr, num);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//测试int数组</span><br>    <span class="hljs-type">int</span> intArr[] = &#123;<span class="hljs-number">56</span>,<span class="hljs-number">8</span>,<span class="hljs-number">93</span>,<span class="hljs-number">40</span>,<span class="hljs-number">69</span>,<span class="hljs-number">23</span>&#125;;<br>    <span class="hljs-type">int</span> num = <span class="hljs-built_in">sizeof</span>(intArr)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>    <span class="hljs-built_in">sort</span>(intArr, num);<br>    <span class="hljs-built_in">printArray</span>(intArr, num);<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">test02</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-4普通函数与模板函数的区别"><a href="#1-2-4普通函数与模板函数的区别" class="headerlink" title="1.2.4普通函数与模板函数的区别"></a>1.2.4普通函数与模板函数的区别</h4><p>普通函数与模板函数区别：</p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>模板函数调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//普通函数调用时可以发生自动类型转换（隐式类型转换）</span><br><span class="hljs-comment">//模板函数调用时，如果利用自动类型推导，不会发生隐式类型转换</span><br><span class="hljs-comment">//如果利用显示指定类型的方式，可以发生隐式类型转换</span><br><br><span class="hljs-comment">//普通函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myadd1</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-comment">//模板函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">myadd2</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">myadd1</span>(a, c)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">myadd2</span>(a, b)&lt;&lt;endl;<br>    <span class="hljs-comment">// cout&lt;&lt;myadd2(a, c)&lt;&lt;endl;</span><br>    cout&lt;&lt;<span class="hljs-built_in">myadd2</span>&lt;<span class="hljs-type">int</span>&gt;(a, c);<br><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-5普通函数与函数模板的调用规则"><a href="#1-2-5普通函数与函数模板的调用规则" class="headerlink" title="1.2.5普通函数与函数模板的调用规则"></a>1.2.5普通函数与函数模板的调用规则</h4><p>调用规则如下：</p><ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板</li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 如果函数模板和普通函数都可以实现，优先调用普通函数</span><br><span class="hljs-comment">2. 可以通过空模板参数列表来强制调用函数模板</span><br><span class="hljs-comment">3. 函数模板也可以发生重载</span><br><span class="hljs-comment">4. 如果函数模板可以产生更好的匹配，优先调用函数模板</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;调用普通函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;调用函数模板2&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">(T a,T b,T c)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;调用函数模板3&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">myprint</span>(a,b);   <span class="hljs-comment">//调用普通函数</span><br>    <span class="hljs-comment">//通过空模板的参数列表强制调用</span><br>    myprint&lt;&gt;(a,b); <span class="hljs-comment">//调用函数模板</span><br>    <span class="hljs-built_in">myprint</span>(a,b,<span class="hljs-number">100</span>);   <span class="hljs-comment">//重载函数调用</span><br>    <span class="hljs-comment">//如果函数模板产生更好的匹配，优先调用函数模板</span><br>    <span class="hljs-type">char</span> c1 = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-type">char</span> c2 = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    <span class="hljs-built_in">myprint</span>(c1,c2);     <span class="hljs-comment">//调用模板</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性。</p><h4 id="1-2-6模板的局限性"><a href="#1-2-6模板的局限性" class="headerlink" title="1.2.6模板的局限性"></a>1.2.6模板的局限性</h4><p>局限性：模板的通用性并不是万能的</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>    a = b;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p><p>再例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;b)&#123;    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p><p>因为C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化模板</strong></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">person</span>(string name,<span class="hljs-type">int</span> age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name = name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age = age;<br>    &#125;<br>    string m_name;<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(T &amp;a,T &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a==b)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//利用具体化person的版本实现代码,具体化优先调用</span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(person &amp;a,person &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.m_name==b.m_name &amp;&amp; a.m_age == b.m_age)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">bool</span> ret = <span class="hljs-built_in">myCompare</span>(a, b);<br>    <span class="hljs-keyword">if</span>(ret)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;a==b&quot;</span>&lt;&lt;endl;<br><br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>           cout&lt;&lt;<span class="hljs-string">&quot;a!=b&quot;</span>&lt;&lt;endl;<br><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-type">bool</span> ret = <span class="hljs-built_in">myCompare</span>(p1, p2);<br>    <span class="hljs-keyword">if</span>(ret)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;p1==p2&quot;</span>&lt;&lt;endl;<br><br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;p1!=p2&quot;</span>&lt;&lt;endl;<br><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul><h3 id="1-3类模板"><a href="#1-3类模板" class="headerlink" title="1.3类模板"></a>1.3类模板</h3><h4 id="1-3-1类模板语法"><a href="#1-3-1类模板语法" class="headerlink" title="1.3.1类模板语法"></a>1.3.1类模板语法</h4><p>类模板作用：</p><p>建立一个通用类，类中的成员数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>类<br></code></pre></td></tr></table></figure><p>解释：</p><p>template —  声明创建模板</p><p>typename — 表面其后面的附后是一种数据类型，可以用class代替</p><p>T — 通用的数据类型，名称可以替换，通常为大写字母</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">person</span>(NameType name,AgeType age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name = name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;name:&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_name&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>&lt;&lt;<span class="hljs-string">&quot;age:&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>    NameType m_name;<br>    AgeType m_age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong&quot;</span>,<span class="hljs-number">999</span>)</span></span>;<br>    p1.<span class="hljs-built_in">show</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-2类模板与函数模板区别"><a href="#1-3-2类模板与函数模板区别" class="headerlink" title="1.3.2类模板与函数模板区别"></a>1.3.2类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p><ol><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//类模板和函数模板的区别</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span> = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> person<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    AgeType m_age;<br>    NameType m_name;<br>    <span class="hljs-built_in">person</span>(NameType name,AgeType age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name = name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_person</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;name:&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_name&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;age:&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//类模板没有自动类型推导的使用方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-number">1000</span>)</span></span>;    <span class="hljs-comment">//C++之前的版本不可以，但是新版本已经支持自动推导了</span><br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;汤普森&quot;</span>,<span class="hljs-number">32</span>)</span></span>;     <span class="hljs-comment">//只能用显示推导</span><br>    p.<span class="hljs-built_in">show_person</span>();<br>    p1.<span class="hljs-built_in">show_person</span>();<br>&#125;<br><span class="hljs-comment">//类模板在模板参数列表中可以有默认参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;库里&quot;</span>,<span class="hljs-number">33</span>)</span></span>;<br>    p2.<span class="hljs-built_in">show_person</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// test01();</span><br>    <span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-3类模板中成员函数创建时机"><a href="#1-3-3类模板中成员函数创建时机" class="headerlink" title="1.3.3类模板中成员函数创建时机"></a>1.3.3类模板中成员函数创建时机</h4><p>类模板成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//类模板中成员函数调用时机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person1</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_person1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;show person1&quot;</span>&lt;&lt;endl;<br><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person2</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_person2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;show person2&quot;</span>&lt;&lt;endl;<br><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    T obj;<br>    <span class="hljs-comment">//类模板中的成员函数</span><br>    <span class="hljs-comment">//在调用时候才去创建</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        obj.<span class="hljs-built_in">show_person1</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        obj.show_person2;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Myclass&lt;person1&gt; m;<br>    m.<span class="hljs-built_in">func1</span>();<br>    <span class="hljs-comment">// m.func2();</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-4类模板对象做函数参数"><a href="#1-3-4类模板对象做函数参数" class="headerlink" title="1.3.4类模板对象做函数参数"></a>1.3.4类模板对象做函数参数</h4><p>学习目标：</p><p>函数模板实例化出对象，向函数传参的方式</p><p>一共有三种传入方式：</p><ol><li>指定传入的类型直接显示对象的数据类型</li><li>参数模板化               将对象中的参数变为模板进行传递</li><li>整个类模板化            将这个对象类型模板化进行传递</li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//类模板对象做函数参数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    T1 m_name;<br>    T2 m_age;<br>    <span class="hljs-built_in">person</span>(T1 name,T2 age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_age = age;<br>        <span class="hljs-keyword">this</span>-&gt;m_name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_person</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;name:&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_name&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;age:&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>    <br>&#125;;<br><span class="hljs-comment">//指定传入类型(最常用)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printperson1</span><span class="hljs-params">(person&lt;string,<span class="hljs-type">int</span>&gt; &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    p.<span class="hljs-built_in">show_person</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-number">100</span>)</span></span>;<br>    p1.<span class="hljs-built_in">show_person</span>();<br>&#125;<br><span class="hljs-comment">//将参数模板化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1,<span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printperson2</span><span class="hljs-params">(person&lt;T1,T2&gt; &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    p.<span class="hljs-built_in">show_person</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;T1的类型为:&quot;</span>&lt;&lt;<span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;T2的类型为:&quot;</span>&lt;&lt;<span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>()&lt;&lt;endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;猪八戒&quot;</span>,<span class="hljs-number">90</span>)</span></span>;<br>    <span class="hljs-built_in">printperson2</span>(p2);<br>    <br>&#125;<br><span class="hljs-comment">//将整个类模板化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printperson3</span><span class="hljs-params">(T &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    p.<span class="hljs-built_in">show_person</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;唐僧&quot;</span>,<span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-built_in">printperson3</span>(p3);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// test01();</span><br>    <span class="hljs-comment">// test02();</span><br>    <span class="hljs-built_in">test03</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛的是第一种：指定传入的类型</li></ul><h4 id="1-3-5类模板与继承"><a href="#1-3-5类模板与继承" class="headerlink" title="1.3.5类模板与继承"></a>1.3.5类模板与继承</h4><p>当类模板碰到继承时，需要注意以下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需要变为模板类</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br>    T m;<br>&#125;;<br><span class="hljs-comment">// class son:public Base   //必须知道父类中T的数据类型才能继承给子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>:<span class="hljs-keyword">public</span> Base&lt;<span class="hljs-type">int</span>&gt;<br>&#123;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    son s1;<br>&#125;<br><span class="hljs-comment">//如果想灵活指定父类中T的类型，子类也要变为一个模板类</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son2</span>:Base&lt;T2&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    T1 obj;<br>    <span class="hljs-built_in">son2</span>()<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;T1的类型为:&quot;</span>&lt;&lt;<span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>()&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;T2的类型为:&quot;</span>&lt;&lt;<span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>()&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    son2&lt;<span class="hljs-type">int</span>,<span class="hljs-type">char</span>&gt; s2;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// test01();</span><br>    <span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>如果父类是类模板，子类需要指定出父类中T的数据类型</p><h4 id="1-3-6类模板成员函数类外实现"><a href="#1-3-6类模板成员函数类外实现" class="headerlink" title="1.3.6类模板成员函数类外实现"></a>1.3.6类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中成员函数的类外实现</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//类模板成员函数类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    T1 m_name;<br>    T2 m_age;<br>   <span class="hljs-built_in">person</span>(T1 name,T2 age);<br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     this-&gt;m_age = age;</span><br>    <span class="hljs-comment">//     this-&gt;m_name = name;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_person</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;&quot;name:&quot;&lt;&lt;this-&gt;m_name&lt;&lt;endl;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;&quot;age:&quot;&lt;&lt;this-&gt;m_age&lt;&lt;endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br><span class="hljs-comment">//构造函数的类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>person&lt;T1,T2&gt;::<span class="hljs-built_in">person</span>(T1 name,T2 age)<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_age = age;<br>    <span class="hljs-keyword">this</span>-&gt;m_name = name;<br>&#125;<br><span class="hljs-comment">//成员函数的类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> person&lt;T1,T2&gt;::<span class="hljs-built_in">show_person</span>()<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;name:&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_name&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;age:&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_age&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    p.<span class="hljs-built_in">show_person</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-7类模板分文件编写"><a href="#1-3-7类模板分文件编写" class="headerlink" title="1.3.7类模板分文件编写"></a>1.3.7类模板分文件编写</h4><p>学习目标：</p><p>掌握类模板成员函数份文件编写产生的问题以及解决办法</p><p>问题：</p><p>类模板成员函数创建时机是在调用阶段，导致分文件编写时链接不到</p><p>解决：</p><ul><li>直接包含.cpp源文件</li><li>将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li></ul><p>示例：</p><p>person.hpp中代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;   <span class="hljs-keyword">public</span>:<br>    T1 m_name;<br>    T2 m_age;<br>    <span class="hljs-built_in">person</span>(T1 name,T2 age);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_person</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>person&lt;T1,T2&gt;::<span class="hljs-built_in">person</span>(T1 name,T2 age)<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_age = age;<br>    <span class="hljs-keyword">this</span>-&gt;m_name = name;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> person&lt;T1,T2&gt;::<span class="hljs-built_in">show_person</span>()<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;name:&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_name&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;age:&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行阶段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-comment">//第一种解决方式    直接包含源文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.hpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// //类模板分文件编写问题以及解决</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-function">person&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    p.<span class="hljs-built_in">show_person</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结：主流方式是第二种，将声明和实现写在一个文件中，后缀改为.hpp文件</p><h4 id="1-3-8类模板与友元"><a href="#1-3-8类模板与友元" class="headerlink" title="1.3.8类模板与友元"></a>1.3.8类模板与友元</h4><p>学习目标：</p><p>掌握类模板配合友元函数的类内和类外实现</p><p>全局函数类内实现直接在类内声明友元即可</p><p>全局函数类外实现需要提前让编译器知道全局函数的存在</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//通过全局函数  打印person信息</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1,<span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printperson2</span><span class="hljs-params">(person&lt;T1,T2&gt; p)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;类外实现&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;name:&quot;</span>&lt;&lt;p.m_name&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;age:&quot;</span>&lt;&lt;p.m_age&lt;&lt;endl;<br><br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-comment">//全局函数  类内实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printperson</span><span class="hljs-params">(person&lt;T1,T2&gt; p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;name:&quot;</span>&lt;&lt;p.m_name&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;age:&quot;</span>&lt;&lt;p.m_age&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//全局函数  类外实现</span><br>    <span class="hljs-comment">//加一个空模板参数列表</span><br>    <span class="hljs-comment">//如果全局函数是类外实现，需要让编译器提前知道这个函数存在</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> printperson2&lt;&gt;(person&lt;T1,T2&gt; p);<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">person</span>(T1 name,T2 age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_age = age;<br>        <span class="hljs-keyword">this</span>-&gt;m_name = name;<br>    &#125;<br>    <span class="hljs-keyword">private</span>:<br>    T1 m_name;<br>    T2 m_age;<br><br>&#125;;<br><span class="hljs-comment">//类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-comment">// void printperson2(person&lt;T1,T2&gt; p)</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     cout&lt;&lt;&quot;类外实现&quot;&lt;&lt;endl;</span><br><span class="hljs-comment">//     cout&lt;&lt;&quot;name:&quot;&lt;&lt;p.m_name&lt;&lt;endl;</span><br><span class="hljs-comment">//     cout&lt;&lt;&quot;age:&quot;&lt;&lt;p.m_age&lt;&lt;endl;</span><br><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;汤普森&quot;</span>,<span class="hljs-number">33</span>)</span></span>;<br>    <span class="hljs-built_in">printperson</span>(p);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;库里&quot;</span>,<span class="hljs-number">34</span>)</span></span>;<br>    <span class="hljs-built_in">printperson2</span>(p1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// test01();</span><br>    <span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-9类模板案例"><a href="#1-3-9类模板案例" class="headerlink" title="1.3.9类模板案例"></a>1.3.9类模板案例</h4><p>案例描述:</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组汇中当前元素个数和数组的容量</li></ul><p>MyArray.hpp中代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//自己的通用的数组类</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArry</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//有参构造 参数 容量</span><br><span class="hljs-built_in">MyArry</span>(<span class="hljs-type">int</span> capacity)<br>&#123;<br><span class="hljs-comment">//cout &lt;&lt; &quot;MyArry的有参构造调用&quot; &lt;&lt; endl;</span><br><span class="hljs-keyword">this</span>-&gt;m_Capacity = capacity;<br><span class="hljs-keyword">this</span>-&gt;m_Size = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;m_Capacity];<br>&#125;<br><br><span class="hljs-comment">//拷贝构造</span><br><span class="hljs-built_in">MyArry</span>(<span class="hljs-type">const</span> MyArry&amp; arr)<br>&#123;<br><span class="hljs-comment">//cout &lt;&lt; &quot;MyArry的拷贝构造调用&quot; &lt;&lt; endl;</span><br><br><span class="hljs-keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;<br><span class="hljs-keyword">this</span>-&gt;m_Size = arr.m_Size;<br><span class="hljs-comment">//this-&gt;pAddress = arr.pAddress;</span><br><br><span class="hljs-comment">//深拷贝</span><br><span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-keyword">new</span> T[arr.m_Capacity];<br><br><span class="hljs-comment">//将arr中的数据都拷贝过来</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;m_Size; i++)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];<br>&#125;<br>&#125;<br><span class="hljs-comment">//operator= 防止浅拷贝问题</span><br>MyArry&amp; <span class="hljs-keyword">operator</span> =(<span class="hljs-type">const</span> MyArry&amp; arr)<br>&#123;<br><br><span class="hljs-comment">//cout &lt;&lt; &quot;MyArry的operator=调用&quot; &lt;&lt; endl;</span><br><br><span class="hljs-comment">//先判断原来堆区是否有数据，如果有先释放</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;pAddress != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;pAddress;<br><span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">this</span>-&gt;m_Capacity = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">this</span>-&gt;m_Size = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//深拷贝</span><br><span class="hljs-keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;<br><span class="hljs-keyword">this</span>-&gt;m_Size = arr.m_Size;<br><span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-keyword">new</span> T[arr.m_Capacity];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;m_Size; i++)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><br><span class="hljs-comment">//尾插法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PushBack</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//判断容量是否等于大小</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Capacity == <span class="hljs-keyword">this</span>-&gt;m_Size)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;pAddress[<span class="hljs-keyword">this</span>-&gt;m_Size] = val;<span class="hljs-comment">//在数组末尾插入数据</span><br><span class="hljs-keyword">this</span>-&gt;m_Size++;<span class="hljs-comment">//更新数组大小</span><br><br>&#125;<br><span class="hljs-comment">//尾删法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PopBack</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//让用户访问不到最后一个元素，即为尾删，逻辑删除</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Size == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;m_Size--;<br>&#125;<br><br><span class="hljs-comment">//通过下标的方式访问数组中的元素</span><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index)<br>&#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;pAddress[index];<br>&#125;<br><br><span class="hljs-comment">//返回数组容量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCapacity</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_Capacity;<br>&#125;<br><br><span class="hljs-comment">//返回数组大小</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_Size;<br>&#125;<br><br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">MyArry</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;pAddress != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-comment">//cout &lt;&lt; &quot;MyArry的析构函数调用&quot; &lt;&lt; endl;</span><br><span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;pAddress;<br><span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T* pAddress;<span class="hljs-comment">//指针指向堆区开辟的真实数组</span><br><br><span class="hljs-type">int</span> m_Capacity;<span class="hljs-comment">//数组容量</span><br><br><span class="hljs-type">int</span> m_Size;<span class="hljs-comment">//数组大小</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>test.cpp中代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;MyArray.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintArry</span><span class="hljs-params">(MyArry &lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">getSize</span>(); i++)<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyArry &lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">arr1</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br><span class="hljs-comment">//利用尾插法向数组中插入数据</span><br>arr1.<span class="hljs-built_in">PushBack</span>(i);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;arr1的打印输出&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">PrintArry</span>(arr1);<br>cout &lt;&lt; <span class="hljs-string">&quot;arr1的容量为&quot;</span> &lt;&lt; arr1.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;arr1的大小为&quot;</span> &lt;&lt; arr1.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;<br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;arr2的打印输出&quot;</span> &lt;&lt; endl;<br>MyArry &lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">arr2</span>(arr1);<br><span class="hljs-built_in">PrintArry</span>(arr2);<br><br><span class="hljs-comment">//尾删</span><br>arr2.<span class="hljs-built_in">PopBack</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;arr2尾删后&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;arr2的容量为&quot;</span> &lt;&lt; arr2.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;arr2的大小为&quot;</span> &lt;&lt; arr2.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">/*MyArry&lt;int&gt;arr3(100);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">arr3 = arr1;*/</span><br><br>&#125;<br><br><br><br><br><br><span class="hljs-comment">//测试自定义数据类型 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>()&#123;&#125;;<br><span class="hljs-built_in">Person</span>(string name,<span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPersonArry</span><span class="hljs-params">(MyArry&lt;Person&gt;&amp; arr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">getSize</span>(); i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名&quot;</span> &lt;&lt; arr[i].m_Name &lt;&lt; <span class="hljs-string">&quot;年龄&quot;</span> &lt;&lt; arr[i].m_Age &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyArry&lt;Person&gt;<span class="hljs-built_in">arr</span>(<span class="hljs-number">10</span>);<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;伞兵1&quot;</span>, <span class="hljs-number">21</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;伞兵2&quot;</span>, <span class="hljs-number">22</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;伞兵3&quot;</span>, <span class="hljs-number">23</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;伞兵4&quot;</span>, <span class="hljs-number">24</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;伞兵5&quot;</span>, <span class="hljs-number">25</span>)</span></span>;<br><br><span class="hljs-comment">//将数据插入到数组中</span><br>arr.<span class="hljs-built_in">PushBack</span>(p1);<br>arr.<span class="hljs-built_in">PushBack</span>(p2);<br>arr.<span class="hljs-built_in">PushBack</span>(p3);<br>arr.<span class="hljs-built_in">PushBack</span>(p4);<br>arr.<span class="hljs-built_in">PushBack</span>(p5);<br><br><span class="hljs-comment">//打印数组</span><br><span class="hljs-built_in">PrintPersonArry</span>(arr);<br><span class="hljs-comment">//输出容量</span><br>cout &lt;&lt; <span class="hljs-string">&quot;arr容量为&quot;</span> &lt;&lt; arr.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl;<br><span class="hljs-comment">//输出大小</span><br>cout &lt;&lt; <span class="hljs-string">&quot;arr大小为&quot;</span> &lt;&lt; arr.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：<br>能够利用所学知识点实现通用的数组。</p><h2 id="2STL初识"><a href="#2STL初识" class="headerlink" title="2STL初识"></a>2STL初识</h2><h3 id="2-1STL的诞生"><a href="#2-1STL的诞生" class="headerlink" title="2.1STL的诞生"></a>2.1STL的诞生</h3><ul><li>长久以来，软件界一直希望建立一种可重复利用的东西</li><li>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></li><li>大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</li><li>为了建立数据结构和算法的一套标准，诞生了<strong>STL</strong></li></ul><h3 id="2-2STL基本概念"><a href="#2-2STL基本概念" class="headerlink" title="2.2STL基本概念"></a>2.2STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL从广义上分为:<strong>容器(container)算法(algorithm)迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过迭代器进行无缝连接</li><li>STL几乎所有的代码都采用了<strong>模板类</strong>或者<strong>模板函数</strong></li></ul><h3 id="2-3STL六大组件"><a href="#2-3STL六大组件" class="headerlink" title="2.3STL六大组件"></a>2.3STL六大组件</h3><p>STL大体分为六大组件，分别是：<strong>容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器</strong>。</p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据。</li><li>算法：常用的各种算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂</li><li>仿函数：行为类似函数，可作为算法的某种策略</li><li>适配器：一种用来修饰容器或者仿函数或迭代器结构的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="2-4STL中容器、算法、迭代器"><a href="#2-4STL中容器、算法、迭代器" class="headerlink" title="2.4STL中容器、算法、迭代器"></a>2.4STL中容器、算法、迭代器</h3><p><strong>容器</strong>：置物之所也</p><p>STL容器就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构:<strong>数组、链表、树、栈、队列、集合、映射表</strong>等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong></p><p> <strong>序列式容器</strong>：强调值的排序，序列式容器中的每个元素均有固定的位置</p><p> <strong>关联式容器</strong>：二叉树结构体，各元素之间没有严格上的物理上的顺序关系</p><p><strong>算法</strong>：问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong></p><p>质变算法：是指运算过程中会更改区间内元素的内容。例如拷贝、查找、删除等等</p><p>非质变算法：是指在运算过程中不会更改区间内的元素内容，例如查找、</p><p>计数、遍历、寻找极值等等</p><p><strong>迭代器</strong>：容器和算法之间的的粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器。</p><p>迭代器的使用非常类似于指针，初学阶段我们可以先理解迭代器为指针。</p><p><strong>迭代器种类</strong>：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、&#x3D;&#x3D;、！&#x3D;</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、&#x3D;&#x3D;、！&#x3D;</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td></tr></tbody></table><p>常用的容器中迭代器种类为<strong>双向迭代器</strong>和<strong>随机访问迭代器</strong></p><h3 id="2-5容器算法迭代器初识"><a href="#2-5容器算法迭代器初识" class="headerlink" title="2.5容器算法迭代器初识"></a>2.5容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据并遍历这个容器</p><h4 id="2-5-1vector存放内置数据类型"><a href="#2-5-1vector存放内置数据类型" class="headerlink" title="2.5.1vector存放内置数据类型"></a>2.5.1vector存放内置数据类型</h4><p>容器：vector</p><p>算法：for_each</p><p>迭代器：vector<int>::iterator</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;   <br>    cout&lt;&lt;val&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//vecotr容器存放内置数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建一个vector容器</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-comment">//通过迭代器访问容器中的数据</span><br>    <span class="hljs-comment">// vector&lt;int&gt;::iterator itBegin = v.begin();//起始迭代器  指向容器中第一个元素</span><br>    <span class="hljs-comment">// vector&lt;int&gt;::iterator itEnd = v.end();//结束迭代器  指向容器中最后一个元素的下一个位置</span><br>    <span class="hljs-comment">// //第一种遍历方式</span><br>    <span class="hljs-comment">// while(itBegin != itEnd)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;*itBegin&lt;&lt;endl;</span><br>    <span class="hljs-comment">//     itBegin++;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">//第二种遍历方式</span><br>    <span class="hljs-comment">// for(vector&lt;int&gt;::iterator it = v.begin();it != v.end();it++)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;*it&lt;&lt;endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">//第三种遍历方式 </span><br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),myprint);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-2vector中存放自定义数据类型"><a href="#2-5-2vector中存放自定义数据类型" class="headerlink" title="2.5.2vector中存放自定义数据类型"></a>2.5.2vector中存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//vector中存放自定义数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">person</span>(string name,<span class="hljs-type">int</span> age)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name = name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age = age;<br>    &#125;<br>    string m_name;<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;person&gt; v;<br>    <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong&quot;</span>,<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong2&quot;</span>,<span class="hljs-number">200</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong3&quot;</span>,<span class="hljs-number">300</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong4&quot;</span>,<span class="hljs-number">400</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong5&quot;</span>,<span class="hljs-number">500</span>)</span></span>;<br>    <span class="hljs-comment">//向容器中添加数据</span><br>    v.<span class="hljs-built_in">push_back</span>(p1);<br>    v.<span class="hljs-built_in">push_back</span>(p2);<br>    v.<span class="hljs-built_in">push_back</span>(p3);<br>    v.<span class="hljs-built_in">push_back</span>(p4);<br>    v.<span class="hljs-built_in">push_back</span>(p5);<br>    <span class="hljs-comment">//遍历容器中的数据</span><br>    <span class="hljs-keyword">for</span>(vector&lt;person&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;姓名:&quot;</span>&lt;&lt;(*it).m_name&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;年龄:&quot;</span>&lt;&lt;(*it).m_age&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;--------------------------&quot;</span>&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;姓名:&quot;</span>&lt;&lt;it-&gt;m_name&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;年龄:&quot;</span>&lt;&lt;it-&gt;m_age&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;--------------------------&quot;</span>&lt;&lt;endl;<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//存放自定义数据类型的指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;person*&gt; v;<br>    <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong&quot;</span>,<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong2&quot;</span>,<span class="hljs-number">200</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong3&quot;</span>,<span class="hljs-number">300</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong4&quot;</span>,<span class="hljs-number">400</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;sunwukong5&quot;</span>,<span class="hljs-number">500</span>)</span></span>;<br>    <span class="hljs-comment">//向容器中添加数据</span><br>    v.<span class="hljs-built_in">push_back</span>(&amp;p1);<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p2);<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p3);<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p4);<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p5);<br>    <span class="hljs-comment">//遍历容器中的数据</span><br>    <span class="hljs-keyword">for</span>(vector&lt;person*&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;姓名:&quot;</span>&lt;&lt;(*it)-&gt;m_name&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;年龄:&quot;</span>&lt;&lt;(*it)-&gt;m_age&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;--------------------------&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-comment">//     cout&lt;&lt;&quot;姓名:&quot;&lt;&lt;it-&gt;m_name&lt;&lt;endl;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;&quot;年龄:&quot;&lt;&lt;it-&gt;m_age&lt;&lt;endl;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;&quot;--------------------------&quot;&lt;&lt;endl;</span><br>     &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">// test01();</span><br>    <span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-3Vector容器嵌套容器"><a href="#2-5-3Vector容器嵌套容器" class="headerlink" title="2.5.3Vector容器嵌套容器"></a>2.5.3Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//容器嵌套容器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; v;<br>    <span class="hljs-comment">//创建小容器</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v3;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v4;<br>    <span class="hljs-comment">//向小容器汇总添加数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++)<br>    &#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>        v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">2</span>);<br>        v3.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">3</span>);<br>        v4.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">4</span>);<br>    &#125;<br>    v.<span class="hljs-built_in">push_back</span>(v1);<br>    v.<span class="hljs-built_in">push_back</span>(v2);<br>    v.<span class="hljs-built_in">push_back</span>(v3);<br>    v.<span class="hljs-built_in">push_back</span>(v4);<br>    <span class="hljs-keyword">for</span> (vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator vit=(*it).<span class="hljs-built_in">begin</span>();vit!=(*it).<span class="hljs-built_in">end</span>();vit++)<br>        &#123;<br>            cout&lt;&lt;*vit&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3STL常用容器"><a href="#3STL常用容器" class="headerlink" title="3STL常用容器"></a>3STL常用容器</h2><h3 id="3-1string容器"><a href="#3-1string容器" class="headerlink" title="3.1string容器"></a>3.1string容器</h3><h4 id="3-1-1string基本概念"><a href="#3-1-1string基本概念" class="headerlink" title="3.1.1string基本概念"></a>3.1.1string基本概念</h4><p><strong>本质：</strong></p><ul><li>string是C++风格的字符串，而string本质上是一个类</li></ul><p>*<em>string和char <em>区别：</em></em></p><ul><li>char *是一个指针</li><li>string是一个类，类内部封装了char *，管理这个字符串，是一个char *型的容器</li></ul><p>特点：</p><p>string类内部封装了很多成员方法</p><p>例如：查找find，拷贝copy，删除delete，替换replace，插入insert</p><p>string管理char *所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4 id="3-1-2string构造函数"><a href="#3-1-2string构造函数" class="headerlink" title="3.1.2string构造函数"></a>3.1.2string构造函数</h4><p>构造函数原型：</p><ul><li>string()创建一个空的字符串</li><li>string(const char* s)           使用字符串s初始化</li><li>string(const string&amp; str)      使用一个string对象初始化另一个string对象</li><li>string(int n,char c)              使用n个字符c初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s1;  <span class="hljs-comment">//默认构造</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    <span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(str)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;s2 = &quot;</span>&lt;&lt; s2 &lt;&lt;endl;<br>    <span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(s2)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;s3 = &quot;</span>&lt;&lt; s3 &lt;&lt;endl;<br>    <span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;s4 = &quot;</span>&lt;&lt; s4 &lt;&lt;endl;<br><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-1-3string赋值操作"><a href="#3-1-3string赋值操作" class="headerlink" title="3.1.3string赋值操作"></a>3.1.3string赋值操作</h4><p>功能描述;</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li>string&amp; operator &#x3D; (const char* s)char*类型字符串赋值给当前的字符串</li><li>string&amp; operator &#x3D; (const string &amp;s)把字符串s赋给当前的字符串</li><li>string&amp; operator &#x3D; (char c)把字符赋值给当前的字符串</li><li>string&amp; assign(const char* s)把字符串s赋值给当前的字符串</li><li>string&amp; assign(const char*s,int n)把字符串s的当前n个字符赋给当前的字符串</li><li>string&amp; assign(const string &amp;s)把字符串s赋给当前字符串</li><li>string&amp; assign(int n,char c)用n个字符c赋给当前字符串</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//string的赋值操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str1;<br>    str1 = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;str1 = &quot;</span>&lt;&lt;str1&lt;&lt;endl;<br><br>    string str2;<br>    str2 = str1;<br>    cout&lt;&lt;<span class="hljs-string">&quot;str2 = &quot;</span>&lt;&lt; str2 &lt;&lt;endl;<br><br>    string str3;<br>    str3 = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;str3 = &quot;</span>&lt;&lt; str3 &lt;&lt;endl;<br><br>    string str4;<br>    str4.<span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello C++&quot;</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str4 = &quot;</span>&lt;&lt; str4 &lt;&lt;endl;<br><br>    string str5;<br>    str5.<span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello C++&quot;</span>,<span class="hljs-number">7</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str5 = &quot;</span>&lt;&lt; str5 &lt;&lt;endl;<br><br>    string str6;<br>    str6.<span class="hljs-built_in">assign</span>(str5);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str6 = &quot;</span>&lt;&lt; str6 &lt;&lt;endl;<br><br>    string str7;<br>    str7.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;w&#x27;</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str = &quot;</span>&lt;&lt; str7 &lt;&lt;endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>string的赋值方式有很多，operator&#x3D;这种方式是比较实用的。</p><h4 id="3-1-4string字符串拼接"><a href="#3-1-4string字符串拼接" class="headerlink" title="3.1.4string字符串拼接"></a>3.1.4string字符串拼接</h4><p>功能描述：</p><ul><li>实现在字符串末尾拼接字符串</li></ul><p>函数原型：</p><ul><li>string&amp; operator+&#x3D;(const char* str)重载+&#x3D;操作符</li><li>string&amp; operator+&#x3D;(const char c)重载+&#x3D;操作符</li><li>string&amp; operator+&#x3D;(const string&amp; str)  重载+&#x3D;操作符</li><li>string&amp; append(const char* s) 把字符串s连接到当前字符串结尾</li><li>string&amp; append(const char* s，int n)  把字符串s的前n个字符连接到当前字符串的结尾</li><li>string&amp; append(const string &amp;s)  同operator+&#x3D;(const string&amp; str)</li><li>string&amp; append(const string &amp;s,int pos,int n)  把字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//string字符串的拼接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s1 = <span class="hljs-string">&quot;我&quot;</span>;<br>    s1 += <span class="hljs-string">&quot;要打篮球&quot;</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;s1 = &quot;</span>&lt;&lt; s1 &lt;&lt;endl;<br>    s1 += <span class="hljs-string">&#x27;!&#x27;</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;s1 = &quot;</span>&lt;&lt; s1 &lt;&lt;endl;<br>    string s2 = <span class="hljs-string">&quot;和库里&quot;</span>;<br>    s1 += s2;<br>    cout&lt;&lt;<span class="hljs-string">&quot;s1 = &quot;</span>&lt;&lt; s1 &lt;&lt;endl;<br><br>    string s3 = <span class="hljs-string">&quot;I&quot;</span>;<br>    s3.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot; love&quot;</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;s3 = &quot;</span>&lt;&lt; s3 &lt;&lt;endl;<br><br>    s3.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot; game lol&quot;</span>,<span class="hljs-number">5</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;s3 = &quot;</span>&lt;&lt; s3 &lt;&lt; endl;<br><br>    <span class="hljs-comment">// s3.append(s2);</span><br>    <span class="hljs-comment">// cout&lt;&lt;&quot;s3 = &quot;&lt;&lt; s3 &lt;&lt;endl;</span><br><br>    s3.<span class="hljs-built_in">append</span>(s2,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;s3 = &quot;</span>&lt;&lt; s3 &lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：<br>字符串拼接的重载版本很多，初学阶段记住几种即可。</p><h4 id="3-1-5string查找和替换"><a href="#3-1-5string查找和替换" class="headerlink" title="3.1.5string查找和替换"></a>3.1.5string查找和替换</h4><p><strong>功能描述</strong>：</p><ul><li>查找:查找指定位置字符串是否存在</li><li>替换:在指定的位置替换字符串</li></ul><p>int find(const string&amp; str, int pos &#x3D; ) const;查找str第一次出现位置,从pos开始查找<br>int find(const char* s, int pos &#x3D; e) const;查找s第一次出现位置,从pos开始查找<br>int find(const char* s, int pos, int n) const;从pos位置查找s的前n个字符第一次位置<br>int find(const char c, int pos &#x3D; e) const;查找字符c第一次出现位置<br>int rfind( const string&amp; str, int pos &#x3D; npos ) const;查找str最后一次位置,从pos开始查找<br>int rfind( const char* s, int pos &#x3D; npos ) const;查找s最后一次出现位置,从pos开始查找<br>int rfind(const char* s, int pos，int n) const;从pos查找s的前n个字符最后一次位置<br>int rfind(const char c, int pos - e) const;查找字符c最后—次出现位置<br>string&amp; replace(int pos, int n, const string&amp; str);替换从pos开始n个字符为字符串str<br>string&amp; replace(int pos, int n,const char* s );替换从pos开始的n个字符为字符串s</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//字符串的查找和替换</span><br><span class="hljs-comment">//查找</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str1 = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br><span class="hljs-comment">//找到返回下标，找不到返回-1</span><br><span class="hljs-type">int</span> pos1 = str1.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;de&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;pos1=&quot;</span> &lt;&lt; pos1 &lt;&lt; endl;<br><span class="hljs-type">int</span> pos2 = str1.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;z&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;pos2=&quot;</span> &lt;&lt; pos2&lt;&lt; endl;<br><br>pos1 = str1.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//从右往左</span><br>cout &lt;&lt; <span class="hljs-string">&quot;pos1=&quot;</span> &lt;&lt; pos1 &lt;&lt; endl;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str2 = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>str2.<span class="hljs-built_in">replace</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;1111&quot;</span>);<span class="hljs-comment">//从1号位置起，3个字符替换为1111</span><br>cout &lt;&lt; <span class="hljs-string">&quot;str2=&quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>find查找是从左往右，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="3-1-6string字符串比较"><a href="#3-1-6string字符串比较" class="headerlink" title="3.1.6string字符串比较"></a>3.1.6string字符串比较</h4><p><strong>功能描述</strong>:<br>字符串之间的比较</p><p><strong>比较方式</strong>:</p><p>字符串比较是按字符的ASCII码进行对比</p><p>比较方法：</p><p>&#x3D;返回0&gt;返回1&lt;返回-1</p><p>函数原型：</p><ul><li>int compare（const string &amp;s）const与字符串s比较</li><li>int compare（const char *s）const           与字符串s比较</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//字符串比较</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str1 = <span class="hljs-string">&quot;zello&quot;</span>;<br>string str2 = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">if</span> (str1.<span class="hljs-built_in">compare</span>(str2) == <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;相等&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str1.<span class="hljs-built_in">compare</span>(str2) &gt; <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;str1大&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;str2大&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>总结</strong>：<br>字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大。</p><h4 id="3-1-7string字符串存取"><a href="#3-1-7string字符串存取" class="headerlink" title="3.1.7string字符串存取"></a>3.1.7string字符串存取</h4><p>string中单个字符存取方式有两种</p><ul><li>char&amp; operator[ ]（int n）通过[ ]方式取字符</li><li>char&amp; at（int n）通过at方式获取字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//string字符存取</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">//通过[]访问单个字符</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str1.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; str1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-comment">//通过at方式访问的单个字符</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str1.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; str1.<span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//修改单个字符</span><br>str1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;z&#x27;</span>;<br>cout &lt;&lt; str1 &lt;&lt; endl;<br><br>str1.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) = <span class="hljs-string">&#x27;x&#x27;</span>;<br>cout &lt;&lt; str1 &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>总结</strong>:</p><p>string字符串中单个字符存取有两种方式，利用[]或at</p><h4 id="3-1-8string插入和删除"><a href="#3-1-8string插入和删除" class="headerlink" title="3.1.8string插入和删除"></a>3.1.8string插入和删除</h4><p><strong>功能描述</strong>：</p><p>对string字符串进行插入和删除字符操作。</p><p><strong>函数原型</strong>:</p><ul><li>string&amp; insert（int pos，const char* s）插入字符串</li><li>string&amp; insert（int pos，const string&amp; str）插入字符串</li><li>string&amp; insert（int pos，int n，char c）在指定位置插入n个字符c</li><li>string&amp; erase（int pos，int n&#x3D;npos）删除从pos开始的n个字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//字符串 插入和删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">//插入</span><br>str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;111&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;<br><br><span class="hljs-comment">//删除</span><br>str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：<br>插入和删除的起始下标都是从0开始。</p><h4 id="3-1-9string子串"><a href="#3-1-9string子串" class="headerlink" title="3.1.9string子串"></a>3.1.9string子串</h4><p><strong>功能描述</strong>:<br>从字符串中获得想要的字串。</p><p><strong>函数原型：</strong></p><ul><li>string substr（int pos&#x3D;0，int n&#x3D;npos）const；返回由pos开始的n个字符组成的字符串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//string求字串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>string subStr = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;subStr=&quot;</span> &lt;&lt; subStr &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//使用操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string email = <span class="hljs-string">&quot;zhangsan@qq.com&quot;</span>;<br><span class="hljs-comment">//从邮箱地址中获取用户名信息</span><br><span class="hljs-type">int</span> pos = email.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;@&quot;</span>);<br>string usrName = email.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, pos);<br>cout &lt;&lt; usrName &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：<br>灵活的运用求字串功能，可以在实际开发中获取有效的信息。</p><h3 id="3-2vector容器"><a href="#3-2vector容器" class="headerlink" title="3.2vector容器"></a>3.2vector容器</h3><h4 id="3-2-1vector的基本概念"><a href="#3-2-1vector的基本概念" class="headerlink" title="3.2.1vector的基本概念"></a>3.2.1vector的基本概念</h4><p>功能：</p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p>vector与普通数组区别：</p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p>动态扩展：</p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝空间，释放原空间。</li></ul><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306092146380.png" alt="image-20230506102145139"></p><ul><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h4 id="3-2-2vector构造函数"><a href="#3-2-2vector构造函数" class="headerlink" title="3.2.2vector构造函数"></a>3.2.2vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li>vector<T> v;采用模板实现类实现，默认构造函数</li><li>vector() v.begin(), v.end() ); 将v（begin(),end()）区间中的元素拷贝给本身</li><li>vector(n,elem);构造函数将n个elem拷贝给本身</li><li>vector(const vector &amp;vec);拷贝构造函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printvector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)<br>    &#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//vector容器构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;     <span class="hljs-comment">//默认构造，无参构造</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>    &#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printvector</span>(v1);<br><br>    <span class="hljs-comment">//通过区间的方式进行构造</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1.begin(),v1.end())</span></span>;<br>    <span class="hljs-built_in">printvector</span>(v2);<br><br>    <span class="hljs-comment">//通过n个elem方式构造</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">27</span>)</span></span>;<br>    <span class="hljs-built_in">printvector</span>(v3);<br><br>    <span class="hljs-comment">//拷贝构造</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v3)</span></span>;<br>    <span class="hljs-built_in">printvector</span>(v4);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>多种构造函数没有可比性，灵活运用即可。</p><h4 id="3-2-3vector赋值操作"><a href="#3-2-3vector赋值操作" class="headerlink" title="3.2.3vector赋值操作"></a>3.2.3vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><p>vector&amp; opetator&#x3D;(const vector &amp;vec)重载等号操作符</p><p>assign(beg,end) 将[beg,end]区间中的数据拷贝赋值给本身</p><p>assign(n,elem)将n个elem拷贝赋值给本身</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printvector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)<br>    &#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//vector赋值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>    &#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printvector</span>(v1);<br><br>    <span class="hljs-comment">//赋值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>    v2 = v1;<br>    <span class="hljs-built_in">printvector</span>(v2);<br><br>    <span class="hljs-comment">//assign</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v3;<br>    v3.<span class="hljs-built_in">assign</span>(v2.<span class="hljs-built_in">begin</span>(),v2.<span class="hljs-built_in">end</span>());         <span class="hljs-comment">//左闭右开</span><br>    <span class="hljs-built_in">printvector</span>(v3);<br><br>    <span class="hljs-comment">//assign   n个elem</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v4;<br>    v4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>,<span class="hljs-number">27</span>);<br>    <span class="hljs-built_in">printvector</span>(v4);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：使用&#x3D;赋值或者assign都可以</p><h4 id="3-2-4vector容量和大小"><a href="#3-2-4vector容量和大小" class="headerlink" title="3.2.4vector容量和大小"></a>3.2.4vector容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p>empty（）判断容器是否为空</p></li><li><p>capacity（）容器的容量</p></li><li><p>size（）返回容器中元素的个数</p></li><li><p>resize（int num）重新指定容器的长度为num，若容器边长，则以默认值填充新位置。</p></li></ul><p>​若容器变短，则末尾超出容器长度的元素被删除。</p><ul><li>reszie（int num，elem）重新指定容器的长度为num，若容器边长，则以默认值填充新位置。</li></ul><p>​若容器变短，则末尾超出容器长度的元素被删除。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printvector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)<br>    &#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-comment">//vector容器大小和容量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br>    &#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(v1.<span class="hljs-built_in">empty</span>())  <span class="hljs-comment">//为真  代表容器为空</span><br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;容器为空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;容器不为空&quot;</span>&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;容器的容量为&quot;</span>&lt;&lt;v1.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;容量的大小为&quot;</span>&lt;&lt;v1.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">printvector</span>(v1);        <span class="hljs-comment">//输出为    0  1  2  3  4  5  6  7  8  9 </span><br>    <span class="hljs-comment">//重新指定大小</span><br>    v1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>);<br>    <span class="hljs-built_in">printvector</span>(v1);        <span class="hljs-comment">//输出为    0  1  2  3  4  5  6  7  8  9  0  0  0  0  0</span><br>    v1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">11</span>);<br>    <span class="hljs-built_in">printvector</span>(v1);        <span class="hljs-comment">//输出为    0  1  2  3  4  5  6  7  8  9  0 </span><br>    v1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printvector</span>(v1);        <span class="hljs-comment">//输出为    0  1  2  3  4  5  6  7  8  9  0  100  100  100  100  </span><br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空····empty（）</li><li>返回元素个数—-size（）</li><li>返回容器容量—–capacity（）</li><li>重新制定大小—–resize（）</li></ul><h4 id="3-2-5vector插入和删除"><a href="#3-2-5vector插入和删除" class="headerlink" title="3.2.5vector插入和删除"></a>3.2.5vector插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p>push_back(ele);尾部插入元素ele</p></li><li><p>pop_back();   删除最后一个元素</p></li><li><p>insert（const iterator pos,ele）;迭代器指向位置pos插入元素ele</p></li><li><p>insert（const iterator pos,int count,ele）;迭代器指向位置pos插入count个元素ele</p></li><li><p>erase(const iterator pos);删除迭代器指向的元素</p></li><li><p>erase(const iterator start,const iterator end);删除迭代器从start到end之间的元素</p></li><li><p>clear();清除容器中所有元素</p></li><li><p>示例：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printvector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)<br>    &#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//vector插入和删除</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>    <span class="hljs-comment">//尾插</span><br>    v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-comment">//遍历</span><br>    <span class="hljs-built_in">printvector</span>(v1);<br>    <span class="hljs-comment">//尾删</span><br>    v1.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-built_in">printvector</span>(v1);<br>    <span class="hljs-comment">//插入  第一个参数是迭代器</span><br>    v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printvector</span>(v1);<br><br>    v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">2</span>,<span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">printvector</span>(v1);<br>    <span class="hljs-comment">//删除</span><br>    v1.<span class="hljs-built_in">erase</span>(v1.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-built_in">printvector</span>(v1);<br>    <br>    <span class="hljs-comment">// v1.erase(v1.begin(),v1.end());</span><br>    v1.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">printvector</span>(v1); <br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>尾插—-push_back</li><li>尾删—pop_back</li><li>插入—insert(位置迭代器)</li><li>删除—erase(位置迭代器)</li><li>清空—clear</li></ul><h4 id="3-2-6vector数据存取"><a href="#3-2-6vector数据存取" class="headerlink" title="3.2.6vector数据存取"></a>3.2.6vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><p>at(int idx);返回索引idx所指的数据</p><p>operator[ ];返回索引idx所指的数据</p><p>front();返回容器中第一个数据元素</p><p>back();返回容器中最后一个数据元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><span class="hljs-comment">//vector数据存取</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br>    &#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">//利用[]方式访问元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;v1.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        cout&lt;&lt;v1[i]&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-comment">//利用at方式访问元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;v1.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        cout&lt;&lt;v1.<span class="hljs-built_in">at</span>(i)&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-comment">//获取第一个元素</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;第一个元素为&quot;</span>&lt;&lt;v1.<span class="hljs-built_in">front</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//获取最后一个元素</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;最后一个元素为&quot;</span>&lt;&lt;v1.<span class="hljs-built_in">back</span>()&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器的第一个元素</li><li>back返回容器的最后一个元素</li></ul><h4 id="3-2-7vector互换容器"><a href="#3-2-7vector互换容器" class="headerlink" title="3.2.7vector互换容器"></a>3.2.7vector互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li>swap(vec)将vec与本身的元素互换</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printvector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)<br>    &#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//互换容器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br>    &#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换前v1&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">printvector</span>(v1);<br>    vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;i &gt; <span class="hljs-number">0</span>;i--)<br>    &#123;<br>        v2.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换前v2&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">printvector</span>(v2);<br>    v1.<span class="hljs-built_in">swap</span>(v2);<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换后v1&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">printvector</span>(v1);<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换后v2&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">printvector</span>(v2);<br>&#125;<br><span class="hljs-comment">//巧用swap可以收缩内存空间</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000</span>;i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;v的容量为:&quot;</span>&lt;&lt;v.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;v的大小为:&quot;</span>&lt;&lt;v.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br><br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">//重新指定大小</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;v的容量为:&quot;</span>&lt;&lt;v.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;v的大小为:&quot;</span>&lt;&lt;v.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br><br>    <span class="hljs-comment">//巧用swap收缩内存</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v).<span class="hljs-built_in">swap</span>(v);<span class="hljs-comment">//匿名对象</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;v的容量为:&quot;</span>&lt;&lt;v.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;v的大小为:&quot;</span>&lt;&lt;v.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// test01();</span><br>    <span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8vector预留空间"><a href="#3-2-8vector预留空间" class="headerlink" title="3.2.8vector预留空间"></a>3.2.8vector预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li>reserve（int len）；容器预留len个元素长度，预留位置不初始化，元素不可访问</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">//vector预留空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-comment">//利用reserve预留空间</span><br>    v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10000</span>);<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;    <span class="hljs-comment">//统计开辟次数</span><br>    <span class="hljs-type">int</span> *p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(p!=&amp;v[<span class="hljs-number">0</span>])<br>        &#123;<br>            p = &amp;v[<span class="hljs-number">0</span>];<br>            num++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;num = &quot;</span>&lt;&lt; num &lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间。</p><h3 id="3-3deque容器"><a href="#3-3deque容器" class="headerlink" title="3.3deque容器"></a>3.3deque容器</h3><h4 id="3-3-1deque的基本概念"><a href="#3-3-1deque的基本概念" class="headerlink" title="3.3.1deque的基本概念"></a>3.3.1deque的基本概念</h4><p>功能：</p><ul><li>双端数组，可以对头端进行插入和删除操作</li></ul><p>deque与vector的区别：</p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度会比vector快</li><li>vector访问元素是的速度会比deque快，这和两者内部实现有关</li></ul><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306092146935.png" alt="image-20230515202459938"></p><p>deque内部工作原理：</p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="3-3-2deque的构造函数"><a href="#3-3-2deque的构造函数" class="headerlink" title="3.3.2deque的构造函数"></a>3.3.2deque的构造函数</h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p>函数原型：</p><p>deque<T> deqT; 默认构造形式</p><p>deque（beg，end）;构造函数将[beg,end]区间中的元素拷贝给本身</p><p>deque（n，elem）；构造函数将n个elem拷贝给本身</p><p>deque（const deque &amp;deq）；拷贝构造函数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cerrno&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printdeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt; &amp;d)</span><span class="hljs-comment">//限制其中的数据不允许被修改则在前边加const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>();it != d.<span class="hljs-built_in">end</span>();it++)<span class="hljs-comment">//呼应上边的const，iterator的迭代器应变为const_iterator</span><br>    &#123;<br>        <span class="hljs-comment">//*it = 100;        容器中数据不可修改</span><br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt; d1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>    &#123;<br>        d1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printdeque</span>(d1);<br><br>    <span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d2</span><span class="hljs-params">(d1.begin(),d1.end())</span></span>;<br>    <span class="hljs-built_in">printdeque</span>(d2);<br><br>    <span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d3</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-built_in">printdeque</span>(d3);<br><br>    <span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d4</span><span class="hljs-params">(d3)</span></span>;<br>    <span class="hljs-built_in">printdeque</span>(d4);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p> 总结：deque容器和vector容器的赋值操作基本上一样，灵活运用即可</p><h4 id="3-3-3deque赋值操作"><a href="#3-3-3deque赋值操作" class="headerlink" title="3.3.3deque赋值操作"></a>3.3.3deque赋值操作</h4><p>功能描述：</p><ul><li>给deque容器进行赋值</li></ul><p>函数原型：</p><ul><li>deque&amp; operator&#x3D;（const deque &amp;deq）；重载等号符</li><li>assign（beg，end）；                                        将[beg,end]区间中的数据拷贝赋值给本身</li><li>assign（n，elem）；                                          将n个elem拷贝赋值给本身</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt;d1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>d1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">PrintDeque</span>(d1);<br><br><span class="hljs-comment">//operator=赋值</span><br>deque&lt;<span class="hljs-type">int</span>&gt;d2;<br>d2 = d1;<br><span class="hljs-built_in">PrintDeque</span>(d2);<br><br><span class="hljs-comment">//assign赋值</span><br>deque&lt;<span class="hljs-type">int</span>&gt;d3;<br>d3.<span class="hljs-built_in">assign</span>(d1.<span class="hljs-built_in">begin</span>(),d1.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">PrintDeque</span>(d3);<br><br>deque&lt;<span class="hljs-type">int</span>&gt;d4;<br>d4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">PrintDeque</span>(d4);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：赋值与vector相同</p><h4 id="3-3-4deque大小操作"><a href="#3-3-4deque大小操作" class="headerlink" title="3.3.4deque大小操作"></a>3.3.4deque大小操作</h4><p>功能描述：</p><ul><li>对deque容器的大小进行操作</li></ul><p>函数原型：</p><ul><li>deque.empty();判断容器是否为空</li><li>deque.size();返回容器中元素的个数</li><li>deque.resize(num);重新指定容器的长度为num，若容器变长，则以默认值填充新位置。若容器变短，则欧威超出容器长度的元素被删除。</li><li>deque.resize(num,elem)重新指定容器的长度为num，若容器变长，则以elem填充新位置。若容器变短，则欧威超出容器长度的元素被删除。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt;d1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>d1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">PrintDeque</span>(d1);<br><span class="hljs-keyword">if</span> (d1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;空&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;不空&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//deque容器没有容量概念</span><br>cout &lt;&lt; <span class="hljs-string">&quot;大小&quot;</span> &lt;&lt; d1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//重新指定大小,并填充</span><br>d1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">PrintDeque</span>(d1);<br><br>d1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">PrintDeque</span>(d1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><ul><li>deque没有容量概念</li><li>判断是否为空——empty</li><li>返回元素个数——size</li><li>重新指定个数——resize</li></ul><h4 id="3-3-5deque插入和删除"><a href="#3-3-5deque插入和删除" class="headerlink" title="3.3.5deque插入和删除"></a>3.3.5deque插入和删除</h4><p>功能描述：</p><ul><li>想deque容器中插入和删除数据</li></ul><p>函数原型：</p><p>两端插入操作：</p><p>push_back(elem)在容器尾部添加一个数据</p><p>push_front(elem)在容器头部插入数据</p><p>pop_back()  删除容器最后一个数据</p><p>pop_front()  删除容器第一个数据</p><p>指定位置操作：</p><ul><li>insert（pos，elem）；在pos位置插入一个elem元素的拷贝，返回新数据的位置</li><li>insert（pos，n，elem）；在pos位置插入n个elem数据，无返回值</li><li>insert（pos，beg，end）；在pos位置插入[beg,end]区间的数据，无返回值</li><li>clear();清空容器的所有数据</li><li>erase（beg，end）；删除[beg,end]区间的数据，返回下一个数据的位置</li><li>erase（pos）；删除pos位置的数据，返回下一个数据的位置</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//两端操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt;d1;<br><span class="hljs-comment">//尾插</span><br>d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br><span class="hljs-comment">//头插</span><br>d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br><br><span class="hljs-built_in">PrintDeque</span>(d1);<br><span class="hljs-comment">//尾删</span><br>d1.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-built_in">PrintDeque</span>(d1);<br><br><span class="hljs-comment">//头删</span><br>d1.<span class="hljs-built_in">pop_front</span>();<br><span class="hljs-built_in">PrintDeque</span>(d1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt;d2;<br><span class="hljs-comment">//尾插</span><br>d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br><span class="hljs-comment">//头插</span><br>d2.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d2.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br><br><span class="hljs-built_in">PrintDeque</span>(d2);<br><br><span class="hljs-comment">//insert插入</span><br>d2.<span class="hljs-built_in">insert</span>(d2.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">PrintDeque</span>(d2);<br><br>d2.<span class="hljs-built_in">insert</span>(d2.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>,<span class="hljs-number">10000</span>);<br><span class="hljs-built_in">PrintDeque</span>(d2);<br><br><span class="hljs-comment">//按照区间进行插入</span><br>deque&lt;<span class="hljs-type">int</span>&gt;d3;<br>d3.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>d3.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>d3.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><br>d2.<span class="hljs-built_in">insert</span>(d2.<span class="hljs-built_in">begin</span>(), d3.<span class="hljs-built_in">begin</span>(), d3.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">PrintDeque</span>(d2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><br>deque&lt;<span class="hljs-type">int</span>&gt;d4;<br><span class="hljs-comment">//尾插</span><br>d4.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d4.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br><span class="hljs-comment">//头插</span><br>d4.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d4.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br><br><span class="hljs-built_in">PrintDeque</span>(d4);<br><br><span class="hljs-comment">//删除</span><br>deque&lt;<span class="hljs-type">int</span>&gt;::iterator it = d4.<span class="hljs-built_in">begin</span>();<br>it++;<br>d4.<span class="hljs-built_in">erase</span>(it);<br><span class="hljs-built_in">PrintDeque</span>(d4);<br><br><span class="hljs-comment">//按照区间方式删除</span><br>d4.<span class="hljs-built_in">erase</span>(d4.<span class="hljs-built_in">begin</span>(), d4.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">PrintDeque</span>(d4);<br><span class="hljs-comment">//清空</span><br>d4.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">PrintDeque</span>(d4);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-built_in">test03</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插——push_back</li><li>尾删——pop_back</li><li>头插——push_front</li><li>头删——pop_front</li></ul><h4 id="3-3-6deque数据存取"><a href="#3-3-6deque数据存取" class="headerlink" title="3.3.6deque数据存取"></a>3.3.6deque数据存取</h4><p>功能描述：</p><ul><li>对deque中的数据的存取操作</li></ul><p>函数原型：</p><p>at（int idx）；返回索引idx所指的数据</p><p>operator[idx]；  返回索引idx所指的数据</p><p>front（）；返回容器中第一个数据元素</p><p>back（）；返回容器中最后一个数据元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt;d1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>d1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br>d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">300</span>);<br><br><span class="hljs-comment">//通过[]方式访问元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; d1.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; d1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-comment">//通过at方式访问元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; d1.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; d1.<span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;第一个元素=&quot;</span> &lt;&lt; d1.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;最后一个元素=&quot;</span> &lt;&lt; d1.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-3-7deque排序"><a href="#3-3-7deque排序" class="headerlink" title="3.3.7deque排序"></a>3.3.7deque排序</h4><p>功能描述：</p><ul><li>利用算法实现对deque容器进行排序</li></ul><p>算法</p><ul><li>sort（iterator beg，iterator end）对beg和end区间内元素进行排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span><span class="hljs-comment">//标准算法头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt;d1;<br>d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br>d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">300</span>);<br><br><span class="hljs-built_in">PrintDeque</span>(d1);<br><br><span class="hljs-comment">//排序-默认升序</span><br><span class="hljs-comment">//对于支持随机访问的迭代器容器，都可以用sort算法对其进行排序</span><br><span class="hljs-comment">//vector容器也可以利用sort进行排序</span><br>cout &lt;&lt; <span class="hljs-string">&quot;排序后&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">sort</span>(d1.<span class="hljs-built_in">begin</span>(), d1.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">PrintDeque</span>(d1);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4stack容器"><a href="#3-4stack容器" class="headerlink" title="3.4stack容器"></a>3.4stack容器</h3><h4 id="3-4-1stack基本概念"><a href="#3-4-1stack基本概念" class="headerlink" title="3.4.1stack基本概念"></a>3.4.1stack基本概念</h4><p><strong>概念：</strong>stack是一种先进后出的数据结构，他只有一个出口</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306092147808.png" alt="image-20230525151858073"></p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据成为—-入栈 push</p><p>栈中弹出数据成为—-出栈pop</p><h4 id="3-4-2stack常用接口"><a href="#3-4-2stack常用接口" class="headerlink" title="3.4.2stack常用接口"></a>3.4.2stack常用接口</h4><p><strong>功能描述：</strong>栈容器常用的对外接口</p><p>构造函数：</p><ul><li>stack<T> stk;stack采用模板类实现，stack对象的默认构造形式</li><li>stack（const stack &amp;stk）拷贝构造函数</li></ul><p>赋值操作：</p><ul><li>stack&amp; operator&#x3D;（const stack &amp;stk）；重载等号操作符</li></ul><p>数据存取：</p><ul><li>push（elem）向栈顶添加元素</li><li>pop（） 从栈顶移除第一个元素</li><li>top（）  返回栈顶元素</li></ul><p>大小操作：</p><ul><li>empty（）；判断堆栈是否为空</li><li>size（）；返回栈的大小</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//栈容器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt;s;<br><br>    <span class="hljs-comment">//入栈</span><br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">40</span>);<br><br>    <span class="hljs-comment">//只要栈不为空，查看栈顶，并且执行出栈操作</span><br>    <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-comment">//查看栈顶元素</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;栈顶元素为：&quot;</span>&lt;&lt;s.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br><br>        <span class="hljs-comment">//出栈</span><br>        s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;栈的大小&quot;</span>&lt;&lt;s.<span class="hljs-built_in">size</span>() &lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>入栈push</li><li>出栈pop</li><li>返回栈顶元素 top</li><li>判断为空empty</li><li>返回栈大小size</li></ul><h3 id="3-5queue容器"><a href="#3-5queue容器" class="headerlink" title="3.5queue容器"></a>3.5queue容器</h3><h4 id="3-5-1queue基本概念"><a href="#3-5-1queue基本概念" class="headerlink" title="3.5.1queue基本概念"></a>3.5.1queue基本概念</h4><p>概念：queue是一种先进先出的数据结构，他有两个出口</p><p><img src="F:\Typora笔记\C++核心编程.assets\image-20230525153231842.png" alt="image-20230525153231842"></p><p>只有队头和队尾能被外界访问，因此不允许有遍历行为。</p><p>队列容器允许从一端新增元素，从另一端移除元素。</p><p>队列中进入数据——入队。</p><p>队列中出数据——出队。</p><h4 id="3-5-2queue常用接口"><a href="#3-5-2queue常用接口" class="headerlink" title="3.5.2queue常用接口"></a>3.5.2queue常用接口</h4><p>构造函数：</p><ul><li>queue<T> que;queue采用模板类实现</li><li>queue(const queue &amp;que)拷贝构造函数</li></ul><p>赋值操作：</p><ul><li>queue&amp; operator&#x3D;（const queue &amp;que）重载等号操作符</li></ul><p>数据存取：</p><ul><li>push（elem）往队尾添加元素</li><li>pop（）  从队头移除第一个元素</li><li>back（）返回最后一个元素</li><li>front（）返回第一个元素</li></ul><p>大小操作：</p><ul><li>empty（）判断是否为空</li><li>size（）返回栈的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;Person&gt;q;<br><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;s1&quot;</span>, <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;s2&quot;</span>, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;s4&quot;</span>, <span class="hljs-number">4</span>)</span></span>;<br><br>q.<span class="hljs-built_in">push</span>(p1);<br>q.<span class="hljs-built_in">push</span>(p2);<br>q.<span class="hljs-built_in">push</span>(p3);<br>q.<span class="hljs-built_in">push</span>(p4);<br>cout &lt;&lt; <span class="hljs-string">&quot;大小=&quot;</span> &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; q.<span class="hljs-built_in">front</span>().m_Name &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt; q.<span class="hljs-built_in">front</span>().m_Age &lt;&lt; endl;<br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;大小=&quot;</span> &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>入队——push</li><li>出队——pop</li><li>返回队头元素——front</li><li>返回队尾元素——back</li><li>判断队是否为空——empty</li><li>返回队列大小——size</li></ul><h3 id="3-6list容器"><a href="#3-6list容器" class="headerlink" title="3.6list容器"></a>3.6list容器</h3><h4 id="3-6-1list基本概念"><a href="#3-6-1list基本概念" class="headerlink" title="3.6.1list基本概念"></a>3.6.1list基本概念</h4><p>功能：将数据进行链式存储</p><p>链表(list)：是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接来实现的。</p><p>链表的组成：链表由一系列结点组成。</p><p>结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p><p>SLT中的链表是一个双向循环链表。<br>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器。</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306092147671.png" alt="image-20230525155709439"></p><p>list的优点:</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点:</p><ul><li>链表灵活，但是空间(指针域)和时间(遍历)额外耗费较大。</li></ul><p>list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：<br>STL中List和vector是两个最常用的容器，各有优缺点。</p><h4 id="3-6-2list构造函数"><a href="#3-6-2list构造函数" class="headerlink" title="3.6.2list构造函数"></a>3.6.2list构造函数</h4><p><strong>功能描述</strong>：<br>创建list容器</p><p><strong>函数原型</strong>：</p><ul><li>list<T> lst;list采用模板类实现，对象的默认构造形式</li><li>list(beg,end);构造函数将[beg,end]区间中的元素拷贝给本身</li><li>list(n,elem);构造函数将n个elem拷贝给本身</li><li>list(const list &amp;list);拷贝构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;l1;<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">PrintList</span>(l1);<br><br>list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">l2</span>(l1.<span class="hljs-built_in">begin</span>(), l1.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">PrintList</span>(l2);<br><br><br>list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">l3</span>(l2);<br><span class="hljs-built_in">PrintList</span>(l3);<br><br>list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">l4</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">PrintList</span>(l4);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><p>list构造方式同其他几个STL常用容器，熟练掌握即可。</p><h4 id="3-6-3list赋值和交换"><a href="#3-6-3list赋值和交换" class="headerlink" title="3.6.3list赋值和交换"></a>3.6.3list赋值和交换</h4><p><strong>功能描述：</strong></p><p>给list容器进行赋值，以及交换list容器。</p><p><strong>函数原型：</strong></p><ul><li>assign（beg，end）将[beg，end]区间中的数据拷贝赋值给本身</li><li>assign（n，elem）将n个elem拷贝赋值给本身</li><li>list&amp; operator&#x3D;（const list &amp;lst）重载等号操作符</li><li>swap（lst）将lst与本身的元素互换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;l1;<br><br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">PrintList</span>(l1);<br><br>list&lt;<span class="hljs-type">int</span>&gt;l2;<br>l2 = l1;<span class="hljs-comment">//operator=</span><br><span class="hljs-built_in">PrintList</span>(l2);<br><br>list&lt;<span class="hljs-type">int</span>&gt;l3;<br>l3.<span class="hljs-built_in">assign</span>(l2.<span class="hljs-built_in">begin</span>(), l2.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">PrintList</span>(l3);<br><br>list&lt;<span class="hljs-type">int</span>&gt;l4;<br>l4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">PrintList</span>(l4);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;l5;<br><br>l5.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>l5.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>l5.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>l5.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><br>list&lt;<span class="hljs-type">int</span>&gt;l6;<br>l6.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>l6.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>l6.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>l6.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;交换前&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">PrintList</span>(l5);<br><span class="hljs-built_in">PrintList</span>(l6);<br><br>l5.<span class="hljs-built_in">swap</span>(l6);<br>cout &lt;&lt; <span class="hljs-string">&quot;交换后&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">PrintList</span>(l5);<br><span class="hljs-built_in">PrintList</span>(l6);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：<br>list赋值和交换能够灵活运用即可。</p><h4 id="3-6-4list大小操作"><a href="#3-6-4list大小操作" class="headerlink" title="3.6.4list大小操作"></a>3.6.4list大小操作</h4><p><strong>功能描述</strong>：<br>对list容器的大小进行操作</p><p><strong>函数原型</strong>：</p><ul><li>size（）返回容器中元素的个数</li><li>empty（）判断容器是否为空</li><li>resize（num）重新制定容器的长度为num，若容器变长，则以默认值填充新位置若容器变短，则末尾超出容器长度的元素被删除</li><li>resize（num，elem）重新制定容器的长度为num，若容器变长，则以elem填充新位置若容器变短，则末尾超出容器长度的元素被删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;l1;<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-built_in">PrintList</span>(l1);<br><br><span class="hljs-keyword">if</span> (l1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;空&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;不空&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;元素个数=&quot;</span> &lt;&lt; l1.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//重新指定大小</span><br>l1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">PrintList</span>(l1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>:</p><ul><li>判断是否为空——empty</li><li>返回元素个数——size</li><li>重新指定个数——resize</li></ul><h4 id="3-6-5list插入和删除"><a href="#3-6-5list插入和删除" class="headerlink" title="3.6.5list插入和删除"></a>3.6.5list插入和删除</h4><p><strong>功能描述</strong>：<br>对list容器进行数据的插入和删除</p><p><strong>函数原型</strong>：</p><ul><li>push_back(elem)在容器尾部加入一个元素</li><li>pop_back()删除容器中最后一个元素</li><li>push_front(elem)在容器开头插入一个元素</li><li>pop_front();从容器开头移除第一个元素</li><li>insert(pos,elem)在pos位置插入elem元素的拷贝，返回新数据的位置</li><li>insert(pos,n,elem)在pos位置插入n个elem数据，无返回值</li><li>insert(pos,beg,end);在pos位置插入[beg，end]区间的数据，无返回值</li><li>clear()移除容器中的所有数据</li><li>erase(beg,end);删除[beg,end]区间的数据，返回下一个数据的位置</li><li>erase(pos);删除pos位置的数据，返回下一个数据的位置</li><li>remove(elem);删除容器中所有与elem值匹配的元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;l1;<br><span class="hljs-comment">//尾</span><br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">//头</span><br>l1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">10</span>);<br>l1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">20</span>);<br><br><span class="hljs-built_in">PrintList</span>(l1);<br><br><span class="hljs-comment">//删</span><br>l1.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-built_in">PrintList</span>(l1);<br><br>l1.<span class="hljs-built_in">pop_front</span>();<br><span class="hljs-built_in">PrintList</span>(l1);<br><br><span class="hljs-comment">//插入</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator it = l1.<span class="hljs-built_in">begin</span>();<br>it++;<br>l1.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">PrintList</span>(l1);<br><br><span class="hljs-comment">//删除</span><br><span class="hljs-comment">//用的时候指定it</span><br>it = l1.<span class="hljs-built_in">begin</span>();<br>l1.<span class="hljs-built_in">erase</span>(++it);<br><span class="hljs-built_in">PrintList</span>(l1);<br><br><span class="hljs-comment">//移除</span><br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1000</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1000</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1000</span>);<br><span class="hljs-built_in">PrintList</span>(l1);<br>l1.<span class="hljs-built_in">remove</span>(<span class="hljs-number">1000</span>);<span class="hljs-comment">//删除所有匹配的元素</span><br><br><span class="hljs-built_in">PrintList</span>(l1);<br><br><br><span class="hljs-comment">//清空</span><br>l1.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">PrintList</span>(l1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>尾插——push_back</li><li>尾删——pop_back</li><li>头插——push_front</li><li>头删——pop_front</li><li>插入——insert</li><li>删除——erase</li><li>移除——remove</li><li>清空——clear</li></ul><h4 id="3-6-6list数据存取"><a href="#3-6-6list数据存取" class="headerlink" title="3.6.6list数据存取"></a>3.6.6list数据存取</h4><p><strong>功能描述</strong>：<br>对list容器中数据进行存储。</p><p><strong>函数原型</strong>：</p><ul><li>front（）返回第一个元素</li><li>back（）返回最后一个元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;l1;<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">//list中不可以用[]访问容器中的元素</span><br><span class="hljs-comment">//at()也不行</span><br><span class="hljs-comment">//因为List本质是链表，不是用连续的线性空间存储数据，迭代器也是不支持随机访问的</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;第一个元素=&quot;</span> &lt;&lt; l1.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;最后一个元素=&quot;</span> &lt;&lt; l1.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//验证迭代器是不支持随机访问的</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator it = l1.<span class="hljs-built_in">begin</span>();<br>it++;<span class="hljs-comment">//支持++ --  双向</span><br>it--;<br><span class="hljs-comment">//it = it+1;不行——不支持随机访问</span><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素——front</li><li>返回最后一个元素——back</li></ul><h4 id="3-6-7list反转和排序"><a href="#3-6-7list反转和排序" class="headerlink" title="3.6.7list反转和排序"></a>3.6.7list反转和排序</h4><p><strong>功能描述</strong>：<br>将容器中的元素反转，以及将容器中的数据进行排序。</p><p><strong>函数原型</strong>：</p><ul><li>reverse（）反转链表</li><li>sort（） 链表排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;l1;<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;反转前&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">PrintList</span>(l1);<br><br><span class="hljs-comment">//反转</span><br>cout &lt;&lt; <span class="hljs-string">&quot;反转后&quot;</span> &lt;&lt; endl;<br>l1.<span class="hljs-built_in">reverse</span>();<br><span class="hljs-built_in">PrintList</span>(l1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//降序 第一个数&gt;第二个数</span><br><span class="hljs-keyword">return</span> v1 &gt; v2;<br>&#125;<br><br><span class="hljs-comment">//排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;l2;<br>l2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>l2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>l2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>l2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>l2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;排序前&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">PrintList</span>(l2);<br><br><span class="hljs-comment">//所有不支持随机访问迭代器的容器不可以用标准算法</span><br><span class="hljs-comment">//不支持随机访问迭代器的容器，内部会提供对应的一些算法</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;排序后&quot;</span> &lt;&lt; endl;<br>l2.<span class="hljs-built_in">sort</span>();<br><span class="hljs-built_in">PrintList</span>(l2);<br><br>l2.<span class="hljs-built_in">sort</span>(myCompare);<span class="hljs-comment">//降序</span><br><span class="hljs-built_in">PrintList</span>(l2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>反转——reverse</li><li>排序——sort(成员函数)</li></ul><h4 id="3-6-8排序案例"><a href="#3-6-8排序案例" class="headerlink" title="3.6.8排序案例"></a>3.6.8排序案例</h4><p><strong>案例描述</strong>：将Person自定义类型进行排序，Person中属性有姓名、年龄、身高。</p><p><strong>排序规则</strong>：按照年龄进行升序，如果年龄相同则按照身高进行降序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age, <span class="hljs-type">int</span> height)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br><span class="hljs-keyword">this</span>-&gt;m_Height = height;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br>&#125;<br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br><span class="hljs-type">int</span> m_Height;<br>&#125;;<br><span class="hljs-comment">//指定排序规则</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">comparePerson</span><span class="hljs-params">(Person &amp;p1,Person &amp;p2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//按照年龄升序</span><br><span class="hljs-keyword">if</span> (p1.m_Age == p2.m_Age)<br>&#123;<br><span class="hljs-comment">//年龄相同 按照身高降序</span><br><span class="hljs-keyword">return</span> p1.m_Height &gt; p2.m_Height;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> p1.m_Age &lt; p2.m_Age;<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;Person&gt;L;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;s11&quot;</span>,<span class="hljs-number">23</span>,<span class="hljs-number">166</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;s12&quot;</span>,<span class="hljs-number">23</span>,<span class="hljs-number">156</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;s13&quot;</span>,<span class="hljs-number">23</span>,<span class="hljs-number">178</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;s14&quot;</span>,<span class="hljs-number">33</span>,<span class="hljs-number">172</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;s15&quot;</span>,<span class="hljs-number">43</span>,<span class="hljs-number">190</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-string">&quot;s16&quot;</span>,<span class="hljs-number">45</span>,<span class="hljs-number">175</span>)</span></span>;<br><br>L.<span class="hljs-built_in">push_back</span>(p1);<br>L.<span class="hljs-built_in">push_back</span>(p2);<br>L.<span class="hljs-built_in">push_back</span>(p3);<br>L.<span class="hljs-built_in">push_back</span>(p4);<br>L.<span class="hljs-built_in">push_back</span>(p5);<br>L.<span class="hljs-built_in">push_back</span>(p6);<br><br><span class="hljs-keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; it-&gt;m_Name &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt; it-&gt;m_Height &lt;&lt; endl;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;排序后&quot;</span> &lt;&lt; endl;<br><br>L.<span class="hljs-built_in">sort</span>(comparePerson);<br><span class="hljs-keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li><li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂。</li></ul><h3 id="3-7set-x2F-multiset容器"><a href="#3-7set-x2F-multiset容器" class="headerlink" title="3.7set&#x2F;multiset容器"></a>3.7set&#x2F;multiset容器</h3><h4 id="3-7-1-set基本概念"><a href="#3-7-1-set基本概念" class="headerlink" title="3.7.1 set基本概念"></a>3.7.1 set基本概念</h4><p><strong>简介：</strong></p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong></p><ul><li>set&#x2F;multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树实现</strong>。</li></ul><p><strong>set和multiset区别：</strong></p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h4 id="3-7-2-set构造和赋值"><a href="#3-7-2-set构造和赋值" class="headerlink" title="3.7.2 set构造和赋值"></a>3.7.2 set构造和赋值</h4><p><strong>功能描述：</strong> 创建set容器以及赋值</p><p><strong>构造：</strong></p><ul><li>set<T> st; &#x2F;&#x2F;默认构造函数：</li><li>set(const set &amp;st); &#x2F;&#x2F;拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li>set&amp; operator&#x3D;(const set &amp;st); &#x2F;&#x2F;重载等号操作符</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSet</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt; &amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//构造和赋值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br><br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br><span class="hljs-comment">//拷贝构造</span><br>set&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">s2</span>(s1);<br><span class="hljs-built_in">printSet</span>(s2);<br><br><span class="hljs-comment">//赋值</span><br>set&lt;<span class="hljs-type">int</span>&gt;s3;<br>s3 = s2;<br><span class="hljs-built_in">printSet</span>(s3);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h4 id="3-7-3-set大小和交换"><a href="#3-7-3-set大小和交换" class="headerlink" title="3.7.3 set大小和交换"></a>3.7.3 set大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size(); </code>&#x2F;&#x2F;返回容器中元素的数目</li><li><code>empty(); </code>&#x2F;&#x2F;判断容器是否为空</li><li><code>swap(st); </code>&#x2F;&#x2F;交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSet</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt; &amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//大小</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br><br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;s1为空&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;s1不为空&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br><br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><br>set&lt;<span class="hljs-type">int</span>&gt; s2;<br><br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">100</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">300</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">200</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">400</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换前&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">printSet</span>(s1);<br><span class="hljs-built_in">printSet</span>(s2);<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后&quot;</span> &lt;&lt; endl;<br>s1.<span class="hljs-built_in">swap</span>(s2);<br><span class="hljs-built_in">printSet</span>(s1);<br><span class="hljs-built_in">printSet</span>(s2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>统计大小 — size</li><li>判断是否为空 — empty</li><li>交换容器 — swap</li></ul><h4 id="3-7-4-set插入和删除"><a href="#3-7-4-set插入和删除" class="headerlink" title="3.7.4 set插入和删除"></a>3.7.4 set插入和删除</h4><p><strong>功能描述</strong>：</p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li>insert(elem); &#x2F;&#x2F;在容器中插入元素。</li><li>clear(); &#x2F;&#x2F;清除所有元素</li><li>erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li>erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li>erase(elem); &#x2F;&#x2F;删除容器中值为elem的元素。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSet</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt; &amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//插入和删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br><span class="hljs-comment">//插入</span><br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br><span class="hljs-comment">//删除</span><br>s1.<span class="hljs-built_in">erase</span>(s1.<span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">printSet</span>(s1);<br><br>s1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">30</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br><span class="hljs-comment">//清空</span><br><span class="hljs-comment">//s1.erase(s1.begin(), s1.end());</span><br>s1.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">printSet</span>(s1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>插入 — insert</li><li>删除 — erase</li><li>清空 — clear</li></ul><h4 id="3-7-5-set查找和统计"><a href="#3-7-5-set查找和统计" class="headerlink" title="3.7.5 set查找和统计"></a>3.7.5 set查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li>find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li>count(key); &#x2F;&#x2F;统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-comment">//查找和统计</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br><span class="hljs-comment">//插入</span><br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-comment">//查找</span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator pos = s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-keyword">if</span> (pos != s1.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未找到元素&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//统计</span><br><span class="hljs-type">int</span> num = s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">30</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>查找 — find （返回的是迭代器）</li><li>统计 — count （对于set，结果为0或者1）</li></ul><h4 id="3-7-6-set和multiset区别"><a href="#3-7-6-set和multiset区别" class="headerlink" title="3.7.6 set和multiset区别"></a>3.7.6 set和multiset区别</h4><p><strong>学习目标：</strong></p><ul><li>掌握set和multiset的区别</li></ul><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-comment">//set和multiset区别</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s;<br>pair&lt;set&lt;<span class="hljs-type">int</span>&gt;::iterator, <span class="hljs-type">bool</span>&gt;  ret = s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (ret.second) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>ret = s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (ret.second) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;<br>&#125;<br>    <br><span class="hljs-comment">//multiset</span><br>multiset&lt;<span class="hljs-type">int</span>&gt; ms;<br>ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">for</span> (multiset&lt;<span class="hljs-type">int</span>&gt;::iterator it = ms.<span class="hljs-built_in">begin</span>(); it != ms.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h4 id="3-7-7-pair对组创建"><a href="#3-7-7-pair对组创建" class="headerlink" title="3.7.7 pair对组创建"></a>3.7.7 pair对组创建</h4><p><strong>功能描述：</strong></p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li>pair&lt;type, type&gt; p &#x3D; make_pair( value1, value2 );</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//对组创建</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(string(<span class="hljs-string">&quot;Tom&quot;</span>), <span class="hljs-number">20</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;<br><br>pair&lt;string, <span class="hljs-type">int</span>&gt; p2 = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-number">10</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结：两种方式都可以创建对组，记住一种即可</p><h4 id="3-7-8-set容器排序"><a href="#3-7-8-set容器排序" class="headerlink" title="3.7.8 set容器排序"></a>3.7.8 set容器排序</h4><p><strong>学习目标：</strong></p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p><strong>主要技术点：</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong> set存放内置数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> v1 &gt; v2;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;    <br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);<br><br><span class="hljs-comment">//默认从小到大</span><br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s1.<span class="hljs-built_in">begin</span>(); it != s1.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//指定排序规则</span><br>set&lt;<span class="hljs-type">int</span>,MyCompare&gt; s2;<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);<br><br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>, MyCompare&gt;::iterator it = s2.<span class="hljs-built_in">begin</span>(); it != s2.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结：利用仿函数可以指定set容器的排序规则</p><p><strong>示例二</strong> set存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">comparePerson</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p1, <span class="hljs-type">const</span> Person &amp;p2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//按照年龄进行排序  降序</span><br><span class="hljs-keyword">return</span> p1.m_Age &gt; p2.m_Age;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;Person, comparePerson&gt; s;<br><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;刘备&quot;</span>, <span class="hljs-number">23</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;关羽&quot;</span>, <span class="hljs-number">27</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;张飞&quot;</span>, <span class="hljs-number">25</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">21</span>)</span></span>;<br><br>s.<span class="hljs-built_in">insert</span>(p1);<br>s.<span class="hljs-built_in">insert</span>(p2);<br>s.<span class="hljs-built_in">insert</span>(p3);<br>s.<span class="hljs-built_in">insert</span>(p4);<br><br><span class="hljs-keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结：对于自定义数据类型，set必须指定排序规则才可以插入数据</p><h3 id="3-8map-x2F-multimap容器"><a href="#3-8map-x2F-multimap容器" class="headerlink" title="3.8map&#x2F;multimap容器"></a>3.8map&#x2F;multimap容器</h3><h4 id="3-8-1map基本概念"><a href="#3-8-1map基本概念" class="headerlink" title="3.8.1map基本概念"></a>3.8.1map基本概念</h4><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li>map&#x2F;multimap属于关联式容器，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据key值快速找到value值</li></ul><p><strong>map和multimap区别：</strong></p><ul><li><p>map不允许容器中有重复key值元素</p></li><li><p>multimap允许容器中有重复key值元素</p></li></ul><h4 id="3-8-2-map构造和赋值"><a href="#3-8-2-map构造和赋值" class="headerlink" title="3.8.2 map构造和赋值"></a>3.8.2 map构造和赋值</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp; </code>&#x2F;&#x2F;map默认构造函数:</li><li><code>map(const map &amp;mp);</code> &#x2F;&#x2F;拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code> &#x2F;&#x2F;重载等号操作符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key=&quot;</span> &lt;&lt; (*it).first &lt;&lt; <span class="hljs-string">&quot;value=&quot;</span> &lt;&lt; (*it).second &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> ;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m1;<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">40</span>));<br><br><span class="hljs-built_in">PrintMap</span>(m1);<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">m2</span>(m1);<br><span class="hljs-built_in">PrintMap</span>(m1);<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m3;<br>m3 = m2;<br><span class="hljs-built_in">PrintMap</span>(m3);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="3-8-3-map大小和交换"><a href="#3-8-3-map大小和交换" class="headerlink" title="3.8.3 map大小和交换"></a>3.8.3 map大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计map容器大小以及交换map容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size(); </code>&#x2F;&#x2F;返回容器中元素的数目</li><li><code>empty();</code> &#x2F;&#x2F;判断容器是否为空</li><li><code>swap(st);</code> &#x2F;&#x2F;交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key=&quot;</span> &lt;&lt; (*it).first &lt;&lt; <span class="hljs-string">&quot;value=&quot;</span> &lt;&lt; (*it).second &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> ;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m1;<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">40</span>));<br><br><span class="hljs-built_in">PrintMap</span>(m1);<br><br><span class="hljs-keyword">if</span> (m1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;空&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;不空&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;大小=&quot;</span> &lt;&lt; m1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m2;<br>m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>));<br>m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>));<br>m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">30</span>, <span class="hljs-number">3</span>));<br>m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">40</span>, <span class="hljs-number">4</span>));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换前&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">PrintMap</span>(m1);<br><span class="hljs-built_in">PrintMap</span>(m2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后&quot;</span> &lt;&lt; endl;<br><br>m1.<span class="hljs-built_in">swap</span>(m2);<br><span class="hljs-built_in">PrintMap</span>(m1);<br><span class="hljs-built_in">PrintMap</span>(m2);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>统计大小——size</li><li>判断是否为空——empty</li><li>交换容器——swap</li></ul><h4 id="3-8-4-map插入和删除"><a href="#3-8-4-map插入和删除" class="headerlink" title="3.8.4 map插入和删除"></a>3.8.4 map插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code> &#x2F;&#x2F;在容器中插入元素。</li><li><code>clear();</code> &#x2F;&#x2F;清除所有元素</li><li><code>erase(pos);</code> &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code> &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key); </code>&#x2F;&#x2F;删除容器中值为key的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key=&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;value=&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m1;<br><span class="hljs-comment">//第一种</span><br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br><span class="hljs-comment">//第二种</span><br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br><span class="hljs-comment">//第三种</span><br>m1.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br><span class="hljs-comment">//第四种</span><br>m1[<span class="hljs-number">4</span>] = <span class="hljs-number">40</span>;<span class="hljs-comment">//不建议这种，用途是利用key访问到value,不存在会自动创建，所以应该确定存在再访问</span><br>cout &lt;&lt; m1[<span class="hljs-number">4</span>] &lt;&lt; endl;<br><br><span class="hljs-built_in">PrintMap</span>(m1);<br><br>m1.<span class="hljs-built_in">erase</span>(m1.<span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">PrintMap</span>(m1);<br><br>m1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//按照key删除</span><br><span class="hljs-built_in">PrintMap</span>(m1);<br><br>m1.<span class="hljs-built_in">erase</span>(m1.<span class="hljs-built_in">begin</span>(), m1.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">PrintMap</span>(m1);<br><br>m1.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">PrintMap</span>(m1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>map插入方式很多，记住其一即可</li><li>插入——insert</li><li>删除——erase</li><li>清空——clear</li></ul><h4 id="3-8-5-map查找和统计"><a href="#3-8-5-map查找和统计" class="headerlink" title="3.8.5 map查找和统计"></a>3.8.5 map查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code> &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code> &#x2F;&#x2F;统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key=&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;value=&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m1;<br><br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator pos = m1.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//返回迭代器</span><br><br><span class="hljs-keyword">if</span> (pos != m1.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了&quot;</span> &lt;&lt;pos-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;pos-&gt;second&lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没找到&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//map不允许插入重复key,count统计为 0 or 1</span><br><span class="hljs-comment">//multimap的count统计可以大于1，可以重复</span><br><span class="hljs-type">int</span> num = m1.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>);<br>cout &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>查找——find(返回的是迭代器)</li><li>统计——cout(对于map,结果为0或1)</li></ul><h4 id="3-8-6-map容器排序"><a href="#3-8-6-map容器排序" class="headerlink" title="3.8.6 map容器排序"></a>3.8.6 map容器排序</h4><p><strong>学习目标：</strong></p><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span><span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> v1 &gt; v2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, MyCompare&gt;&amp; m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, MyCompare&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key=&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;value=&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>,MyCompare&gt;m1;<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">4</span>, <span class="hljs-number">40</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">5</span>, <span class="hljs-number">50</span>));<br><br><span class="hljs-built_in">PrintMap</span>(m1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h2 id="4STL-函数对象"><a href="#4STL-函数对象" class="headerlink" title="4STL-函数对象"></a>4STL-函数对象</h2><h3 id="4-1函数对象"><a href="#4-1函数对象" class="headerlink" title="4.1函数对象"></a>4.1函数对象</h3><h4 id="4-1-1函数对象概念"><a href="#4-1-1函数对象概念" class="headerlink" title="4.1.1函数对象概念"></a>4.1.1函数对象概念</h4><p><strong>概念：</strong></p><ul><li>重载函数调用操作符的类，其对象常称为函数对象</li><li>函数对象使用重载的()时，行为类似函数调用，也叫仿函数</li></ul><p><strong>本质：</strong></p><ul><li>函数对象(仿函数)是一个类，不是一个函数</li></ul><h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2 函数对象使用"></a>4.1.2 函数对象使用</h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdd</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> v1 + v2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyAdd myadd;<br>cout &lt;&lt; <span class="hljs-built_in">myadd</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyPrint</span>()<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;count = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string test)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; test &lt;&lt; endl; <br><span class="hljs-keyword">this</span>-&gt;count++;<br>&#125;<br><br><span class="hljs-type">int</span> count;<span class="hljs-comment">//内部自己状态</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyPrint myprint;<br><span class="hljs-built_in">myprint</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">myprint</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">myprint</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">myprint</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">myprint</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">myprint</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;MyPrint调用次数为:&quot;</span> &lt;&lt; myprint.count &lt;&lt; endl;<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPrint</span><span class="hljs-params">(MyPrint&amp; mp, string test)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">mp</span>(test);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyPrint myPrint;<br><span class="hljs-built_in">doPrint</span>(myPrint, <span class="hljs-string">&quot;hello c++&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-built_in">test03</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2谓词"><a href="#4-2谓词" class="headerlink" title="4.2谓词"></a>4.2谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为谓词</li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreaterFive</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">5</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">//查找容器中，有没有大于5的数字</span><br><span class="hljs-comment">//CreaterFive()匿名函数对象</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">CreaterFive</span>());<br><br><span class="hljs-keyword">if</span> (pos == v.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未找到&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了，大于5的数字为:&quot;</span> &lt;&lt; *pos &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>、<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-3二元谓词"><a href="#4-2-3二元谓词" class="headerlink" title="4.2.3二元谓词"></a>4.2.3二元谓词</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val1,<span class="hljs-type">int</span> val2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val1 &gt; val2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//改变为降序</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">MyCompare</span>());<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数</li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 #include</li></ul><h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code> &#x2F;&#x2F;加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt; </code>&#x2F;&#x2F;减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code> &#x2F;&#x2F;乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code> &#x2F;&#x2F;除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code> &#x2F;&#x2F;取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code> &#x2F;&#x2F;取反仿函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span><span class="hljs-comment">//内建函数对象头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//megate一元仿函数 取反仿函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>negate&lt;<span class="hljs-type">int</span>&gt;n;<br>cout &lt;&lt; <span class="hljs-built_in">n</span>(<span class="hljs-number">50</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//加法仿函数——其他算数仿函数同理</span><br>plus&lt;<span class="hljs-type">int</span>&gt;p;<span class="hljs-comment">//默认认定传的是同种数据类型</span><br>cout &lt;&lt; <span class="hljs-built_in">p</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code> &#x2F;&#x2F;等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt; </code>&#x2F;&#x2F;不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt; </code>&#x2F;&#x2F;大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code> &#x2F;&#x2F;大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code> &#x2F;&#x2F;小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code> &#x2F;&#x2F;小于等于</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> v1 &gt; v2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//sort(v.begin(),v.end(), MyCompare());</span><br><span class="hljs-comment">//greater&lt;int&gt;() 内建函数对象</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code> &#x2F;&#x2F;逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code> &#x2F;&#x2F;逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code> &#x2F;&#x2F;逻辑非</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">bool</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">bool</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//利用逻辑非 将容器v 搬运到容器v2中，并执行取反操作</span><br><br>vector&lt;<span class="hljs-type">bool</span>&gt;v2;<br>v2.<span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(),<span class="hljs-built_in">logical_not</span>&lt;<span class="hljs-type">bool</span>&gt;());<span class="hljs-comment">//()代表对象的创建</span><br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">bool</span>&gt;::iterator it = v2.<span class="hljs-built_in">begin</span>(); it != v2.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5STL-常用算法"><a href="#5STL-常用算法" class="headerlink" title="5STL-常用算法"></a>5STL-常用算法</h2><p><strong>概述:</strong></p><ul><li>算法主要是由头文件&lt; algorithm &gt;&lt; functional &gt; &lt; numeric &gt;组成</li><li>&lt; algorithm &gt;是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等。</li><li>&lt; functional &gt;定义了一些模板类，用以声明函数对象</li><li>&lt; numeric &gt;体积很小，只包括几个在序列上面进行简单数据运算的模板函数</li></ul><h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>for_each </code>&#x2F;&#x2F;遍历容器</li><li>transform &#x2F;&#x2F;搬运容器到另一个容器中</li></ul><h4 id="5-1-1for-each"><a href="#5-1-1for-each" class="headerlink" title="5.1.1for_each"></a>5.1.1for_each</h4><p><strong>功能描述</strong>：</p><ul><li>遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>for_each(iterator beg, iterator end, _func);</code></li></ul><p>&#x2F; 遍历算法 遍历容器元素</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p><strong>&#x2F;&#x2F; _func 函数或者函数对象</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//普通函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print01</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">//仿函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Print02</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),Print01);<br>cout &lt;&lt; endl;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Print02</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：<br>for_each在实际开发中是最常用的遍历算法，需要熟练掌握。</p><h4 id="5-1-2transform"><a href="#5-1-2transform" class="headerlink" title="5.1.2transform"></a>5.1.2transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li>transform(iterator beg1, iterator end1, iterator beg2, _func);</li></ul><p>&#x2F;&#x2F;beg1 源容器开始迭代器</p><p>&#x2F;&#x2F;end1 源容器结束迭代器</p><p>&#x2F;&#x2F;beg2 目标容器开始迭代器</p><p>&#x2F;&#x2F;_func 函数或者函数对象</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransForm</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val + <span class="hljs-number">100</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt;vTarget;<span class="hljs-comment">//目标容器</span><br>vTarget.<span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>());<span class="hljs-comment">//目标容器需要提前开辟空间</span><br><span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">TransForm</span>());<br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), vTarget.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">MyPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：<br>搬运的目标容器必须提前开辟空间，否则无法正常搬运。</p><h3 id="5-2常用查找算法"><a href="#5-2常用查找算法" class="headerlink" title="5.2常用查找算法"></a>5.2常用查找算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li>find &#x2F;&#x2F;查找元素</li><li>find_if &#x2F;&#x2F;按条件查找元素</li><li>adjacent_find &#x2F;&#x2F;查找相邻重复元素</li><li>binary_search &#x2F;&#x2F;二分查找法</li><li>count &#x2F;&#x2F;统计元素个数</li><li>count_if &#x2F;&#x2F;按条件统计元素个数</li></ul><h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(iterator beg, iterator end, value);</code></li></ul><p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; value 查找的元素</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name,<span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br>&#125;<br><span class="hljs-comment">//重载==</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> ==(<span class="hljs-type">const</span> Person&amp; p)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>string m_Name;<br>string m_Age;<br>&#125;;<br><br><br><br><span class="hljs-comment">//内置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>);<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没找到&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-comment">//自定义数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;Person&gt;V;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-number">11</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-number">22</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-number">33</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-number">44</span>)</span></span>;<br><br>V.<span class="hljs-built_in">push_back</span>(p1);<br>V.<span class="hljs-built_in">push_back</span>(p2);<br>V.<span class="hljs-built_in">push_back</span>(p3);<br>V.<span class="hljs-built_in">push_back</span>(p4);<br><br>vector&lt;Person&gt;::iterator it = <span class="hljs-built_in">find</span>(V.<span class="hljs-built_in">begin</span>(), V.<span class="hljs-built_in">end</span>(), p2);<br><span class="hljs-keyword">if</span> (it == V.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没找到&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>总结</strong>：<br>利用find可以在容器中找指定的元素，返回值是迭代器。</p><h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find_if(iterator beg, iterator end, _Pred);</code></li></ul><p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; _Pred 函数或者谓词（返回bool类型的仿函数）</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GreaterFive</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">5</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//内置数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">GreaterFive</span>());<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没找到&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//自定义数据类型</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name,<span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br>&#125;<br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greater20</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Person &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> p.m_Age &gt; <span class="hljs-number">20</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;Person&gt;V;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-number">11</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-number">22</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-number">33</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-number">44</span>)</span></span>;<br><br>V.<span class="hljs-built_in">push_back</span>(p1);<br>V.<span class="hljs-built_in">push_back</span>(p2);<br>V.<span class="hljs-built_in">push_back</span>(p3);<br>V.<span class="hljs-built_in">push_back</span>(p4);<br><br>vector&lt;Person&gt;::iterator it = <span class="hljs-built_in">find_if</span>(V.<span class="hljs-built_in">begin</span>(), V.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Greater20</span>());<br><span class="hljs-keyword">if</span> (it == V.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没找到&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了&quot;</span> &lt;&lt; it-&gt;m_Name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;m_Age &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><code>adjacent_find(iterator beg, iterator end);</code></li></ul><p>&#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">7</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">adjacent_find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没找到&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到相邻重复元素&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p><h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><code>bool binary_search(iterator beg, iterator end, value);</code></li></ul><p>&#x2F;&#x2F; 查找指定的元素，查到 返回true 否则false</p><p>&#x2F;&#x2F; 注意: 在无序序列中不可用</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; value 查找的元素</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">//这个容器必须是有序的序列，如果是无序的序列，结果未知</span><br><span class="hljs-type">bool</span> ret = <span class="hljs-built_in">binary_search</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">9</span>);<br><br><span class="hljs-keyword">if</span> (ret)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没找到&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>count(iterator beg, iterator end, value);</code></li></ul><p>&#x2F;&#x2F; 统计元素出现次数</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; value 统计的元素</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">//内置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">10</span>);<br>cout &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Person&amp; p)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;Person&gt;v;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;s1&quot;</span>,<span class="hljs-number">11</span> )</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;s2&quot;</span>,<span class="hljs-number">12</span> )</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;s3&quot;</span>,<span class="hljs-number">13</span> )</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;s4&quot;</span>,<span class="hljs-number">14</span> )</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;s5&quot;</span>,<span class="hljs-number">14</span> )</span></span>;<br><br>v.<span class="hljs-built_in">push_back</span>(p1);<br>v.<span class="hljs-built_in">push_back</span>(p2);<br>v.<span class="hljs-built_in">push_back</span>(p3);<br>v.<span class="hljs-built_in">push_back</span>(p4);<br>v.<span class="hljs-built_in">push_back</span>(p5);<br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), p5);<br><br>cout &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结： 统计自定义数据类型时候，需要配合重载 operator&#x3D;&#x3D;</p><h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>count_if(iterator beg, iterator end, _Pred);</code></li></ul><p>&#x2F;&#x2F; 按条件统计元素出现次数</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; _Pred 谓词</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greater20</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">20</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Greater20</span>());<br>cout &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br>&#125;<br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeGreater20</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> p.m_Age &gt; <span class="hljs-number">20</span>;<br>&#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;Person&gt;v;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;s1&quot;</span>,<span class="hljs-number">11</span> )</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;s2&quot;</span>,<span class="hljs-number">22</span> )</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;s3&quot;</span>,<span class="hljs-number">33</span> )</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;s4&quot;</span>,<span class="hljs-number">44</span> )</span></span>;<br><br>v.<span class="hljs-built_in">push_back</span>(p1); <br>v.<span class="hljs-built_in">push_back</span>(p2); <br>v.<span class="hljs-built_in">push_back</span>(p3); <br>v.<span class="hljs-built_in">push_back</span>(p4); <br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">AgeGreater20</span>());<br>cout &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：按值统计用count，按条件统计用count_if</p><h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort </code>&#x2F;&#x2F;对容器内元素进行排序</li><li><code>random_shuffle</code> &#x2F;&#x2F;洗牌 指定范围内的元素随机调整次序</li><li><code>merge</code> &#x2F;&#x2F; 容器元素合并，并存储到另一容器中</li><li><code>reverse</code> &#x2F;&#x2F; 反转指定范围的元素</li></ul><h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>sort(iterator beg, iterator end, _Pred);</code></li></ul><p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; _Pred 谓词</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">60</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">//升</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//降</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：sort属于开发中最常用的算法之一，需熟练掌握</p><h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p><ul><li>洗牌 指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>random_shuffle(iterator beg, iterator end);</code></li></ul><p>&#x2F;&#x2F; 指定范围内的元素随机调整次序</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),myPrint);<br>cout &lt;&lt; endl;<br><br><span class="hljs-built_in">random_shuffle</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子</li></ul><h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></li></ul><p>&#x2F;&#x2F; 容器元素合并，并存储到另一容器中<br>&#x2F;&#x2F; 注意: 两个容器必须是<strong>有序的</strong><br>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>&#125;<br><span class="hljs-comment">//目标容器</span><br>vector&lt;<span class="hljs-type">int</span>&gt;vTarget;<br>vTarget.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>() + v2.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-built_in">merge</span>(v1.<span class="hljs-built_in">begin</span>(),v1.<span class="hljs-built_in">end</span>(),v2.<span class="hljs-built_in">begin</span>(),v2.<span class="hljs-built_in">end</span>(),vTarget.<span class="hljs-built_in">begin</span>());<br><br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), vTarget.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：merge合并的两个容器必须的有序序列</p><h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reverse(iterator beg, iterator end);</code></li></ul><p>&#x2F;&#x2F; 反转指定范围的元素</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">60</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br><br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br><br><span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：reverse反转区间内元素，面试题可能涉及到</p><h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>copy</code> &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code> &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if</code> &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code> &#x2F;&#x2F; 互换两个容器的元素</li></ul><h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>copy(iterator beg, iterator end, iterator dest);</code></li></ul><p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; dest 目标起始迭代器</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br>v2.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>());<br><span class="hljs-built_in">copy</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>());<br><br>for_each(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></li></ul><p>&#x2F;&#x2F; 将区间内旧元素 替换成 新元素</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; oldvalue 旧元素</p><p>&#x2F;&#x2F; newvalue 新元素</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">60</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;替换前&quot;</span> &lt;&lt; endl;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;替换后&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">replace</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">20</span>, <span class="hljs-number">2000</span>);<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：replace会替换区间内满足条件的元素</p><h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong></p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code></li></ul><p>&#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; _pred 谓词</p><p>&#x2F;&#x2F; newvalue 替换的新元素</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Great30</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">30</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">60</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;替换前&quot;</span> &lt;&lt; endl;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;替换后&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">replace_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">Great30</span>(),<span class="hljs-number">3000</span>);<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：<br>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p><ul><li>互换两个容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(container c1, container c2);</code></li></ul><p>&#x2F;&#x2F; 互换两个容器的元素</p><p>&#x2F;&#x2F; c1容器1</p><p>&#x2F;&#x2F; c2容器2</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">100</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换前&quot;</span> &lt;&lt; endl;<br>for_each(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), MyPrint);<br>cout &lt;&lt; endl;<br><br>for_each(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), MyPrint);<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">swap</span>(v1, v2);<br><br>for_each(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), MyPrint);<br>cout &lt;&lt; endl;<br><br>for_each(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), MyPrint);<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：swap交换容器时，注意交换的容器要同种类型</p><h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <strong>#include <numeric></strong></li></ul><p><strong>算法简介：</strong></p><ul><li><code>accumulate</code> &#x2F;&#x2F; 计算容器元素累计总和</li><li><code>fill</code> &#x2F;&#x2F; 向容器中添加元素</li></ul><h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p><ul><li>计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><code>accumulate(iterator beg, iterator end, value);</code></li></ul><p>&#x2F;&#x2F; 计算容器元素累计总和</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; value 起始值</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-comment">//参数3是起始累加值</span><br><span class="hljs-type">int</span> total = <span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>cout &lt;&lt; total &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：accumulate使用时头文件注意是 numeric，这个算法很实用</p><h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li>·fill(iterator beg, iterator end, value);</li></ul><p>&#x2F;&#x2F; 向容器中填充元素</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; value 填充的值</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//后期重新填充</span><br><span class="hljs-built_in">fill</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">100</span>);<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), MyPrint);<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：利用fill可以将容器区间内元素填充为指定的值</p><h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>set_intersection</code> &#x2F;&#x2F; 求两个容器的交集</li><li><code>set_union</code> &#x2F;&#x2F; 求两个容器的并集</li><li><code>set_difference</code> &#x2F;&#x2F; 求两个容器的差集</li></ul><h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></li></ul><p>&#x2F;&#x2F; 求两个集合的交集</p><p>&#x2F;&#x2F; 注意:两个集合必须是有序序列</p><p>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt;vTarget;<br><span class="hljs-comment">//最特殊情况，大容器包含小容器，开辟空间 取消的容器的size即可</span><br>vTarget.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">min</span>(v1.<span class="hljs-built_in">size</span>(),v2.<span class="hljs-built_in">size</span>()));<br><br><span class="hljs-comment">//返回迭代器的位置是交集的末尾位置，帮助下面for_each划定区间</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = <span class="hljs-built_in">set_intersection</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());<br><br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, MyPrint);<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>:</p><ul><li>求交集的两个容器必须得是有序序列。</li><li>目标容器开辟空间需要从两个容器中取小值。</li><li>set_intersection返回值(迭代器)是交集中最后一个元素的位置。</li></ul><h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></li></ul><p>&#x2F;&#x2F; 求两个集合的并集</p><p>&#x2F;&#x2F; 注意:两个集合必须是有序序列</p><p>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt;vTarget;<br>vTarget.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>() + v2.<span class="hljs-built_in">size</span>());<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = <span class="hljs-built_in">set_union</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());<br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, MyPrint);<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要两个容器相加</li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3 set_difference"></a>5.6.3 set_difference</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></li></ul><p>&#x2F; 求两个集合的差集</p><p>&#x2F;&#x2F; 注意:两个集合必须是有序序列</p><p>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>&#125;<br><span class="hljs-comment">//考虑特殊情况</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt;vTarget;<br><span class="hljs-comment">//最特殊情况 两个容器没有交集 取两个容器大的size作为目标容器开辟的空间</span><br>vTarget.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">max</span>(v1.<span class="hljs-built_in">size</span>(), v2.<span class="hljs-built_in">size</span>()));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;v1和v2的差集&quot;</span> &lt;&lt; endl;<br><br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = <span class="hljs-built_in">set_difference</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());<br><br>for_each(vTarget.<span class="hljs-built_in">begin</span>(),itEnd, MyPrint);<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;v2和v1的差集&quot;</span> &lt;&lt; endl;<br><br>itEnd = <span class="hljs-built_in">set_difference</span>(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());<br><br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, MyPrint);<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从两个容器取较大值</li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>摄影知识学习</title>
    <link href="/2023/06/09/%E6%91%84%E5%BD%B1%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/06/09/%E6%91%84%E5%BD%B1%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="摄影知识学习"><a href="#摄影知识学习" class="headerlink" title="摄影知识学习"></a>摄影知识学习</h1><p>单反和微单区别于内部光学结构构造不同，均可添加镜头</p><p>避免产生误区：</p><ul><li>单反并不一定比微单强</li><li>单反并不一定比微单贵</li></ul><p>PS：APS-C画幅是略小于全画幅的画幅大小</p><span id="more"></span><h2 id="1、相机产品线"><a href="#1、相机产品线" class="headerlink" title="1、相机产品线"></a>1、相机产品线</h2><h3 id="1-1佳能（Canon）相机产品线（EOS）"><a href="#1-1佳能（Canon）相机产品线（EOS）" class="headerlink" title="1.1佳能（Canon）相机产品线（EOS）"></a>1.1佳能（Canon）相机产品线（EOS）</h3><p>单反：D-EF&#x2F;EF-S</p><ul><li>0D：全系列全画幅单反（5D4  &#x2F;  6D2 &#x2F; 1DX3）及一款旗舰APS-C单反（7D2）</li><li>00D：高端APS-C单反（90D）</li><li>000D：中端APS-C画幅数码单反（850D）</li><li>0000D：低端APS-C画幅数码单反</li></ul><p>推荐使用850D以上等级相机作为入门</p><p>微单：R-RF&#x2F;M-EF-M</p><p>R&#x2F;RP:一代试水机&#x2F;全画幅专微</p><p>R5:高端Full-Frame专微</p><p>R6:入门Full-Frame专微</p><p>M5:高端APS-C微单</p><p>M6:中高端APS-C微单</p><p>M00:中端APS-C微单e.g. 佳能M50</p><p>M000:低端APS-C微单   e.g. 佳能 M200</p><h3 id="1-2尼康（Nikon）相机产品线"><a href="#1-2尼康（Nikon）相机产品线" class="headerlink" title="1.2尼康（Nikon）相机产品线"></a>1.2尼康（Nikon）相机产品线</h3><p>单反：F-FX&#x2F;DX(F系列有FX和DX两个卡口)</p><p>D0：全画幅旗舰单反(D6)”速度机”</p><p>D000:高端（旗舰）全画幅单反（D850&#x2F;D780）</p><p>​及一款APS-C旗舰单反（D500）</p><p>D0000：APS-C画幅数码单反</p><p>微单：Z-FX&#x2F;DX（Z系列有FX何DX两个卡口）</p><p>Z7：全画幅旗舰微单</p><p>Z6：全画幅中端微单</p><p>Z5：全画幅低端微单</p><p>Z50：APS-C微单 </p><h3 id="1-3索尼（SONY）相机产品线"><a href="#1-3索尼（SONY）相机产品线" class="headerlink" title="1.3索尼（SONY）相机产品线"></a>1.3索尼（SONY）相机产品线</h3><p>（微单A&#x2F;α-E-FE&#x2F;E）（叫A系列或者阿尔法系列，有E卡口或者FE卡口）</p><p>A6X00：APS-C画幅微单（A6100    A6400    A6600）</p><p>A7R：画质型全画幅微单（A7R IV）</p><p>A7：均衡型全画幅微单（A7 III）</p><p>A7S：视频型全画幅微单（A7S III）</p><p>A9：速度型全画幅旗舰微单（A9 II）</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306091314590.png" alt="image-20230423132005370"></p><h2 id="2、镜头"><a href="#2、镜头" class="headerlink" title="2、镜头"></a>2、镜头</h2><h3 id="1-1按品牌分："><a href="#1-1按品牌分：" class="headerlink" title="1.1按品牌分："></a>1.1按品牌分：</h3><p>原厂：佳能      尼康     索尼</p><p>副厂：SIGMA     ZEISS   TAMRON</p><h3 id="1-2按焦距分："><a href="#1-2按焦距分：" class="headerlink" title="1.2按焦距分："></a>1.2按焦距分：</h3><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306091312409.png" alt="image-20230423132414108"></p><p><strong>多少多少毫米</strong></p><p><strong>数字越小，代表视角越广，看到的范围越大，容纳的越广阔，画面中单个主体的占比越小</strong></p><p><strong>数字越大，视角越窄，看到的范围小，单个主体在画面中的占比越大</strong></p><h3 id="1-3其他分类"><a href="#1-3其他分类" class="headerlink" title="1.3其他分类"></a>1.3其他分类</h3><ol><li>变焦与定焦</li><li>手动对焦与自动对焦</li><li>恒定光圈与浮动光圈</li></ol><p>光圈越大，f值的数字越小，恒定光圈好于浮动光圈，一般恒定光圈越大镜头就越好。</p><h3 id="1-4镜头参数"><a href="#1-4镜头参数" class="headerlink" title="1.4镜头参数"></a>1.4镜头参数</h3><ul><li>镜头信息识别</li></ul><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306091313958.png" alt="image-20230423133312793"></p><p><strong>恒定光圈代表在不同的焦段都可以使用到这个最大光圈</strong></p><p><strong>尼康的防抖叫做VR，佳能的防抖叫做IS，索尼的防抖叫做OSS</strong></p><ul><li>镜头前口径</li><li>防抖及防抖模式</li></ul><p>​稳定开关，稳定模式选择（包括上下左右都防抖和只防抖上下）</p><ul><li>对焦模式</li></ul><p>​AF和MF，AF代表自动对焦，MF代表手动对焦</p><ul><li>锁定按钮</li></ul><p>​锁住以后就不能进行变焦</p><ul><li>对焦&#x2F;变焦环</li><li>等等</li></ul><h3 id="1-5镜头里的“黑话”"><a href="#1-5镜头里的“黑话”" class="headerlink" title="1.5镜头里的“黑话”"></a>1.5镜头里的“黑话”</h3><ul><li>牛头  狗头：垃圾镜头叫狗头   好的镜头叫牛头</li><li>大光定：大光圈定焦镜头的缩写</li><li>大三元&#x2F;小三元：覆盖非常全的变焦镜头</li><li>红圈&#x2F;金圈&#x2F;G-Master：分别是佳能尼康索尼中具代表性的优秀镜头</li><li>天涯镜&#x2F;小痰盂：大的变焦比的镜头（例28-300的变焦镜头）叫天涯镜</li><li>饼干头&#x2F;大炮：个头比较小，比较薄的镜头叫饼干头</li><li>“灭门”：把整个品牌的系统全部换掉（相机和镜头都换）</li><li>牙膏厂：一次只更新一部分（canon）</li></ul><h3 id="常见镜头介绍：变焦镜头"><a href="#常见镜头介绍：变焦镜头" class="headerlink" title="常见镜头介绍：变焦镜头"></a>常见镜头介绍：变焦镜头</h3><p>变焦镜头：覆盖了较多的焦段，站着不动只需进行变焦去拍摄。</p><ul><li>大三元：16-35&#x2F;14-24 F2.824-70 F2.870-200 F2.8</li><li>小三元：16-35&#x2F;11-24 F4     24-70 F4        70-200   F4</li><li>其他：18-55(套头)    100-400    150-600<img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306091313400.png" alt="image-20230423153849404"></li></ul><h3 id="1-6常见镜头介绍：定焦镜头"><a href="#1-6常见镜头介绍：定焦镜头" class="headerlink" title="1.6常见镜头介绍：定焦镜头"></a>1.6常见镜头介绍：定焦镜头</h3><p>定焦镜头</p><p>推荐使用f1.8，资金充裕使用f1.4   f1.2</p><h3 id="1-7常见镜头介绍：第一支全画幅镜头推荐"><a href="#1-7常见镜头介绍：第一支全画幅镜头推荐" class="headerlink" title="1.7常见镜头介绍：第一支全画幅镜头推荐"></a>1.7常见镜头介绍：第一支全画幅镜头推荐</h3><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306091313238.png" alt="image-20230423154408407"></p><p>推荐使用中焦或者中长焦，对于光圈，F2.8是大光圈相较于F4（后边跟的数字越小代表光圈越大）</p><h3 id="1-8常见镜头介绍：全画幅镜头组合推荐"><a href="#1-8常见镜头介绍：全画幅镜头组合推荐" class="headerlink" title="1.8常见镜头介绍：全画幅镜头组合推荐"></a>1.8常见镜头介绍：全画幅镜头组合推荐</h3><ul><li>只选一支：24-70&#x2F;24-105</li><li>选择两支：16-35+70-200&#x2F;100-400</li><li>选择三支：两支+50或大三元</li><li>三支以上：+35+85等等</li></ul><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306091313470.png" alt="image-20230423154918676"></p><h2 id="3、如何选购适合自己的相机"><a href="#3、如何选购适合自己的相机" class="headerlink" title="3、如何选购适合自己的相机"></a>3、如何选购适合自己的相机</h2><ol><li>最高预算</li><li>用途和需求</li><li>自己的个人偏好（外观&#x2F;微单或单反）</li><li>易用性&#x2F;新手友好度（体验和操控）</li></ol><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306091313272.png" alt="image-20230423155800888"></p><h2 id="4、关于相机和器材的名词"><a href="#4、关于相机和器材的名词" class="headerlink" title="4、关于相机和器材的名词"></a>4、关于相机和器材的名词</h2><p><strong>像素</strong>：高像素会让照片看起来更加清晰，有更多的裁剪空间，但是不能一味地追求高像素。</p><p>高像素的两大缺点</p><ul><li>一张照片内存占的大</li><li>后期处理照片需要更高的电脑配置</li></ul><p><strong>宽容度与动态范围</strong></p><p><strong>宽容度</strong>是指相机本身能够容纳（记录）的从最亮到最暗的范围</p><p><strong>动态范围</strong>是指成像照片或现场场景中最亮到最暗的范围区间</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306091313876.png" alt="image-20230423160628726"></p><h3 id="4-1相机性能评判要点"><a href="#4-1相机性能评判要点" class="headerlink" title="4.1相机性能评判要点"></a>4.1相机性能评判要点</h3><ul><li>外观及重量</li><li>便携性与耐候性</li><li>体验与操控性</li><li>画质与像素</li><li>对焦与连拍</li><li>视频性能*</li><li>拓展接口及镜头系统</li></ul><h3 id="4-2优质器材信息网站推荐"><a href="#4-2优质器材信息网站推荐" class="headerlink" title="4.2优质器材信息网站推荐"></a>4.2优质器材信息网站推荐</h3><ul><li>器材官网</li><li>DPReview</li><li>相机笔记</li><li>影响狗</li></ul><h2 id="5、关于拍摄和操作的名词"><a href="#5、关于拍摄和操作的名词" class="headerlink" title="5、关于拍摄和操作的名词"></a>5、关于拍摄和操作的名词</h2><p><strong>拍摄格式</strong>：RAW OR JPG</p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306091313949.png" alt="image-20230423161615050"></p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306091313531.png" alt="image-20230423161817534"></p><p><strong>联机拍摄</strong>：Capture one（软件名）</p><h2 id="6、相机的基础操作"><a href="#6、相机的基础操作" class="headerlink" title="6、相机的基础操作"></a>6、相机的基础操作</h2><h3 id="6-1设置手中的相机"><a href="#6-1设置手中的相机" class="headerlink" title="6.1设置手中的相机"></a>6.1设置手中的相机</h3><p>如何熟悉相机</p><ul><li>了解按钮的作用，多按按</li><li>知道常用的设置在哪里，多找找</li><li>形成肌肉记忆，多用用</li></ul><p>通用设置思路</p><ul><li>设置双卡记录（如果有）</li><li>设置RAW格式记录</li><li>关闭长时间曝光降噪</li><li>自定义复合个人习惯的设置</li></ul><h3 id="6-2相机的基础操作"><a href="#6-2相机的基础操作" class="headerlink" title="6.2相机的基础操作"></a>6.2相机的基础操作</h3><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306091313823.png" alt="image-20230423164049951"></p><h2 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h2><p>景深是指清晰的范围</p><p>光圈越大，景深越浅，拍摄的清晰的范围也就越小，背景虚化也就更明显</p><p>光圈越小，景深越深，拍摄的清晰的范围也就越大，背景虚化也就不怎么明显</p><h2 id="光圈和快门速度和感光度"><a href="#光圈和快门速度和感光度" class="headerlink" title="光圈和快门速度和感光度"></a>光圈和快门速度和感光度</h2><p>光圈大小一般以f&#x2F;1.4、f&#x2F;2等显示，后边的数字是圆的半径（猜测1.4即为根号二，2即为根号4）</p><p>光圈越大，进光量越多</p><p>光圈越大，景深越浅，虚化越厉害</p><p>光圈毎降一档，进光量就减少一半</p><p>故形象的比喻就是：进光量是水的流量，想要注入同样的水。光圈越大，快门速度越快；光圈变小，快门速度变慢才可以达到效果</p><p>快门：1&#x2F;100s 比1&#x2F;200s多一倍的进光量，因为快门速度慢，所以进的光多（仔细想想就明白了）</p><p>ISO：ISO200比ISO100多一倍的进光量，但是ISO越大可能带来的噪点越多。</p><p>ISO越低，画质越好（原生感光度）</p><h2 id="相机档位"><a href="#相机档位" class="headerlink" title="相机档位"></a>相机档位</h2><p>AUTO：自动档，相机自己计算好，不用管</p><p>P档：也是自动档，但是不会自动弹出闪光灯</p><p>S档：快门速度优先，其他的相机决定好（可以理解为运动档）</p><p>A档：光圈优先，自己控制光圈</p><p>M档：全手动档，全部都由自己控制（老法师档）</p><h2 id="曝光值"><a href="#曝光值" class="headerlink" title="曝光值"></a>曝光值</h2><p>​在曝光的时候，通常用<strong>快门速度</strong>(T)和<strong>光圈值</strong>(f)的组合来表示，为简单起见，曾经用Light Value (LV)来表示，现在统一用<strong>Exposure Value</strong> (EV，<strong>曝光值</strong>)来表示。</p><p>​对于同一被摄体的亮度而言，即使光圈值任意改变，如果快门速度进行相应的调整，则通过镜头光圈的光束的容量是等价的，就是曝光量是一样的，就可以用一个数值来表示这些组合，这个数值就是EV。比如下列的组合都是具有同样的曝光量，即为EV a：</p><table><thead><tr><th>组合</th><th>光圈值</th><th>快门速度</th><th>EV值</th></tr></thead><tbody><tr><td>1</td><td>f&#x2F;2.8</td><td>1&#x2F;250s</td><td>11</td></tr><tr><td>2</td><td>f&#x2F;4</td><td>1&#x2F;125s</td><td>11</td></tr><tr><td>3</td><td>f&#x2F;5.6</td><td>1&#x2F;60s</td><td>11</td></tr><tr><td>4</td><td>f&#x2F;8</td><td>1&#x2F;30s</td><td>11</td></tr><tr><td>5</td><td>f&#x2F;11</td><td>1&#x2F;15s</td><td>11</td></tr></tbody></table><p>假定所设定的光圈值为f，快门速度为T，则有如下关系：</p><p>2<sup>EV </sup>&#x3D; f<sup>2</sup>&#x2F;T –&gt; EV &#x3D; log<sub>2</sub>(f<sup>2</sup>&#x2F;T)</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th><th>17</th><th>18</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1&#x2F;2</td><td>1&#x2F;4</td><td>1&#x2F;8</td><td>1&#x2F;15</td><td>1&#x2F;30</td><td>1&#x2F;60</td><td>1&#x2F;125</td><td>1&#x2F;250</td><td>1&#x2F;500</td><td>1&#x2F;1000</td><td>1&#x2F;2000</td><td>1&#x2F;4000</td><td>1&#x2F;8000</td><td>1&#x2F;16000</td><td></td><td></td><td></td><td></td></tr><tr><td>1.4</td><td>2</td><td>1</td><td>1&#x2F;2</td><td>1&#x2F;4</td><td>1&#x2F;8</td><td>1&#x2F;15</td><td>1&#x2F;30</td><td>1&#x2F;60</td><td>1&#x2F;125</td><td>1&#x2F;250</td><td>1&#x2F;500</td><td>1&#x2F;1000</td><td>1&#x2F;2000</td><td>1&#x2F;4000</td><td>1&#x2F;8000</td><td>1&#x2F;16000</td><td></td><td></td><td></td></tr><tr><td>2</td><td>4</td><td>2</td><td>1</td><td>1&#x2F;2</td><td>1&#x2F;4</td><td>1&#x2F;8</td><td>1&#x2F;15</td><td>1&#x2F;30</td><td>1&#x2F;60</td><td>1&#x2F;125</td><td>1&#x2F;250</td><td>1&#x2F;500</td><td>1&#x2F;1000</td><td>1&#x2F;2000</td><td>1&#x2F;4000</td><td>1&#x2F;8000</td><td>1&#x2F;16000</td><td></td><td></td></tr><tr><td>2.8</td><td>8</td><td>4</td><td>2</td><td>1</td><td>1&#x2F;2</td><td>1&#x2F;4</td><td>1&#x2F;8</td><td>1&#x2F;15</td><td>1&#x2F;30</td><td>1&#x2F;60</td><td>1&#x2F;125</td><td>1&#x2F;250</td><td>1&#x2F;500</td><td>1&#x2F;1000</td><td>1&#x2F;2000</td><td>1&#x2F;4000</td><td>1&#x2F;8000</td><td>1&#x2F;16000</td><td></td></tr><tr><td>4</td><td>15</td><td>8</td><td>4</td><td>2</td><td>1</td><td>1&#x2F;2</td><td>1&#x2F;4</td><td>1&#x2F;8</td><td>1&#x2F;15</td><td>1&#x2F;30</td><td>1&#x2F;60</td><td>1&#x2F;125</td><td>1&#x2F;250</td><td>1&#x2F;500</td><td>1&#x2F;1000</td><td>1&#x2F;2000</td><td>1&#x2F;4000</td><td>1&#x2F;8000</td><td>1&#x2F;16000</td></tr><tr><td>5.6</td><td>30</td><td>15</td><td>8</td><td>4</td><td>2</td><td>1</td><td>1&#x2F;2</td><td>1&#x2F;4</td><td>1&#x2F;8</td><td>1&#x2F;15</td><td>1&#x2F;30</td><td>1&#x2F;60</td><td>1&#x2F;125</td><td>1&#x2F;250</td><td>1&#x2F;500</td><td>1&#x2F;1000</td><td>1&#x2F;2000</td><td>1&#x2F;4000</td><td>1&#x2F;8000</td></tr><tr><td>8</td><td>60</td><td>30</td><td>15</td><td>8</td><td>4</td><td>2</td><td>1</td><td>1&#x2F;2</td><td>1&#x2F;4</td><td>1&#x2F;8</td><td>1&#x2F;15</td><td>1&#x2F;30</td><td>1&#x2F;60</td><td>1&#x2F;125</td><td>1&#x2F;250</td><td>1&#x2F;500</td><td>1&#x2F;1000</td><td>1&#x2F;2000</td><td>1&#x2F;4000</td></tr><tr><td>11</td><td>125</td><td>60</td><td>30</td><td>15</td><td>8</td><td>4</td><td>2</td><td>1</td><td>1&#x2F;2</td><td>1&#x2F;4</td><td>1&#x2F;8</td><td>1&#x2F;15</td><td>1&#x2F;30</td><td>1&#x2F;60</td><td>1&#x2F;125</td><td>1&#x2F;250</td><td>1&#x2F;500</td><td>1&#x2F;1000</td><td>1&#x2F;2000</td></tr><tr><td>16</td><td>250</td><td>125</td><td>60</td><td>30</td><td>15</td><td>8</td><td>4</td><td>2</td><td>1</td><td>1&#x2F;2</td><td>1&#x2F;4</td><td>1&#x2F;8</td><td>1&#x2F;15</td><td>1&#x2F;30</td><td>1&#x2F;60</td><td>1&#x2F;125</td><td>1&#x2F;250</td><td>1&#x2F;500</td><td>1&#x2F;1000</td></tr><tr><td>22</td><td>500</td><td>250</td><td>125</td><td>60</td><td>30</td><td>15</td><td>8</td><td>4</td><td>2</td><td>1</td><td>1&#x2F;2</td><td>1&#x2F;4</td><td>1&#x2F;8</td><td>1&#x2F;15</td><td>1&#x2F;30</td><td>1&#x2F;60</td><td>1&#x2F;125</td><td>1&#x2F;250</td><td>1&#x2F;500</td></tr><tr><td>32</td><td>1000</td><td>500</td><td>250</td><td>125</td><td>60</td><td>30</td><td>15</td><td>8</td><td>4</td><td>2</td><td>1</td><td>1&#x2F;2</td><td>1&#x2F;4</td><td>1&#x2F;8</td><td>1&#x2F;15</td><td>1&#x2F;30</td><td>1&#x2F;60</td><td>1&#x2F;125</td><td>1&#x2F;250</td></tr></tbody></table><p>表格中没有罗列出的EV值也能求出，但有可能是负值。</p><p>从表格看，对于<strong>同样的光圈值</strong>(f)，<strong>快门速度相差一级</strong> (或者对于同样的快门速度，光圈值相差一级)，曝光值就<strong>相差1</strong>，就称为<strong>曝光量相差一档</strong>。</p><h2 id="影调"><a href="#影调" class="headerlink" title="影调"></a>影调</h2><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202306271608884.png" alt="image-20230627160756113"></p><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>x轴代表从0-255的像素值，y轴代表该像素值的个数</p><p>波峰靠左为暗调，波峰靠右为亮调，波峰在中间为中间调</p><p>在颜色直方图中，只有右边的颜色才会出现在图片中，左边的颜色并不会出现，只代表RGB颜色通道中有这个颜色（因为像素值很低，几乎等于没有，所以不会出现）</p><h2 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h2><p>对比度的增加可以提升曝光，降低阴影。</p><h2 id="调色曲线"><a href="#调色曲线" class="headerlink" title="调色曲线"></a>调色曲线</h2><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307071034394.png" alt="image-20230707103445078"></p><p>曲线的横坐标为调色前的各亮度值，纵坐标为调色后的亮度值</p><p>故没调色之前是y&#x3D;x的直线，通过改变亮度值就可以重塑直方图</p><p> <img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307071044115.png" alt="image-20230707104453077"></p><p><strong>胶片灰的调色</strong> </p><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307071049692.png" alt="image-20230707104905627"></p><p>在RGB三个曲线中</p><p>如果增加红色的亮度，则会变得更红；如果减少红色的亮度，则会偏<strong>青色</strong></p><p>如果增加绿色的亮度，则会变得更绿；如果减少绿色的亮度，则会偏<strong>洋红色</strong></p><p>如果增加蓝色的亮度，则会变得更蓝；如果减少蓝色的亮度，则会偏<strong>黄色</strong></p><h2 id="城市夜景人文调色思路"><a href="#城市夜景人文调色思路" class="headerlink" title="城市夜景人文调色思路"></a><strong>城市夜景人文调色思路</strong></h2><p>降低色温</p><p>降低色调</p><p>提亮阴影</p><p>二次构图</p><h2 id="分离色调工具"><a href="#分离色调工具" class="headerlink" title="分离色调工具"></a>分离色调工具</h2><p><img src="https://feng-typora-picture-bed.oss-cn-beijing.aliyuncs.com/img_for_typora202307071107893.png" alt="image-20230707110757805"></p><p>曲线工具只有红、绿、蓝、青、洋红、黄6种颜色</p><p>分离色调有360中颜色，但是只能改变区域（例如高光和阴影），不能精确的选择出哪个亮度所在的区域</p>]]></content>
    
    
    <categories>
      
      <category>摄影</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摄影知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超分辨率</title>
    <link href="/2023/06/07/%E8%B6%85%E5%88%86/"/>
    <url>/2023/06/07/%E8%B6%85%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>图像的高频和低频：</p><p>图像中的<strong>高频分量</strong>，指的是图像强度（亮度&#x2F;灰度）<strong>变化剧烈的地方</strong>，也就是我们常说的边缘（轮廓）；</p><p>图像中的<strong>低频分量</strong>，指的是图像强度（亮度&#x2F;灰度）<strong>变换平缓的地方</strong>，也就是大片色块的地方。</p><p>人眼对图像中的<strong>高频信号</strong>更为敏感。 图像的高低频是对图像各个位置之间强度变化的一种度量方法。</p><span id="more"></span><p>低频分量:主要对整副图像的强度的综合度量。</p><p>高频分量:主要是对图像边缘和轮廓的度量。</p><p>著名 的超分辨率神经架构：VDSR和EDSR</p><p>AdderNet可以减少运算，但是并不能减少运算时间，同时他也不能提高超分图片的PSNR值，这是他存在的缺陷。</p>]]></content>
    
    
    
    <tags>
      
      <tag>重建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
